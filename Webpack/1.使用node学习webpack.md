## webpack-cli

**学习前提**

- `webpack` 的大部分项目中，都需要使用 `webpack.config.js` 来配置 `webpack`
- 但不建议使用 `webpack.config.js` 配置文件的方式来学习 `webpack`，太难调试了

在终端执行 `webpack` 命令时发生了什么？

```bash
$ webpack
```

1. 如果直接运行 `npx webpack`，会在 `node_modules/webpack/package.json` 中找到 `bin` 语句，最终执行 `bin/webpack.js`

   **bin 字段是 npm 包命令行工具的入口**

   ![image-20220824102543558](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824102543558.png)

2. 调用执行 `webpack` 包对应的 `bin/webpack.js` 文件，然后继续调用 `webpack-cli` 包

   ![image-20220824093215178](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824093215178.png)

3. 之后调用执行 `webpack-cli` 包对应的 `bin/cli.js` 文件

   ![image-20220824094047238](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824094047238.png)

4. 执行 `webpack-cli/bin/cli.js` 相当于找 `node_modules/.bin` 下面的 `webapck` 相关命令

   ![image-20220824104129644](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824104129644.png)

   这个 cmd 文件核心就是组装了 `node ../node_modules/webpack/bin/webpack.js ` 命令，并执行

   ![image-20220824092322716](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824092322716.png)

5. 最后还是调用执行 `webpack/bin/webpack.js` ，并执行 `webpack` 包的 API 进行打包

## webpack api 简介

使用 `webpack api` 也特别容易，将以前 `webpack.config.js` 的配置，作为参数传递给 `webpack` 函数即可

```js
const webpack = require('webpack')

const compiler = webpack({
  // webpack 的诸多配置置于此处
  entry: './index.js'
})

compiler.run((err, stat) => {
  // 在 stat 中可获取关于构建的时间及资源等信息
})
```

使用 `webpack` 进行学习及测试也非常方便，比如使用它测试不同 mode 对打包资源的影响：

```js
webpack([
  {
    entry: './index.js',
    mode: 'production',
    output: {
      filename: 'main.production.js'
    }
  },
  {
    entry: './index.js',
    mode: 'development',
    output: {
      filename: 'main.development.js'
    }
  },
  {
    entry: './index.js',
    output: {
      filename: 'main.unknown.js'
    }
  }
]).run((err, stat) => {

})
```

## 最简示例

执行如下代码，用以查看构建示例，在 webpack 编译结束后，可拿到 [Stat](https://webpack.js.org/api/stats/#structure) 对象，其中包含诸多编译时期的信息

- 比如：可通过该对象获得打包后所有资源体积以及编译时间

```js
function compiler () {
  return webpack({
    entry: './index.js',
    mode: 'none',
    output: {
      // 添加 IIFE 外层包裹生成的代码 默认 true 此处关了是方便调试
      iife: false,
      /* 
        pathinfo：是否在 bundle 中引入「所包含模块信息」的相关注释
        生产环境(production)下，不应该使用
        如果使用 mode = 'development'，默认值为 true
        如果使用 mode = 'production'，默认值为 false
        值为 'verbose' 时，会显示更多信息
      */
      pathinfo: 'verbose'
    }
  })
}

compiler().run((err, stat) => {
  console.log(stat.toJson())
})
```

通过断点调试或执行如下命令，获取对应数据结果

```bash
# jq 需要手动安装，是一个 JSON 处理器
$ node build.js | jq -C "." | less
```

![image-20220824112413281](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824112413281.png)

## 调试源码

### 编译时间如何计算

思路：从后往前分析，从结果触发，看调用堆栈

1. `.run` 的回调函数能拿到 err 和 stat 参数，那就将断点先打到回调函数体内，通过调用堆栈去找 stat

   ![image-20220824145301149](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824145301149.png)

2. 点击堆栈中的第二行，到了 callback 的调用位置，明确目标，我们要找到 stats 是如何传递的，于是关注到 callback 在 finalCallback 函数体内，这个函数接收到 stats 参数，所以要去找这个函数的调用位置

   ![image-20220824145808206](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824145808206.png)

3. 继续点击调用堆栈第三行，这时就来到调用 finalCallback 的位置，这里传递了 stats

   这时就不需要再调用堆栈里找了，因为我们已经定位到位置，现在需要去搜索 stats 变量在哪里定义和赋值的即可

   ![image-20220824150740173](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824150740173.png)

   这里会发现有有一个 startTime，再去找它的声明和赋值的位置

   ![image-20220824151741452](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824151741452.png)

4. 在第 3 步分析中，有一个关键词的位置 `new Stats(compilation)`，这里传入了 `compilation` 变量，这个变量上面有很多属性和方法（例如：startTime 和 endTime）

   进到了 Stats 中，会发现 `get startTime` 和 `get endTime` 这两个方法，返回的就是 `compilation` 上的 startTime 和 endTime

   ![image-20220824152927038](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824152927038.png)

### webpack 命令时的流程

命令行接口（Cli）：为了更合适且方便地使用配置，可以在 `webpack.config.js` 中对 `webpack` 进行配置。Cli 中传入的任何参数会在配置文件中映射为对应的参数

```bash
npx webpack --help
```

**使用 webpack-cli**

- 命令行运行

   ```bash
   npx webpack --entry ./index.js --output-path build
   ```

- `webpack.config.js`

   ```js
   const path = require('path')
   module.exports = {
     entry: './index.js',
     output: {
       path: path.resolve(__dirname, 'build')
     },
     mode: 'none'
   }
   ```

   之后使用命令行运行

   ```bash
   npx webpack
   ```


**开始调试**

我们知道，在使用 webpack-cli 的时候，实际上会去找 `node_modules/webpack`、`node_modules/webpack-cli` 依赖包的 `package.json` 中定义的 bin字段所对应的文件

> bin 字段用来指定各个内部命令对应的可执行文件的位置（npm 包命令行工具的入口）
>
> - [https://docs.npmjs.com/cli/v8/configuring-npm/package-json/#bin](https://docs.npmjs.com/cli/v8/configuring-npm/package-json/#bin)

webpack

![image-20220824102543558](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824102543558.png)

在 `bin/webpack.js` 中加入断点，直接开始调试即可

![image-20220824161047441](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220824161047441.png)

## 作业

1. 使用 `webpack api` 打包一个最简的 js 资源

2. 你所使用含有 webpack 的项目中，`webpack` 是通过 `webpack-cli` 打包的吗？

3. 如何计算每次 webpack 构建时间

   ```js
   compiler.run((err, stat) => {
     // 单入口
     console.log(`打包时间：${stat.toJson().time}`)
     console.log(`打包时间：stat.endTime - stat.startTime`)
     // 多入口
     stat.stats.map((stat, index) => {
       console.log(`第${index + 1}次打包, 打包时间: ${stat.endTime - stat.startTime}`)
     })
   })
   ```

4. 断点调试 webpack 源码，了解其编译时间（startTime/endTime）是如何计算的

5. 断点调试执行 webpack 命令时的流程，体验它是如何在 `webpack`/`webpack-cli` 间相互调用的