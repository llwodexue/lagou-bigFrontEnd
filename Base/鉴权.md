## HTTP 协议

HTTP 协议是超文本传输协议，主要是客户端和服务器之间交互数据，交互分为请求和响应两部分。HTTP 协议默认是 80 端口，HTTP = HTTP + SSL 安全传输协议，端口是 443

**请求：**

- 请求行
- 请求头
- 请求正文

**响应：**

- 响应行
- 响应头
- 响应正文

**HTTP 特点：** 简单、快速、无连接无状态，指的是多个请求之间是没有关联的、独立的

## Cookie 鉴权

Cookie 是服务器产生的保存在客户端的一小段文本信息，格式是字典、键值对

**Cookie 有两类：**

1. 会话级 Cookie：保存在内存，当浏览器关闭会自动消失
2. 持久化 Cookie：保存在硬盘，当浏览器关闭不会自动消失，它的生命周期取决于失效时间

**Cookie 鉴权**

1. 客户端第 1 次访问服务器生成 Cookie，然后通过响应头中的 `Set-Cookie` 传输到客户端，然后在客户端保存
2. 客户端第 2~N 次访问服务器时，那么在请求的请求头 Cookie 里面就会自动带上客户端保存的 Cookie，然后和服务器的 Cookie 进行对比来实现鉴权

**Cookie 缺点：**

- 服务器生成保存在客户端，对于一些重要信息，用户名、密码通过 Cookie 保存不安全

## Session 鉴权

**Session 鉴权**

1. 当客户端登录服务器的时候，服务器生成 SessionId 并保存到服务器，然后在登录请求的响应头里面就会把 SessionId 通过 Cookie 传输给客户端
2. 后面的所有请求都会在请求头 Cookie 里面带上 SessionId，然后和服务器的 SessionId 进行对比实现鉴权

Session  鉴权需要服务端存储，jwt 鉴权不需要服务端存储

## Token 鉴权

**Token 鉴权**

1. 一般是登录之后自动生成 Token 或者通过一个单独的接口来生成 Token，然后保存在服务器的硬盘，一般保存在服务器的数据库
2. 后面的所有请求都必须带上 Token（请求头、参数），然后和服务器的 Token 对比实现鉴权

**jwt 踢人**

1. 颁布 jwt 时，就把 jwt 存到 Redis 中，每次访问验证 jwt 时看看 Redis 里是否有这个 Token，没有这个 Token 就验证失败

2. 采用类似 OAuth2.0 协议中的做法，认证后颁布 2 个 Token `acess_token` 和 `refresh_token`

   `access_token` 为 jwt 生成的，并设置一个较短的过期时间，比如 30 分钟。访问令牌每次调用后端服务都需要携带

   `refresh_token` 刷新令牌，可以不为 jwt 生成的，设置一个较长的过期时间，比如 1 个月，存在数据库中（Redis）。前端拿着 `access_token` 请求时，都要判断 Redis 中 `refresh_token` 过期没，没过期就通过。如果 `access_token` 过期了，只要 `refresh_token` 还没过期就刷新 `acess_token` 返给前端。如果要踢人，直接把 `refresh_token` 从 Redis 中清除即可

3. 黑名单模式，就是把需要踢的用户的 `token` 放在一个数组里，此用户访问时，遍历数组看有没有这个人，有的话就下线

4. WebSocket 踢人，不涉及 Token，可以通过 code 来进行判断

### OAuth 2

> [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

OAuth 2 是一个工业级别的开发授权协议，可以使互联网用户授权第三方网站或应用访问他们在特定网站上的信息（如个人资料、照片等），而不必向第三方网站或应用提供密码

![](https://gitee.com/lilyn/pic/raw/master/jslearn-img/OAuth2.png)

1. 客户端向资源所有者请求授权。客户端申请认证的 URI，需要包含以下参数：
   - `response_type`：授权类型，必填项，固定为 `code`
   - `client_id`：客户端的 ID，必填项
   - `redirect_uri`：重定向 URI，必填项
   - `scope`：申请的权限范围，可选项
   - `state`：客户端的当前状态，可以是任意值，认证服务器会原封不动地返回这个值
2. 客户端收到授权许可。服务器回应客户端的 URI，需要包含以下参数：
   - `code`：授权码，必填项。通常有效期很短设置 10 分钟，客户端只能使用一次，否则会被授权服务器拒绝
   - `state`：客户端请求包含这个参数，认证服务器的回应也必须一模一样包含这个参数
3. 客户端使用获得的授权向认证服务器申请令牌。需要包含以下参数：
   - `grant_type`：授权模式，必填项，固定为 `authorization_code`
   - `code`：第二步获得的授权码，必填项
   - `redirect_uri`：重定向 URI，必填项，与第一步保持一致
   - `client_id`：客户端 ID，必填项
4. 认证服务器验证许可。需要包含以下参数：
   - `access_type`：访问令牌，必填项
   - `token_type`：令牌类型，大小写不敏感，必填项。可以是 `brarer` 类型或 `mac` 类型
   - `expires_in`：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间
   - `refresh_token`：更新令牌，用来获取下一次访问令牌，可选项
   - `scope`：权限范围，可选项