# 排序算法进阶

## 堆排序

### 堆排序介绍

堆排序(Heap Sort)是堆排序是一种基于比较的排序算法，它的核心思想是使用二叉堆来维护一个有序序列

- 二叉堆是一种完全二叉树，其中**每个节点都满足父节点比子节点大(或小)的条件**
- 在堆排序中，我们**使用最大堆来进行排序**，也就是**保证每个节点都比它的子节点大**

在堆排序中，我们首先构建一个最大堆

- 然后，我们**将堆的根节点(也就是最大值)与堆的最后一个元素交换**，这样**最大值就被放在了正确的位置**上
- 接着，**我们将堆的大小减小一，并将剩余的元素重新构建成一个最大堆**
- 我们**不断重复这个过程，直到堆的大小为 1**
- 这样，我们就**得到了一个有序的序列**

堆排序和选择排序有一定的关系，因为它们都利用了"选择"这个基本操作

- 选择排序的基本思想是**在待排序的序列中选出最小(或最大)的元素**，然后**将其放置到序列的起始位置**
- 堆排序也是**一种选择排序算法**，它**使用最大堆来维护一个有序序列，然后不断选择出最大的值**

堆排序时间复杂度为 O(nlogn)

### 手写堆排序

堆排序可以分为两大步骤：构建最大堆和排序

构建最大堆:

1. 遍历待排序序列，从最后一个非叶子节点开始，依次对每个节点进行调整
2. 假设当前节点的下标为 i，左子节点的下标为 2i+1，右子节点的下标为 2i+2，父节点的下标为 (i-1)/2
3. 对于每个节点 i，比较它和左右子节点的值，找出其中最大的值，并将其与节点 i 进行交换
4. 重复进行这个过程，直到节点 i 满足最大堆的性质
5. 依次对每个非叶子节点进行上述操作，直到根节点，这样我们就得到了一个最大堆

排序:

1. 将堆的根节点(也就是最大值)与堆的最后一个元素交换，这样最大值就被放在了正确的位置上
2. 将堆的大小减小一，并将剩余的元素重新构建成一个最大堆
3. 重复进行步骤 1 和步骤 2，直到堆的大小为 1，这样我们就得到了一个有序的序列

![image-20240429112058738](C:\Users\suncu\AppData\Roaming\Typora\typora-user-images\image-20240429112058738.png)

二叉堆索引

![image-20240430163821059](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240430163821059.png)

```typescript
function heapSort(arr: number[]): number[] {
  // 1.获取数组的长度
  const n = arr.length
  // 2.对arr进行原地建堆
  // 2.1.从第一个非叶子节点开始进行下滤操作
  const start = Math.floor((n - 1) / 2)
  for (let i = start; i >= 0; i--) {
    // 2.2.进行下滤操作
    heapDown(arr, n, i)
  }
  // 3.对最大堆进行排序操作
  for (let i = n - 1; i > 0; i--) {
    swap(arr, 0, i)
    heapDown(arr, i, 0)
  }
  return arr
}
/**
 * 下滤操作函数
 * @param arr 在数组中进行下滤操作
 * @param n 下滤操作的范围
 * @param index 哪一个位置需要进行下滤操作
 */
function heapDown(arr: number[], n: number, index: number) {
  while (2 * index + 1 < n) {
    // 1.获取左右子节点的索引
    const leftChildIndex = 2 * index + 1
    const rightChildIndex = 2 * index + 2
    // 2.找出左右子节点较大的值
    let largeIndex = leftChildIndex
    if (rightChildIndex < n && arr[rightChildIndex] > arr[leftChildIndex]) {
      largeIndex = rightChildIndex
    }
    // 3.判断index位置的值比更大的子节点，直接break
    if (arr[index] >= arr[largeIndex]) {
      break
    }
    // 4.和更大位置的进行交换操作
    swap(arr, index, largeIndex)
    index = largeIndex
  }
}
```

### 堆排序复杂度

堆排序的时间复杂度分析较为复杂，因为它既涉及到堆的建立过程，也涉及到排序过程

1. 堆的建立过程
   - 堆的建立过程包括 **n/2 次堆的向下调整操作**，因此**它的时间复杂度为 O(n)**
2. 排序过程步骤
   - 排序过程**需要执行 n 次堆的删除最大值操作**，每次操作都需要**将堆的最后一个元素与堆顶元素交换**，然后**向下调整堆**
   - 每次**向下调整操作的时间复杂度为 O(logn)**，因此**整个排序过程的时间复杂度为 O(nlogn)**

综合起来，堆排序的时间复杂度为 O(nlogn)

需要注意的是，堆排序的空间复杂度为 O(1)，因为它只使用了常数个辅助变量来存储堆的信息

总结：

堆排序是一种高效的排序算法，它利用堆这种数据结构来实现排序

- 堆排序具有时间复杂度为 O(nlogn) 的优秀性能，并且由于它只使用了常数个辅助变量来存储堆的信息，因此空间复杂度为 O(1)
- 但是，由于堆排序的过程是不稳定的，即相同元素的相对位置可能会发生变化，因此在某些情况下可能会导致排序结果不符合要

总的来说，堆排序是一种高效的、通用的排序算法，它适用于各种类型的数据，并且可以应用于大规模数据的排序

