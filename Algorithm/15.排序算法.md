# 排序算法

## 认识排序算法

### 人与计算机区别

排序（Sorting）是一个非常常见的功能，在平时生活中也是随处可见的

如何排序?

- 需求: 对一组身高不等的10个人进行排序

人来排序:

- 如果是人来排序事情会非常简单，因为人只要扫过去一眼就能看出来谁最高谁最低
- 然后让最低（或者最高）的站在前面，其他人依次后移
- 按照这这样的方法。 依次类推就可以了

人排序的特点:

- 可以统筹全局，直接获取到最高或者最低的结果
- 不需要考虑空间的问题

人排序的缺点:

- 容易出错
- 数据量非常庞大时，很难进行排序（比如有 10w 的数据量）



计算机来排序:

- 计算机有些笨拙，它只能执行指令，所以没办法一眼扫过去
- 计算机也很聪明，只要你写出了正确的指令，可以让它帮你做无数次类似的事情而不用担心出现错误
- 并且计算机排序也无需担心数据量的大小
- 想象一下，让人排序 10w 个，甚至更大的数据项你还能一眼扫过去吗？
- 人在排序时不一定要固定特有的空间，他们可以相互推推嚷嚷就腾出了位置，还能互相前后站立
- 但是计算机必须有严密的逻辑和特定的指令

- 计算机不能像人一样，一眼扫过去这样通览所有的数据
- 它只能根据计算机的比较操作原理，在同一个时间对两个队员进行比较
- 在人类看来很简单的事情，计算机的算法却不能看到全景
- 因此，它只能一步步解决具体问题和遵循一些简单的规则

### 常见排序算法

维基百科堆排序算法的解释:

- 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式排列的算法
- 虽然排序算法从名称来看非常容易理解，但是从计算机科学发展以来，在此问题上已经有大量的研究

由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题

- 而且人们已经研究出一套成熟的方案来实现排序
- 因此，幸运的是你并不需要是发明某种排序算法，而是站在巨人的肩膀上即可

在计算机科学所使用的排序算法通常依以下标准分类:

- **计算的时间复杂度**：使用大 O 表示法，也可以实际测试消耗的时间
- **内存使用量**（甚至是其他电脑资源）：比如外部排序，使用磁盘来存储排序的数据
- **稳定性**：稳定排序算法会让原本有相等健值的纪录维持相对次序
- 排序的方法：插入、交换、选择、合并等等

常见的排序算法非常多:

- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 快速排序
- 堆排序
- 希尔排序
- 计数排序
- 桶排序
- 基数排序
- 内省排序
- 平滑排序

![image-20240129161528197](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240129161528197.png)

## 冒泡排序

冒泡排序（Bubble sort）是一种简单的排序方法

- 基本思路是通过两两比较相邻的元素并交换它们的位置，从而使整个序列按照顺序排列
- 该算法一趟排序后，最大值总是会移到数组最后面，那么接下来就不用再考虑这个最大值
- 一直重复这样的操作，最终就可以得到排序完成的数组

这个算法的名字由来是因为越大的元素会经由交换慢慢"浮"到数组的尾端，故名"冒泡排序"

冒泡排序的流程如下:

- 从第一个元素开始，逐一比较相邻元素的大小
- 如果前一个元素比后一个元素大，则交换位置。口 在第一轮比较结束后，最大的元素被移动到了最后一个位置
- 在下一轮比较中，不再考虑最后一个位置的元素，重复上述操作
- 每轮比较结束后，需要排序的元素数量减一，直到没有需要排序的元素
- 排序结束
- 这个流程会一直循环，直到所有元素都有序排列为止

![image-20240129163032487](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240129163032487.png)

封装交换位置

```typescript
export function swap(arr: number[], i: number, j: number) {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}
```

封装

```typescript
function bubbleSort(arr: number[]): number[] {
  const n = arr.length
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }
  return arr
}
```

