# 平衡二叉树



## 平衡树

平衡树（Balanced Tree）是一种特殊的二叉搜索树：

- 其目的是通过一些特殊的技巧来维护树的高度平衡
- 从而保证树的搜索、插入、删除等操作的时间复杂度都较低

为什么需要平衡树呢?

- 如果一棵树退化成链状结构，那么搜索、插入、删除等操作的时间复杂度就会达到最坏情况，即 O(n)，因此不能满足要求
- 平衡树通过不断调整树的结构，使得树的高度尽量平衡，从而保证搜索、插入、删除等操作的时间复杂度都较低，通常为 O(logn)
- 因此，如果我们需要高效地处理大量的数据，那么平衡树就显得非常重要了

平衡树的应用非常广泛，如索引、内存管理、图形学等领域均有广泛使用

![image-20231225153028161](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231225153028161.png)

事实上不只是添加会导致树的不平衡，删除元素也可能会导致树的不平衡

### 如何让树更加平衡

方式一：限制插入、删除的节点（比如在树特性的状态下，不允许插入或者删除某些节点，不现实）

方式二：在随机插入或者删除元素后，通过某种方式观察树是否平衡，如果不平衡通过特定的方式（比如旋转），让树保持平衡

![image-20231225153314467](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231225153314467.png)

### 平衡二叉搜索树

- AVL树：这是一种最早的平衡二叉搜索树，在 1962 年由 GM.**A**delson-**V**elsky 和 E.M.**L**andis 发明
- 红黑树：这是一种比较流行的平衡二叉搜索树，由 R.Bayer 在 1972 年发明
- Splay树：这是一种动态平衡二叉搜索树，通过旋转操作对树进行平衡
- Treap：这是一种随机化的平衡二叉搜索树，是二叉搜索树和堆的结合
- B-树：这是一种适用于磁盘或其他外存存储设备的多路平衡查找树

这些平衡二又搜索树都用于保证搜索树的平衡，从而在插入、删除、查找操作时保证了较低的时间复杂度

红黑树和AVL树是应用最广泛的平衡二又搜索树:

- 红黑树：红黑树被广泛应用于实现诸如操作系统内核、数据库、编译器等软件中的数据结构，其原因在于它在插入、删除、查找操作时都具有较低的时间复杂度
- AVL树：AVL树被用于实现各种需要高效查询的数据结构，如计算机图形学、数学计算和计算机科学研究中的一些特定算法

## AVL树

AVL树 (Adelson-Velsky and Landis Tree) 是由 G.M.Adelson-Velsky 和 E.M.Landis 在 1962 年发明的

- 它是一种自（Self）平衡二叉搜索树
- 它是二叉搜索树的一个变体，在保证二叉搜索树性质的同时通过旋转操作保证树的平衡

在AVL树中，每个节点都有一个权值，该权值代表了以该节点为根节点的子树的高度差

- 在AVL树中，任意节点的权值只有 1 或 -1 或 0，因此AVL树也被称为高度平衡树
- 对于每个节点，它的左子树和右子树的高度差不超过1
- 这使得AVL树具有比普通的二叉搜索树更高的查询效率
- 当插入或删除节点时，AVL树可以通过旋转操作来重新平衡树，从而保证其平衡性

![image-20231225162004846](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231225162004846.png)

AVL树的插入和删除操作与普通的二叉搜索树类似，但是在插入或者删除之后，需要继续保持树的平衡

- AVL树需要通过旋转操作来维护平衡
- 有四种情况旋转操作:左左情况、右右情况、左右情况和右左情况双旋口 具体使用哪一种旋转，要根据不同的情况来进行区分和判断

由于AVL树具有自平衡性，因此其最坏情况下的时间复杂度仅 O(log n)

### 旋转情况

此动画演示了不断将节点插入AVL树时的情况，并且演示了左旋（Left Rotation）、右旋（Right Rotation）、右左旋转（Right-Left Rotation）、左右旋转（Left-Right Rotation）以及带子树的右旋（Right Rotation with children）

![AVL_Tree_Example](https://gitee.com/lilyn/pic/raw/master/md-img/AVL_Tree_Example.gif)

以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作

![image-20231225162310492](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231225162310492.png)

### 封装过程

手写实现AVL树本身的过程是相当的复杂的，最好是分而治之

- 步骤一：学习AVL树节点的封装
- 步骤二：学习AVL树的旋转情况下如何编写代码
- 步骤三：写出不同情况下进行的不同旋转操作
- 步骤四：写出插入操作后，树的再平衡操作
- 步骤五：写出删除操作后，树的再平衡操作

grand/root -> parent/pivot -> current

### 右旋转

![image-20231226110115620](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231226110115620.png)![image-20231226111019213](https://gitee.com/lilyn/pic/raw/master/md-img/image-20231226111019213.png)

实现步骤分析：

处理 pivot 的位置

1. 选择当前节点的左子节点作为旋转轴心 pivot
2. pivot 的父节点指向 root 当前节点的父节点

```typescript
const pivot = root.left
pivot.parent = root.parent
```

处理 pivot 右节点的位置

3. root 当前节点的左节点
4. 如果父节点有值，那么右节点的父节点指向 root 节点

```typescript
root.left = pivot.right
if (pivot.right) {
  pivot.right.parent = root
}
pivot.right = root
```

处理 root 节点的位置

5. pivot 的右节点指向 root
6. root 节点父节点指向 pivot

```typescript
pivot.right = root
root.parent = pivot
```

7. 判断是否有父节点，父节点的 left/right 指向 pivot

```typescript
// 情况一：pivot.parent 为 null/undefined
avltree.root = pivot
// 情况二：父节点的左子节点
pivot.parent.left = pivot
// 情况三：pivot 是父节点的右子节点
pivot.parent.right = pivot
```

