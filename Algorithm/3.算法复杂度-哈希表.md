## 算法复杂度

对于同一个问题，我们往往其实有很多种解决它的思路和方法，也就是可以采用不同的算法

- 但是不同的算法，其实效率是不一样的

举个例子（现实的例子）:在一个庞大的图书馆中，我们需要找一本书。在图书已经按照某种方式摆好的情况下（数据结构是固定的）

- 方式一：顺序查找
  - 一本本找，直到找到想要的书（累死）
- 方式二：先找分类，分类中找这本书
  - 先找到分类，在分类中再顺序或者某种方式查找
- 方式三：找到一台电脑，查找书的位置，直接找到
  - 图书馆通常有自己的图书管理系统
  - 利用图书管理系统先找到书的位置，再直接过去找到

### 顺序查找

方式一: 顺序查找

- 这种算法从头到尾遍历整个数组，依次比较每个元素和给定元素的值
- 如果找到相等的元素，则返回下标；如果遍历完整个数组都没找到，则返回 -1

```typescript
function sequentSearch(array: number[], num: number) {
  for (let i = 0; i < array.length; i++) {
    const item = array[i]
    if (item === num) return i
  }
  return -1
}
```

### 二分查找

方式二：二分查找

- 这种算法假设数组是有序的，每次选择数组中间的元素与给定元素进行比较
- 如果相等，则返回下标；如果给定元素比中间元素小，则在数组的左半部分继续查找
- 如果给定元素比中间元素大，则在数组的右半部分继续查找
- 这样每次查找都会将查找范围减半，直到找到相等的元素或者查找范围为空

```typescript
function binarySearch(array: number[], num: number) {
  // 1.定义左边的索引
  let left = 0
  // 2.定义右边的索引
  let right = array.length - 1
  // 3.开始查找
  while (left <= right) {
    let mid = Math.floor((left + right) / 2)
    const midNum = array[mid]
    if (midNum === num) {
      return mid
    } else if (midNum < num) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}
```

### 测试效率

```typescript
import sequentSearch from './1.顺序查找'
import binarySearch from './2.二分查找'

const MAX_LENGTH = 10 * 1000 * 1000
const nums = new Array(MAX_LENGTH).fill(0).map((_, i) => i)
const num = MAX_LENGTH / 2

const startTime1 = performance.now()
const index1 = sequentSearch(nums, num)
const endTime1 = performance.now()
console.log('索引为：', index1, '。消耗的时间：', endTime1 - startTime1)

const startTime2 = performance.now()
const index2 = binarySearch(nums, num)
const endTime2 = performance.now()
console.log('索引为：', index2, '。消耗的时间：', endTime2 - startTime2)
```

## 大O表示法

大 O 表示法（Big O notation）英文翻译为大 O 符号（维基百科翻译），中文通常翻译为大 O 表示法（标记法）

- 这个记号则是在德国数论学家爱德蒙·兰道的著作中才推广的，因此它有时又称为兰道符号（Landau symbols）
- 代表 "order of..." (....阶) 的大 O，最初是一个大写希腊字母 "O" (omicron) ，现今用的是大写拉丁字母 "O"

**大 O 符号在分析算法效率的时候非常有用**

举个例子，解决一个规模为 n 的时间所花费的时间（或者所需步骤的数目）可以表示为：`T(n) = 4n^2 -2n + 2`

- 当 n 增大时，`n^2` 项开始占据主导地位，其他各项可以被忽略

举例说明：当 n=500

- `4n^2` 项是 `2n` 项的 1000 倍大，因此在多数场合下，省略后者对表达式的值的影响是可以忽略不计的
- 进一步看，如果我们与任意其他级的表达式比较，`n^2` 的系数也是无关紧要的

这样，针对这个例子 `T(n) = 4n^2 -2n + 2` 大 O 表示法就几下剩余的部分，写作：`T(n) = O(n^2)`

- 具有 `n^2`（平方阶）的时间复杂度，表示为：`O(n^2)`

### 函数阶

| 符号       | 名称                                 |
| ---------- | ------------------------------------ |
| O(1)       | 常数（阶）                           |
| O(log^n)   | 对数（阶）                           |
| O(n)       | 线性，次线性                         |
| O(n log^n) | 线性对数，或对数线性、拟线性、超线性 |
| O(n^2)     | 平方                                 |
| O(n^c)     | 多项式，有时叫作 "代数"（阶）        |
| O(c^n)     | 指数，有时叫做 "几何"（阶）          |

![image-20230817144939852](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230817144939852.png)

### 空间复杂度

空间复杂度指的是程序运行过程中所需要的额外存储空间

- 空间复杂度也可以用大 O 表示法来表示
- 空间复杂度的计算方法与时间复杂度类似，通常需要分析程序中需要额外分配的内存空间，如数组、变量、对象、递归调用等

举个栗子

- 对于一个简单的递归算法来说，每次调用都会在内存中分配新的栈帧，这些栈赖占用了额外的空间
  - 因此，该算法的空间复杂度是 O(n)，其中 n 是递归深度
- 而对于迭代算法来说，在每次迭代中不需要分配额外的空间，因此其空间复杂度为 O(1)

当空间复杂度很大时，可能会导致内存不足，程序崩溃

在平时进行算法优化时，我们通常会进行如下的考虑：

- 使用尽量少的时间（优化空间复杂度）
- 使用进行少的时间（优化时间复杂度）
- 特定情况下：使用空间换时间或时间换空间

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 访问 | O(1) | O(n) |
| 查询 | O(n) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

数组是一种连续的存储结构，通过下标可以直接访问数组中的任意元素

- 时间复杂度：对于数组，随机访问时间复杂度为 O(1)，插入和删除操作时间复杂度为 O(n)
- 空间复杂度：数组需要连续的存储空间，空间复杂度为 O(n)

链表是一种链式存储结构，通过指针链接起来的节点组成，访问链表中元素需要从头结点开始遍历

- 时间复杂度：对于链表，随机访问时间复杂度为 O(n)，插入和删除操作时间复杂度为 O(1)
- 空间复杂度：链表需要为每个节点分配存储空间，空间复杂度为 O(n)

在实际开发中，选择使用数组还是链表，需要根据具体应用场景来决定

- 如果数据量不大，且需要频繁随机访问元素，使用数组可能会更好
- 如果数据量大，或者需要频繁插入和删除元素，使用链表可能会更好

## 哈希表

哈希表通常是基于数组进行实现的，但是相对于数组，它也有很多优势：

- 它可以提供非常快速的插入-删除-查找操作
- 无论多少数据，插入和删除值都接近常量的时间：即 O(1) 的时间复杂度。实际上，只需要几个机器指令即可完成
- 哈希表的速度比数还要快，基本可以瞬间查找到想要的元素
- 哈希表相对于数来说编码要容易很多

哈希表相对于数组的一些不足：

- 哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素（没有特殊处理情况下）
- 通常情况下，哈希表中的 key 是不允许重复的，不嫩放置相同的 key，用于保存不同的元素

哈希表它的结构就是数组，但是它神奇的地方在于对数组下标值的一种变换，这种变换我们可以使用哈希函数，通过哈希函数可以获取到 HashCode

![image-20230817155619650](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230817155619650.png)

### 案例

**公司员工存储**

方案一：数组

- 一种方案是按照顺序将所有的员工依次存入一个长度为 1000 的数组中
- 每个员工的信息都保存在数组的某个位置上
- 数组最大的优势是什么？通过下标值去获取信息
- 为了可以通过数组快速定位到某个员工，最好给员工信息中添加一个员工编号，而编号对应的就是员工的下标值
- 当查找某个员工的信息时，通过员工编码可以快速定位到员工的信息位置

方案二：链表

- 链表对应插入和删除数据有一定优势
- 但是对于获取员工的信息，每次都必须从头遍历到尾

如果我们知道员工的姓名，但不知道它的员工编号，只能线性查找，效率非常低

- 使用哈希函数，让某个 key 的信息和索引值对应起来

**50000个单词的存储**

方案一：数组

- 我拿到一个单词 lridescent，我想知道这个单词的翻译/读音/应用
- 怎么可以从数组中查到这个单词的位置呢？线性查找？50000次比较？
- 如果你使用数组来实现这个功能，效率会非常非常低

方案二：链表

- 不需要考虑

方案三：将单词转成数组的下标值

- 如果单词转成数组下标，那么我们要查找某个单词的信息，直接按照下标值一步即可访问到想要的元素

### 字母转数字

字符串转下标值

- 计算机中有很多编码方案用数字代替单词字符，就是字符编码，比如 ASII 编码。a 是 97，b 是 98，z 是 122
- 当然也可以自己设计编码系统，比如 a 是 1，b 是 2，z 是 26

方案一：数字想加

- 一种转换单词的简单方案就是把单词每个字符的编码求和
- 比如：`cats: 3 + 1 + 20 + 19 = 43`，这种方案明显的问题就是有很多单词最终的下标都是 43，比如：was/tin/give/tend/moan/tick 等等

方案二：幂的连乘

- 可以通过一种算法，让 cats 转成不那么普通的数字
- 我们平时使用的大于 10 的数字，可以用一种幂的连乘来表示它的唯一性
- 比如：`cats: 3*27^3 + 1*27^2 + 20*27 + 17 = 60337`
- 这样得到的数字可以基本保证它的唯一性，不会和别的单词重复
- 问题：如果一个单词是：zzzzzzzzzz，那么得到的数字超过 7000000000000，创建这么大的数组是没有意义的，这样就会导致空间浪费

方案一产生的数组下标太小，方案二产生的数组下标又太多

### 开放地址法

开放地址法主要工作方式是寻找空白的单元格来添加重复的数据

![image-20230817163630901](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230817163630901.png)

从图片的文字中我们可以了解到，开放地址法其实就是要寻找空白的位置来防止冲突的数据项

但是探索这个位置的方式不同，有三种方法

- 线性探测
  - 线性查找空白的单元
  - 问题：聚集，一连串填充单元叫聚集，连续的单元不允许我们放置数据
- 二次探测
  - 二次探测是在线性探测基础上对步长进行了优化
- 再哈希法
  - 二次探测步长依然是固定的，可以关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化作为步长

### 链地址法

哈希表中执行插入和搜索操作效率是非常高的

- 如果没有产生冲突，那么效率就会更高
- 如果发生冲突，存取时间就依赖后来的探测长度
- 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长
- 随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案

**装填因子**

- 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值
- 装填因子 = 总数据项 / 哈希表长度
- 开放地址法的装填肉子最大是多少呢？ 1，因为它必须寻找到空白的单元才能将元素放入
- 链地址法的装填因子呢？可以大于1，因为拉链法可以无限的延伸下去，只要你愿意。(当然后面效率就变低了)

**线性探测效率**

- 探测序列（P）和装填因子（L）的关系
- 公式来自于 Knuth（算法分析领域的专家，现代计算机的先驱人物），给出推导过程，仅仅说明它的效率。这些公式的推导自己去看了一下，确实有些繁琐

![image-20230817165000537](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230817165000537.png)

二次探测和再哈希法性能相当，它们的性能比线性探测略好

![image-20230817165039361](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230817165039361.png)

链地址法的效率分析有些不同，一般来说比开放地址法简单。我们来分析一下这个公式应该是怎么样的

- 假如哈希表包含 arraySize 个数据项，每个数据项有一个链表，在表中一共包含 N 个数据项
- 那么，平均起来每个链表有多少个数据项呢？非常简单，`N / arraySize`
- 有没有发现这个公式有点眼熟？其实就是装填因子

那么我们现在就可以求出查找成功和不成功的次数了

- 成功可能只需要查找链表的一半即可: `1 + loadFactor/ 2`
- 不成功呢？可能需要将整个链表查询完才知道不成功: `1 + loadFactor`

经过上面的比较我们可以发现，链地址法相对来说效率是好于开放地址法的。所以在真实开发中，使用链地址法的情况较多

- 因为它不会因为添加了某元素后性能急剧下降
- 比如在 Java 的 HashMap 中使用的就是链地址法

## 哈希函数

- 哈希表的主要优点是它的速度，所以在速度上不能满足，那么就达不到设计的目的了
- 提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法。因为它们的性能是比较低的

快速的计算

- 哈希表的优势就在于效率，所以快速获取到对应的 hashCode 非常重要
- 我们需要通过快速的计算来获取到元素对应的 hashCode

均匀的分布

- 哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率
- 所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布

![image-20230821160715569](E:\learn\lagouBigFront\md\Algorithm\img\image-20230821160715569.png)

**均匀分布**

- 在设计哈希表时，已经有办法处理映射到相同下标值的情况：链地址法和开放地址法
- 但是无论哪种方案，为了提供效率，最好的情况还是让数据在哈希表中均匀分布
- 因此，我们需要再使用常量的地方，尽量使用质数

质数的使用

- 哈希表的长度
- N 次幂的底数（之前使用的是 27）

为什么他们使用质数，会让哈希表分布更加均匀呢？

- 质数和其他数相乘的结果相比于其他数字更容易产生唯一性的结果，减少哈希冲突
- Java 中的 N 次幂的底数选择的是 31，是经过长期观察分布结果得出的

### Java 中的 HashMap

Java 中的哈希表采用的是链地址法

HashMap 的初始长度是 16，每次自动扩展，长度必须是 2 的次幂

- 为了服务于 Key 映射到 index 的算法。60000000 % 100 = 数字。下标值

HashMap 中为了提高效率，才用了位运算的方式

- HashMap 中的 index 计算公式：index = HashCode(Key) & (Length - 1)