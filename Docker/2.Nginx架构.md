## Nginx架构

1. 为什么 Nginx 采用 master-worker 架构模型
2. 为什么 worker 的数量要和 cpu 核数相匹配
3. 多个 worker 进程间共享数据，为什么在 TLS、限流、限速场景共享方式不同

### Nginx请求处理流程

![image-20240219153631334](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219153631334.png)

### Nginx进程结构

1. 单进程
2. 多进程

为什么 Nginx 采用多进程结构而不是多线程结构：

- 保证高可用性和高可靠性
  - 因为多线程之间共享同一个地址空间，所以当某一个第三方模块引发地址空间导致得段错误时，在地址越界出现时会导致整个 Nginx 进程全部挂掉
  - 而当我们使用多进程这样的一个 Nginx 进程模型时,往往不会出现这样的一个问题
- 通常第三方模块是不会在 master 进程这里加上自己的功能代码的
  - master 进程它被设计用来的目的就是做 worker 进程的管理的
  - master 进程负责监控每个 worker 进程是不是在正常的工作。需不需要做重新载入配置文件，需不需要做热部署
- 缓存需要在多个 worker 进程间共享的
  - 缓存不光要被 worker 进程使用，还要被 Cache Manager 和 Cache Loader 进程使用
  - 实际上每个请求使用的缓存还是由 worker 进程来进行的
- 为什么 worker 会很多？
  - Nginx 采用事件驱动模型，它希望每一个 worker 从头到尾都占有一颗 CPU，所以我们不止要把 worker 的数量配置与服务器上的 CPU 核数一致，还需要把每一个 worker 进程与某一颗 CPU 绑定在一起，这样可以更好的使用 CPU 核心上的 CPU 缓存，来减少失效的命中率

![image-20240219154205492](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219154205492.png)



![image-20240219174018359](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174018359.png)

master 进程

1. 启动时检查 nginx.conf 是否正确，语法错误
2. 根据配置文件的参数创建、且监控 worker 进程的数量和状态
3. 监听 socket，接收 client 发起的请求，然后 worker 竞争抢夺链接，获胜的可以处理且响应请求
4. 接收发送的管理 nginx 进程的信号，并且将信号通知到 worker 进程
5. 如果发送了 reload 命令，则读取新配置文件，创建新的 worker 进程，结束旧的 worker 进程

worker 进程

1. 实际处理 client 网络请求的是 worker
1. master 根据 nginx.conf 决定 worker 的数量
1. 有 client 用户请求到达时，worker 之间进程竞争，获胜者和 client 建立连接且处理用户请求
1. 接收用户请求后，若需要代理转发给后端，则后端处理完毕后接收处理结果，再响应给用户
1. 接收并处理 master 发来的进程信号，如：启动、重启、重载、停止

## 流程

### reload流程

![image-20240219174123999](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174123999.png)

![image-20240219174341174](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174341174.png)

### 热升级流程

![image-20240219174515789](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174515789.png)

![image-20240219174701798](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174701798.png)

![image-20240219174853644](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174853644.png)

## 事件驱动

![image-20240219174951487](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174951487.png)

![image-20240219175041804](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219175041804.png)

事件分发机制

![image-20240219175914415](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219175914415.png)

### epoll

![image-20240219180144467](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219180144467.png)

### 请求间切换

![image-20240220102505550](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240220102505550.png)

### 阻塞

阻塞与非阻塞

- 阻塞：操作系统或底层C库提供的方法或系统调用，调用的方法可能会导致进程进入睡眠状态，为什么会进入睡眠状态？因为当前条件不满足情况下，操作系统主动把进程切换到另一个进程
- 非阻塞：调用该方法永远不会因为时间片未用完时把进程主动切换掉

![image-20240220104025382](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240220104025382.png)

![image-20240220104048022](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240220104048022.png)

## Nginx模块

1. 前提：编译进 Nginx
2. 提供哪些配置项
3. 模块何时被使用
4. 提供哪些变量

![image-20240220112408392](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240220112408392.png)