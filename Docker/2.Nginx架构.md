## Nginx架构

1. 为什么 Nginx 采用 master-worker 架构模型
2. 为什么 worker 的数量要和 cpu 核数相匹配
3. 多个 worker 进程间共享数据，为什么在 TLS、限流、限速场景共享方式不同

### Nginx请求处理流程

![image-20240219153631334](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219153631334.png)

### Nginx进程结构

1. 单进程
2. 多进程

为什么 Nginx 采用多进程结构而不是多线程结构：

- 保证高可用性和高可靠性
  - 因为多线程之间共享同一个地址空间，所以当某一个第三方模块引发地址空间导致得段错误时，在地址越界出现时会导致整个 Ngxin 进程全部挂掉
  - 而当我们使用多进程这样的一个 Nginx 进程模型时,往往不会出现这样的一个问题
- 通常第三方模块是不会在 master 进程这里加上自己的功能代码的
  - master 进程它被设计用来的目的就是做 worker 进程的管理的
  - master 进程负责监控每个 worker 进程是不是在正常的工作。需不需要做重新载入配置文件，需不需要做热部署
- 缓存需要在多个 worker 进程间共享的
  - 缓存不光要被 worker 进程使用，还要被 Cache Manager 和 Cache Loader 进程使用
  - 实际上每个请求使用的缓存还是由 worker 进程来进行的
- 为什么 worker 会很多？
  - Nginx 采用事件驱动模型，它希望每一个 worker 从头到尾都占有一颗 CPU，所以我们不止要把 worker 的数量配置与服务器上的 CPU 核数一致，还需要把每一个 worker 进程与某一颗 CPU 绑定在一起，这样可以更好的使用 CPU 核心上的 CPU 缓存，来减少失效的命中率

![image-20240219154205492](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219154205492.png)



![image-20240219174018359](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174018359.png)

## 流程

### reload流程

![image-20240219174123999](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174123999.png)

![image-20240219174341174](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174341174.png)

### 热升级流程

![image-20240219174515789](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174515789.png)

![image-20240219174701798](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174701798.png)

![image-20240219174853644](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174853644.png)

## 事件驱动

![image-20240219174951487](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219174951487.png)

![image-20240219175041804](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219175041804.png)

事件分发机制

![image-20240219175914415](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219175914415.png)

![image-20240219180144467](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240219180144467.png)