## 8. Host 与 :authority

在一个的服务器中，可能拥有多个 Host 的应用服务，即同一个 IP 地址，可能对应多个域名，此时仅仅通过 IP 无法访问到对应的服务，可通过 `Host` 来进行定位

- `Host` 是客户端唯一必须携带的请求头，如果缺失了该请求头则会返回 400 状态码。在 HTTP/2 以及 HTTP/3 中，以一个伪头 `:authority` 代替

如果不携带 `Host` 请求头，则直接返回 400 状态码

```bash
$ nc httpbin.org 80
GET /get HTTP/1.1

HTTP/1.1 400 Bad Request
Server: awselb/2.0
Date: Wed, 21 Sep 2022 05:51:39 GMT
Content-Type: text/html
Content-Length: 122
Connection: close

<html>
<head><title>400 Bad Request</title></head>
<body>
<center><h1>400 Bad Request</h1></center>
</body>
</html>
```

如果通过 `curl` 模拟 Host，可通过请求 IP 地址，并明确指定 Host 头部

```bash
# 请求成功
$ curl http.devtool.tech

# 获取到其 IP 地址
$ dig +short http.devtool.tech
76.223.126.88

# 直接请求 IP，导致找不到该应用
$ curl 76.223.126.88

# 请求成功
$ curl 76.223.126.88 -H "Host: http.devtool.tech"
```

**作业**

1. 通过 `nc` 命令直接发送报文控制 Host 请求头的发送

   ```bash
   $ nc httpbin.org 80
   GET /get HTTP/1.1
   HOST: test.org
   ```

2. 通过浏览器控制台，查看各个网站的 `Host`/`:authority` 请求头

## 9. 内容协商

内容协商，客户端与服务期端协商需要什么样的资源，比如语言（中文/英文）、压缩编码以及媒体类型，如果服务器无法返回对应的资源，则返回 406 状态码

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/httpnegoserver-16662593768391.png)

**请求头**

关于内容协商的请求头有以下几个：

- `Accept`：我（客户端）需要什么样的 MIME 资源，比如 json 与 html，**不较常见**
- `Accept-Language`：我需要什么样的语言，比如 en-US 和 zh-CN，**较为常见**
- `Accept-Encoding`：我需要什么样的压缩编码，比如 gzip 与 br，如果不配置则可能不进行压缩，**非常常见**

**Accept**

- 其中 `q` 为 `quality`，意为权重，默认为 1

```bash
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

注意，比较反直觉的是，在 HTTP Header 中，`,` **拥有比** `;` **更高的优先级**，根据 `,` 分组，而不是根据 `;` 分组，这有可能让一些人无所适从

`Accept` 协商 Content-Type，在国外 API 文档较为常见，比如 [Github API](https://docs.github.com/en/rest/overview/media-types)，它允许配置以下两种 MIME Type

- `application/vnd.github.text+json`：仅仅返回 Markdown
- `application/vnd.github.html+json`：仅仅返回 HTML

```bash
# jq 为 JSON 处理工具，以下语句意为只打印 body body_html body_text 三个字段
# 选择 html 内容进行返回，则可以看到返回的 .body_html 字段
$ curl -s \
  -H "Accept: application/vnd.github.html+json" \
  https://api.github.com/repos/shfshanyue/Daily-Question/issues/1 | jq "{ body, body_html, body_text }"
{
  "body": null,
  "body_html": "<p dir=\"auto\">网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案</p>",
  "body_text": null
}

# 选择 text 内容进行返回，则可以看到返回的 .body_text 字段
$ curl -s \
  -H "Accept: application/vnd.github.text+json" \
  https://api.github.com/repos/shfshanyue/Daily-Question/issues/1 | jq "{ body, body_html, body_text }"
{
  "body": null,
  "body_html": null,
  "body_text": "网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案"
}
```

**Accept-Language**

- `Accept Language` 协商语言，常用作国际化

```bash
# 如果请求的语言是中文版本，则重定向至 /zh-CN/ 中文版页面
$ curl -I https://developer.mozilla.org/ -H 'Accept-Language: zh'
HTTP/2 302 
content-length: 0
location: /zh-CN/

# 如果请求的语言是英语版本，则重定向至 /zh-US/ 英文版页面
$ curl -I https://developer.mozilla.org/ -H 'Accept-Language: en'
HTTP/2 302 
content-length: 0
location: /en-US/
```

语言配置也可以通过 API 拿到，通过此可进行 i18n 配置，作为其默认语言，这比通过前端界面选择语言要友好许多

```js
navigator.language
```

**Accept-Encoding**

控制压缩编码，比如 gzip 与 br，如果不配置则可能不进行压缩。可通过响应头 `Content-Encoding` 查看压缩编码

```bash
$ curl -I https://juejin.cn
HTTP/2 200 
content-type: text/html; charset=utf-8
content-length: 58565
vary: Accept-Encoding

$ curl -I https://juejin.cn -H 'Accept-Encoding: gzip'
HTTP/2 200 
server: Tengine
content-type: text/html; charset=utf-8
content-encoding: gzip
vary: Accept-Encoding

$ curl -I https://juejin.cn -H 'Accept-Encoding: br'
HTTP/2 200 
content-type: text/html; charset=utf-8
vary: Accept-Encoding
content-encoding: br
```

**反爬**

在浏览器中会自动发送 `Accept`、`Accept-Encoding` 以及 `Accept-Language` 三个请求头

```Bash
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
accept-encoding: gzip, deflate, br
accept-language: zh-CN,zh;q=0.9,en;q=0.8
```

因此一些安全性要求较高的网站，**将通过以上三个请求头是否存在判断请求方是浏览器还是爬虫**。如果不存在以上请求头，则直接拒绝请求

**作业**

1. 什么是内容协商

2. Accept 如何配置权重

3. Accept/Accept-Language/Accept-Encoding 三个请求头的应用场景

4. 为什么在浏览器中发送的请求大都是 gzip 经压缩数据，而在 curl 直接发送请求时返回的是原始数据

   因为在浏览器中会自动发送 Accept、Accept-Encoding、Accept-Language 三个请求头，所以返回数据大都使用 gzip 压缩过。但是使用 curl 等工具时，则不会自动发送这些请求头，所以返回原始数据。这个特性也可以作为反爬的一个依据。没看到这三个请求头，直接拒绝请求

## 10. Content-Type

`Content-Type` 指定 Body 的媒体资源类型，如果是请求头，则代表请求体的资源类型，如果是响应头，则代表响应体的资源类型

- 资源类型通过 MIME（`Multipurpose Internet Mail Extensions`）进行表示，以此为基础的 npm 库 [mime-db](https://github.com/jshttp/mime-db) 也常用在各个 Node.js 服务器框架

**请求头中的 Content-Type**

在 API 中常见以下几种请求头中的 Content-Type：

- `aplication/json`：请求体为 JSON
- `application/x-www-form-urlencoded`：请求体为以 `&` 分割的字符串，如 `a=3&b=4`
- `multipart/form-data`：请求体以 Boundary 分割

在浏览器中通过 Form 表单发送请求体会自动携带 `application/x-www-form-urlencoeded` 请求头

通过 `FormData API` 会自动携带 `multipart/form-data` 请求头

但是如果需要通过 `application/json` 发送 JSON 数据，则需要**手动携带请求头**

当服务器接收到客户端请求时，将会**根据 Content-Type 来决定如何解析 Request Body**，这就是 Body Parser 所做的事情，比如 [koajs/bodyparser](https://github.com/koajs/bodyparser)

```bash
# 使用 Form 发送请求
$ curl -X POST httpbin.org/post -d a=3
{
  "args": {}, 
  "data": "", 
  "form": {
    "a": "3"
  }, 
  "headers": {
    "Accept": "*/*", 
    "Content-Length": "3", 
    "Content-Type": "application/x-www-form-urlencoded", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.79.1", 
    "X-Amzn-Trace-Id": "Root=1-63454557-3cd5f9a53682be3a327dd0a3"
  }, 
  "json": null, 
  "url": "http://httpbin.org/post"
}

# 使用 JSON 发送请求
$ curl -X POST httpbin.org/post -H "content-type: application/json" -d '{"a": 3}'
{
  "args": {}, 
  "data": "{\"a\": 3}", 
  "form": {}, 
  "headers": {
    "Accept": "*/*", 
    "Content-Length": "8", 
    "Content-Type": "application/json", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.79.1", 
    "X-Amzn-Trace-Id": "Root=1-63454532-1aa1d82138215128077cd85d"
  }, 
  "json": {
    "a": 3
  }, 
  "url": "http://httpbin.org/post"
}
```

**响应头的 Content-Type**

当响应头中含有 `Content-Type` 时，它指明 Response Body 的媒体资源类型

- 因为我们可以通过 HTTP 去请求各种各样的资源，因此 Content-Type 基本上可以是所有 MIME 类型。

而在前端中，涉及到的响应头中的 Content-Type 为以下几种：

- `text/html`
- `text/css`
- `application/javascript`
- `image/png`
- `image/jpeg`
- `image/webp`
- `image/svg+xml`

**作业**

1. 你接触过哪些 MIME Type

2. 你在 HTTP Header 中见过那些 Content-Type

   有可能 MIME Type 并不仅仅在 Content-Type 中出现，比如在操作系统中你也会看到一个 excel/ppt/psd，他也是有 MIME Type 的，但可能在 Content-Type 中很少见到

## 11. User-Agent

`User-Agent` 请求头是用以表明客户端特征字符串，，一般也会简称为 `UA`

```bash
# curl 的 User-Agent 为 curl/7.79.1
$ curl httpbin.org/headers
{
  "headers": {
    "Accept": "*/*", 
    "Host": "httpbin.org", 
    "User-Agent": "curl/7.79.1", 
    "X-Amzn-Trace-Id": "Root=1-63413b72-69ed41753e5826a46b5f573e"
  }  
 }

# httpie 的 User-Agent 为 HTTPie/3.2.1
http --body httpbin.org/headers
{
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate",
    "Host": "httpbin.org",
    "User-Agent": "HTTPie/3.2.1",
    "X-Amzn-Trace-Id": "Root=1-63413b60-054f0ff42a87407e6316b91e"
  }
}
```

但是对于浏览器来说，其包含的信息就比较多了，他不仅可以表示出你所用的浏览器，浏览器版本号，还可以看出渲染引擎，**操作系统信息**等

```bash
// 在 MacOS 中的 Chrome 浏览器
'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'

// 在 iPhone 中的 Chrome 浏览器
'Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1
```

在浏览器中，可通过 API `navigator.userAgent` 查看其 UA，但是在移动端浏览器不方便打开控制台，可使用 [UA-Parser](https://devtool.tech/ua-parser) 查看浏览器的 UA

**浏览器如何判断 PC/Mobile**

.通过判断 API `navigator.userAgent` 可获取该浏览器发送请求时的 User-Agent 请求头，对于 Android/iPhone 可以匹配一下正则

- 也可以使用 [https://github.com/kaimallea/isMobile](https://github.com/kaimallea/isMobile) 库

```js
const appleIphone = /iPhone/i
const appleIpod = /iPod/i
const appleTablet = /iPad/i
const androidPhone = /\bAndroid(?:.+)Mobile\b/i // Match 'Android' AND 'Mobile'
const androidTablet = /Android/i

import isMobile from "ismobilejs"
const mobile = isMobile()
```

**打点统计**

基于 User-Agent 结合打点服务，可统计某网站的浏览器、操作系统、PC/Mobile 占比等数据。可使用 Google Analytics 进行统计

![image-20221025141815324](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221025141815324.png)

配置合适的 [browserslist](https://github.com/browserslist/browserslist) 规则，可减小垫片代码体积，提高网站性能

- `babel` 在 `@babel/preset-env` 中使用 `core-js` 作为垫片
- `postcss` 使用 `autoprefixer` 作为垫片

`browserslist` 的原理：根据正则解析查询语句，对浏览器版本数据库 `caniuse-lite` 进行查询，返回所得的浏览器版本列表

关于前端打包体积与垫片关系，我们有以下几点共识:

1. 由于低浏览器版本的存在，垫片是必不可少的
2. 垫片越少，则打包体积越小
3. 浏览器版本越新，则垫片越少

**内容协商**

同时 UA 请求头，也可用作内容协商，`User-Agent` 还有以下实际应用场景

- UA 判断是否移动端，据此返回移动端网站或者 PC 网站
- UA 判断是否搜索引擎爬虫，据此返回是否经 SEO 优化好的内容，比如 [prerender](https://github.com/prerender/prerender)
- UA 判断是否浏览器环境，据此返回不同内容

```bash
# 判断 UA 是否浏览器环境，如果是，返回 html 页面，这与直接打开该网址效果相同
$ curl https://ifconfig.me -H "User-Agent: chrome"

# 如果不是浏览器环境，直接返回 IP 地址
$ curl https://ifconfig.me
171.221.136.154
```

**作业**

1. 在浏览器中如何判断当前环境是移动端还是 PC 端

   ```js
   import isMobile from "ismobilejs"
   const mobile = isMobile()
   ```

2. 在浏览器中如何判断当前环境是否在 iPhone 中

   ```js
   /iPhone/i.test(navigator.userAgent)
   ```

3. 打点服务如何统计自己产品用户的各个浏览器版本的占比 

## 12. Referer

`Referer` 请求头指当前请求页面的来源地址。比如：

1. 你在谷歌搜索页面进入掘金，那该掘金网页的 Referer 就是谷歌搜索页面
2. 你在知乎文章页面进入掘金，那该掘金网页的 Referer 就是知乎文章页面
3. 你直接在地址栏输入掘金，那该掘金网页的 Referer 请求头不存在

而对于 JS/CSS/Image 来说，Referer 字段一般是对应的文档页面，即 HTML 页面，因为它是通过 HTML 页面中的链接而发起的请求

- 由于 `Referer` 可以拿到网站的来源页面，在打点服务中可以进行**打点统计分析**，取得本网站的来源网站的流量占比

**防盗链**

除了打点统计分析外，`Referer` 最大的功能是做图片防盗链

- 请求图片的请求头中的 `Referer` 将是图片所在的掘金文章地址。**如果掘金服务器端，判断请求图片的请求头** `Referer` **并不是掘金的域名，则禁止访问，返回 403 状态码**

除了图片防盗链，还有图片水印方式，比如掘金选择了后者，哔哩哔哩选择了图片防盗链，以哔哩哔哩首页轮播图及 curl 命令行为例说明：

**直接访问该图片地址，访问成功，从以下几点可以看出**

1. 200 状态码
2. content-type 为 image/png，证明是图片格式 
3. content-length 为 2182486，2MB 左右大小，证明不可能是占位符图片
4. 最后下载提示你为二进制图片格式，需要下载到本地

**而添加一个其它域名的 Referer 去请求该图片，则直接返回 403 状态码，被防盗链**

```bash
# 直接访问该图片地址，访问成功，从以下几点可以看出
$ curl -i https://i0.hdslb.com/bfs/banner/728f45f115c9b99752bb162664600a183b23c8da.png
HTTP/2 200
date: Wed, 12 Oct 2022 02:47:09 GMT
content-type: image/png
content-length: 2182486
server: openresty

Warning: Binary output can mess up your terminal. Use "--output -" to tell 
Warning: curl to output it to your terminal anyway, or consider "--output 
Warning: <FILE>" to save to a file.

# 添加一个其它域名的 Referer 去请求该图片，则直接返回 403 状态码，防盗链
$ curl -i -H "referer: https://llmysnow.top/" https://i0.hdslb.com/bfs/banner/728f45f115c9b99752bb162664600a183b23c8da.png
HTTP/2 403 
server: kngx/1.10.2
date: Wed, 12 Oct 2022 02:52:52 GMT
content-type: text/html
content-length: 168

<html>
<head><title>403 Forbidden</title></head>
<body bgcolor="white">
<center><h1>403 Forbidden</h1></center>
<hr><center>kngx/1.10.2</center>
</body>
</html>
```

**防防盗链**

- 既然防盗链的原理是判断 `Referer` 请求头，那岂不是不发即可以？
- 可以通过 `Referrer-Policy` 响应头控制是否发送 `Referer` 请求头

```bash
# 不发送 referer 请求头
Referrer-Policy: no-referrer
```

也可以将它置于 HTML 中

```html
<meta name="referrer" content="no-referrer" />
```

**作业**

1. Referer 请求头有那些使用场景

   - 打点统计分析
   - 图片防盗链

2. 图片防盗链的技术原理是什么

   判断 Referer 请求头，是否是期望的。如果不符合期望，就返回 403 状态码

3. 图片防盗链图片为何直接在浏览器**新标签页手动输入地址**可以打开

   新标签页的 Referer 为空

4. 你见过那些添加了防盗链的网站

5. 如何防止防盗链

   `Referrer-Policy: no-referrer`