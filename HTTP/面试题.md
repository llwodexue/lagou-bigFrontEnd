## http

**1.0 与 1.1 区别**

- 长连接
  - 1.1 默认开启 Connection: keep-alive，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少建立和关闭连接的消耗和延迟
- 缓存处理
  - 强缓存
    - 1.0 Expires
    - 1.1 Cache-Control
  - 协商缓存
    - 1.0 Last-Modified 和 If-Modified-Since
    - 1.1 ETag 和 If-None-Match
- 带宽优化
  - 1.0 存在浪费带宽，例如客户端只是需要某个对象的一部分，但是服务器却将整个对象传送过来
  - 1.1 引入了 range 头，它允许只请求某个部分，即返回码是 206
- Host 头
  - 1.0 认为每台服务器都有唯一 IP，但是随着虚拟主机技术发展，多个主机共享一个 IP 愈发普遍
  - 1.1 请求消息和响应消息都应支持 Host 头，否则会报 400

**1.x 与 2.0 区别**

1.x 存在的问题

- TCP 连接数限制

  对于同一个域名，浏览器最多同时创建 6~8 个 TCP 连接，为了解决数量限制，出现域名分片技术

- 队头阻塞

  当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，浏览器按 FIFO 原则处理请求，如果上一个没有返回，后续请求都会受阻

- header 内容多，没有相应压缩传输优化方案

- 明文传输不安全

2.0 优势

1. 二进制传输

   http2 采用二进制方式传输数据，而非 http1.x 里纯文本的报文，二进制解析起来更高效

2. 多路复用

   在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 标明这一帧属于哪个流，对方在接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据

   http1.1 每个请求都当做一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发给对方，这就是 http2 的多路复用

3. header 压缩

   使用 HPACK 算法压缩首部

4. 服务端推送

   浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求

http1.x 不是二进制传输，而是通过文本进行传输，由于没有流的概念，在使用并行传输时，接收端在接收响应后，并不能区分多个响应分别对应的请求，所以无法进行多路复用

http2 采用多路复用是指，在同一个域名下，开启一个 TCP 的 connection，每个请求以 stream 的方式传输，每个 stream 有唯一的标识，connection 一旦建立，后续的请求都可以复用这个 connection 并且可以同时发送，server 端可以根据 stream 的唯一标识来响应对应的请求



尽管 http2 解决了很多 1.1 的问题，但 http2 仍然存在一些缺陷，这些缺陷并不是来自于 http2 协议本身，而是来源于底层的 TCP 协议，我们知道 TCP 链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，http1.1 可以同时使用 6 个 TCP 连接，一个阻塞另外五个还能工作，但 http2 只有一个TCP连接，阻塞的问题便被放大了

http3 选择了一个折衷的方法 UDP 协议，http2 在 UDP 的基础上实现多路复用

## https

**http 和 https 区别**

- http 使用 80 端口，https 使用 443 端口
- https 需要申请证书
- http 是超文本传输协议，是明文传输，https 是经过 ssl 加密的协议，传输安全
- https 比 http 慢
  - 通信慢：除去 tcp 连接，发送 http 请求以外，还必须进行 ssl 通信
  - 加密处理：加密和解密运算处理耗时

**https 握手过程**

1. 客户端使用 https 的 url 访问 web 服务器，需要与服务器建立 ssl 连接
2. web 服务器收到客户端请求后，会将网站的证书传送给客户端
3. 客户端收到网站证书后会检查颁发机构以及过期时间，如果没有问题就随机产生一个秘钥
4. 客户端利用公钥对会话密钥加密，并传送给服务端，服务端利用自己的私钥对会话密钥解密
5. 之后服务端与客户端使用密钥加密传输

https 采用混合加密机制

- 在交换密钥环节使用非对称加密方式（一个公钥、一个私钥）
- 建立通信交互报文阶段使用对称加密方式

## 握手挥手

**握手为什么是三次？**

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

**挥手为什么是四次?**

- 因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN + ACK 报文
- 其中 ACK 报文是用来应答的，SYN 报文是用来同步的
- 但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的FIN报文我收到了”
- 只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送
- 故需要四次挥手

## 状态码

1. 1xx (信息性状态码) 接受的请求正在处理
2. 2xx 成功 请求正常处理完毕
   - 200 OK 客户端发来的请求在服务器端被正常处理了
   - 204 No Content 服务器接收的请求已成功处理,但是返回的响应报文中不含实体的主体部分，另外,也不允许返回任何实体的主体
     一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
   - 206 Partial Content 客户端进行了范围请求,而服务器成功执行了这部分的Get请求,响应报文中包含Content-Range指定范围的实体内容
3. 3xx 重定向 需要进行附加操作已完成请求
   - 301 Moved Permanently 永久性重定向
   - 302 Found 临时性重定向
   - 303 See Other 表示由于请求对应的资源错在着另一个URI,应用GET方法定性获取请求的资源
   - 304 Not Modified 表示客户端发送附带条件的请求时,服务器允许请求访问资源,但未满足条件的情况下
   - 附带条件的请求是指采用GET方法的请求报文中包含If-Match,If-Modified-Since, If-None-Match，If-Range，If-Unmodified-Since中任一的首部
4. 4xx 客户端错误 服务器无法处理请求
   - 400 Bad Request 请求报文中存在语法错误
   - 401 Unauthorized 表示发送的请求需要有通过HTTP认证
   - 403 Forbidden 对请求资源的访问被服务器拒绝了
   - 404 Not Found 服务器无法找到请求的资源
5. 5xx 服务器错误 服务器处理请求错误
   - 500 Internal Server Error 服务器在执行时发生了错误
   - 503 Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护

## WebSocket

webSocket 和 http 一样，同属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。

除此之外，它与 http 协议不同的地方还有：

- http 只能由客户端发起，而 websocket 是双向的
- 没有同源限制，可以跨域共享资源

## TCP UDP

TCP 

- 可靠：消息确定要收到，发送失败，会重新传输
- 有序：每个数据包有编号

UDP

- 消息不确定收到，可能丢包
- 无序

## CSRF

> [https://github.com/funnycoderstar/blog/issues/142](https://github.com/funnycoderstar/blog/issues/142)

跨站请求伪造（Cross Site Request Forgery），是指黑客诱导用户打开黑客的网站，在黑客的网站中，利用用户的登陆状态发起的跨站请求。CSRF 攻击就是利用了用户的登陆状态，并通过第三方的站点来做一个坏事

要完成一次CSRF攻击,受害者依次完成两个步骤:

1. 登录受信任网站A，并在本地生成 Cookie
2. 在不登出 A 的情况，访问危险网站 B



**如何防御 CSRF？**

- 利用 Cookie 的 SameSite
  - Strict。浏览器会完全禁用第三方 cookie。比如 a.com访问 b.com 资源，那么 a.com 中的 cookie 不会发送到 b.com 服务器，只有从 b.com 的站点去请求 b.com 的资源，才会带上这些 cookie
  - Lax。相对宽松一些
  - 在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 POST 方法或者通过 img、Iframe 等标签加载的 URL，这些场景都不会携带 Cookie
  - None。任何情况下都会发送 Cookie 数据
- 验证请求的来源点
  - 可以在服务端验证请求来源的站点，禁止第三方站点的请求，可以通过 HTTP 请求头中的 Referer 和 Origin 属性
- CSRF Token
  - 最开始浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串种植到返回的页面中(可以通过 Cookie)
  - 浏览器之后再发起请求的时候，需要带上页面中的 `CSRF Token`（在 request 中要带上之前获取到的 Token，比如 `x-csrf-token：xxxx`）, 然后服务器会验证该 Token 是否合法。第三方网站发出去的请求是无法获取到 `CSRF Token` 的值的

**Fetch 的 credentials 参数**

如果没有配置 credential 这个参数，fetch 是不会发送 Cookie 的

credential 的参数如下

- include：不论是不是跨域的请求，总是发送请求资源域在本地的 Cookies、HTTP Basic anthentication 等验证信息
- same-origin：只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息
- omit： 从不发送 cookies

## XSS

> [https://github.com/funnycoderstar/blog/issues/141](https://github.com/funnycoderstar/blog/issues/141)

跨站脚本攻击（Cross Site Script）,本来缩写是 CSS, 但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区分，所以安全领域叫做 “XSS”

XSS 攻击，通常是指攻击者通过 “HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，对用户的浏览器进行控制或者获取用户的敏感信息（Cookie, SessionID等）的一种攻击方式

页面被注入了恶意 JavaScript 脚本，浏览器无法判断区分这些脚本是被恶意注入的，还是正常的页面内容，所以恶意注 入Javascript 脚本也拥有了所有的脚本权限。如果页面被注入了恶意  JavaScript 脚本，它可以做哪些事情呢？

1. **可以窃取 cookie信息**。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。
2. **可以监听用户行为**。恶意JavaScript可以使用 "addEventListener"接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。
3. 可以**修改DOM** 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。
4. 还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。

XSS攻击可以分为三类：反射型，存储型，基于DOM型(DOM based XSS)

**反射型**

在实际的开发过程中，我们会碰到这样的场景，在页面A中点击某个操作，这个按钮操作是需要登录权限的，所以需要跳转到登录页面，登录完成之后再跳转会A页面，我们是这么处理的，跳转登录页面的时候，会加一个参数 returnUrl，表示登录完成之后需要跳转到哪个页面，即这个地址是这样的 `http://xxx.com/login?returnUrl=http://xxx.com/A`，假如这个时候把returnUrl改成一个script脚本，而你在登录完成之后，如果没有对returnUrl进行合法性判断，而直接通过`window.location.href=returnUrl`，这个时候这个恶意脚本就会执行

**存储型**

比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码

在用户名的输入框输入 `<script>alert('存储型 XSS 攻击')</script>`

**基于DOM(DOM based XSS)**

基于DOM攻击大致需要经历以下几个步骤

1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL
3. 用户浏览器接受到响应后执行解析，前端JavaScript取出URL中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，冒充用户行为，调用目标网站接口执行攻击者指定的操作

在输入框输入 如下内容 `'' onclick=alert('哈哈，你被攻击了')`

首先用两个单引号闭合调 href 属性，然后插入一个 onclick 事件。点击这个新生成的链接，脚本将被执行



**如何防御 XSS？**

- HttpOnly

  由于很多 XSS 都是来盗用 Cookie 的，因此可以通过使用 HttpOnly 属性来防止通过 document.cookie 来获取 cookie

  需要注意的一点是：HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击

- 输入和输出的检查

  **永远不要相信用户的输入**。

  输入检查一般是检查用户输入的数据是都包含一些特殊字符，如 `<`、`>`, `'`及`"`等。如果发现特殊字符，则将这些字符过滤或编码。这种可以称为 “XSS Filter”

- 防御 DOM Based XSS

  从JavaScript输出到HTML页面，相当于一次 XSS输出的过程，需要根据不同场景进行不同的编码处理

  1. 变量输出到 `<script>`，执行一次 JavascriptEncode
  2. 通过JS输出到HTML页面
     - 输出事件或者脚本，做 JavascriptEncode 处理
     - 输出 HTML内容或者属性，做 HtmlEncode 处理

  会触发 DOM Based XSS的地方有很多，比如

  - xxx.interHTML
  - xxx.outerHTML
  - document.write
  - 页面中所有的inputs框
  - XMLHttpRequest返回的数据

- 利用 CSP

  [CSP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP) (Content Security Policy) 即内容安全策略，是一种可信白名单机制，可以在服务端配置浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击

  通常可以通过两种方式来开启 CSP：

  - 设置 HTTP Header 的 `Content-Security-Policy`

  ```html
  Content-Security-Policy: default-src 'self'; // 只允许加载本站资源
  Content-Security-Policy: img-src https://*  // 只允许加载 HTTPS 协议图片
  Content-Security-Policy: child-src 'none'    // 允许加载任何来源框架
  ```

  - 设置 meta 标签的方式

  ```html
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
  ```

