## 柯里化函数 curry

```js
function curry(fn) {
  return function curriedFn(...args1) {
    if (args1.length < fn.length) {
      return function (...args2) {
        return curriedFn(...[...args1, ...args2])
      }
    }
    // 参数一致直接执行
    return fn(...args1)
  }
}

function getSum(a, b, c) {
  return a + b + c
}
const curried = curry(getSum)
console.log(curried(1, 2, 3))
console.log(curried(1, 2)(3))
```

## 合成函数 compose

```js
function compose(...args) {
  return function (value) {
    return args.reverse().reduce((acc, fn) => fn(acc), value)
  }
}

const reverse = arr => arr.reverse()
const first = arr => arr[0]
const toUpper = s => s.toUpperCase()
const f = compose(toUpper, first, reverse)
console.log(f(['one', 'two', 'three'])) // THREE
```

## 深拷贝 deepClone

`JSON.stringify()` 方法会做 2 件事：

1. 将指转换成一个 JSON 字符串
2. 如果有指定的 replacer 转换函数则继续转换该值

`JSON.parse(JSON.stringify(obj))` 有如下问题：

- 函数 undefined、Symbol 序列化会丢失信息
- 时间对象，返回的是字符串形式而不是时间对象
- RegExp、Set、Map 序列表只得到空对象
- NaN、Infinity 序列化结果会变为 null
- 循环引用、属性值为 BigInt 直接报错

```js
// 有些 value 会返回 undefined
JSON.stringify(undefined)
undefined
JSON.stringify(() => {})
undefined
JSON.stringify(Symbol("xx"))
undefined

// 有些 value 会返回 {}
JSON.stringify(new Set())
'{}'
JSON.stringify(new Map())
'{}'
JSON.stringify(new RegExp())
'{}'

// 有些 value 会返回 null
JSON.stringify(Infinity)
'null'
JSON.stringify(NaN)
'null'
JSON.stringify(null)
'null'

// 信息不准确
JSON.stringify(new Date())
'"2023-02-09T03:05:08.167Z"'

// 不允许出现循环引用，属性值也不能是 BigInt
TypeError: Converting circular structure to JSON
TypeError: Do not know how to serialize a BigInt
```

考虑如下几种情况：

1. 属性是基本类型
2. 属性是对象
3. 属性是数组
4. 循环引用的情况 obj.prop = obj

```js
function deepCloneV1(originObj, map = new WeakMap()) {
  if (typeof originObj === 'object') {
    if (map.get(originObj)) {
      return map.get(originObj)
    }
    const cloneObj = Array.isArray(originObj) ? [] : {}
    map.set(originObj, cloneObj)

    for (const prop in originObj) {
      cloneObj[prop] = deepCloneV1(originObj[prop], map)
    }
    return cloneObj
  } else {
    return originObj
  }
}
```

还存在一些问题

1. 一些特殊类型的对象，比如：Date、RegExp、Set、Map
1. 使用 typeof 来判断是否是对象有问题，typeof null -> 'object'

```js
function deepCloneV2(originObj, map = new Map()) {
  if (isObject) {
    if (map.get(originObj)) {
      return map.get(originObj)
    }
    const descObj = Object.getOwnPropertyDescriptors(originObj)
    const cloneObj = Object.create(Object.getPrototypeOf(originObj), descObj)
    map.set(originObj, cloneObj)

    const type = [Map, WeakMap, Set, WeakSet, Date, RegExp]
    if (type.includes(originObj.constructor)) {
      return new originObj.constructor(originObj)
    }

    for (const prop of Reflect.ownKeys(originObj)) {
      cloneObj[prop] =
        isObject(originObj[prop]) && typeof originObj[prop] !== 'function'
          ? deepCloneV2(originObj[prop], map)
          : originObj[prop]
    }
    return cloneObj
  } else {
    return originObj
  }
}

function isObject(obj) {
  return (typeof obj === 'object' || typeof obj === 'function') && obj !== null
}
```

进行测试

```js
let obj = {
  fun: function () {},
  syb: Symbol('foo'),
  a: undefined,
  b: NaN,
  c: Infinity,
  reg: /^abc$/,
  date: new Date(),
  set: new Set([1, 2, 3, 4, 4]),
  map: new Map([
    ['name', '张三'],
    ['title', 'Author']
  ]),
  text: 'aaa'
}
let cloneObj = deepCloneV2(obj)
console.log(cloneObj)
```

## Promise

Promise.race

```js
function racePromise(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(item => {
      Promise.resolve(item)
        .then(res => {
          return resolve(res)
        })
        .catch(err => {
          return reject(err)
        })
    })
  })
}
```

Promise.all

```js
function allPromise(promises) {
  return new Promise((resolve, reject) => {
    const result = []
    const count = 0
    const total = promises.length
    promises.forEach((item, i) => {
      Promise.resolve(item)
        .then(res => {
          result[i] = res
          count++
          if (count === total) {
            return resolve(result)
          }
        })
        .catch(err => {
          return reject(err)
        })
    })
  })
}
```

Promise.any

```js
function anyPromise(promises) {
  return new Promise((resolve, reject) => {
    const result = []
    let count = 0
    const total = promises.length
    promises.forEach((item, i) => {
      Promise.resolve(item)
        .then(res => {
          return resolve(res)
        })
        .catch(err => {
          result[i] = err
          count++
          if (count === total) {
            return reject(result)
          }
        })
    })
  })
}
```

## new

1. 创建一个新的空对象
2. 将新对象的原型指向当前函数的原型
3. 新创建的对象绑定到当前 this 上
4. 如果没有返回其他对象，就返回 obj，否则返回其他对象



## 数组去重

```js
Array.prototype.uniq = function () {
  /* 1 */
  return [...new Set(this)]

  /* 2 */
  const map = new Map()
  let arr = []
  for (let i = 0; i < this.length; i++) {
    if (!map.has(this[i])) {
      map.set(this[i], 1)
      arr.push(this[i])
    }
  }
  return arr

  /* 3 */
  this.sort((a, b) => a - b)
  let j = 0
  for (let i = 1; i < this.length; i++) {
    if (this[i] !== this[j]) {
      j += 1
      this[j] = this[i]
    }
  }
  return this.splice(0, j + 1)
}
```

