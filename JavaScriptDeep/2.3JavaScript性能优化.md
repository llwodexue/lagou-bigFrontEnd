## JavaScript 内存管理

![一段代码的性能](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%A7%E8%83%BD.png)

**内存管理**

- 内存：由可读写单元组成，表示一片可操作性空间
- 管理：人为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间
- 管理流程：申请-使用-释放

**JS 内存管理**

- 申请内存空间
- 使用内存空间
- 释放内存空间

```js
// 申请空间
let obj = {}
// 使用空间
obj.name = 'jack'
// 释放空间
obj = null
```

## 垃圾回收与常见 GC 算法

### JavaScript 中的垃圾回收

- JavaScript 中内存管理是自动的
- 对象不再被 **引用** 时是垃圾
- 对象不能 **从根上访问到** 时是垃圾

**JavaScript 中的可达对象**

- 可以访问到的对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript 中的根可以理解为 **全局变量**

```js
let obj = { name: 'bird' }
let dog = obj
// 虽然被清理了，但是dog还在引用着，还是可达的
obj = null
```

![可达对象图示](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E5%9B%BE%E7%A4%BA.png)

```js
function objGroup(obj1, obj2) {
  obj1.next = obj2
  obj2.prev = obj1
  return {
    o1: obj1,
    o2: obj2,
  }
}
let obj = objGroup({ name: 'obj1' }, { name: 'obj2' })
```

现在通过 delete 语句，把 obj 中对 o1 的引用（`delete obj.o1`）以及 obj2 对 obj1 的引用（`delete obj2.prev`）都 delete 掉，因为没有办法通过某些方式找到 o1，所以 o1 会被垃圾回收

![可达对象进行delete](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8Cdelete.png)

### GC 算法

**GC 定义与作用**

- GC 就是垃圾回收机制的简写（Garbage Collection）
- GC 可以找到内存中的垃圾、并释放和回收空间

![GC里的垃圾是什么](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/GC%E9%87%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E6%98%AF%E4%BB%80%E4%B9%88.png)

**GC 算法是什么**

- GC 是一种机制，垃圾回收器完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

**常见 GC 算法**

- 引用计数
- 标记清除
- 标记整理
- 分代回收

#### 引用计数

- 核心思想：设置引用数，判断当前引用数是否为 0
- 引用计数器，引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

```js
const user1 = { age: 11 }
const user2 = { age: 22 }
// 即使脚本执行完，因为在全局还是找到到，所以不会被回收
const nameList = [user1.age, user2.age]

function fn() {
  // 因为挂载在window上，即使fn执行完毕，计数也不是0
  num1 = 1
  // 加上const后只在作用域内起作用，从全局是找不到的，计数为0
  const num2 = 2
}
fn()
```

**引用计数算法优点**

- 发现垃圾时立即回收
- 最大限度减少程序暂停

**引用计数算法缺点**

- 无法回收循环引用的对象
- 时间开销大（需要监控对象数值变化）

```js
function fn() {
  const obj1 = {}
  const obj2 = {}
	// obj1引用obj2，obj2引用obj1
  obj1.name = obj2
  obj2.name = obj1
}
fn()
```

#### 标记清除

- 核心思想：分标记和清除两个阶段完成

## V8 引擎的垃圾回收

## Performance 工具

