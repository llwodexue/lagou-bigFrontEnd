# V8 引擎

Chrome V8 或简称 V8 是 Google 开发的，用 C++ 编写的开源 Javascript 和 WebAssembly 引擎。V8 引擎最初是为基于 Chromium 的浏览器和 Chrome 浏览器构建的，旨在提高 JavaScript 执行的性能，但也可以在浏览器之外执行 JavaScript 代码，从而实现服务器端脚本编写。如今，V8 引擎是 Node.js、MongoDB 和 Electron 等桌面应用程序等各种技术的基础

## 为什么要有V8引擎

V8 引擎产生的那个时候，Javascript 的执行速度很慢，无法处理复杂的计算任务，那么也就是意味着实现复杂的 web 应用是非常困难的

当时许多传统语言如 java 和 C# 在编译代码并创建字节码后，最终由计算机执行。但生成字节码会产生额外开销，会降低编译器的效率。而 V8 引擎可以将 javascript 代码直接编译为机器语言，即可以由系统直接执行的语言，而不需要使用解释器

- 这让 V8 当时在理念上也是遥遥领先的。后面因为直接编译为机器码占用内存太大，改为了先编译为字节码后编译为机器码

V8 引擎还使用其他优化技术，在当时遥遥领先

1. Inline expansion

   ```js
   function multiply(a, b) {
     return a * b
   }
   function calculate() {
     let x = 5
     let y = 10
     let result = multiply(x, y) // 函数调用
     console.log(result)
   }
   calculate()
   ```

   当 V8 引擎执行这段代码时，它可能会检测到 multiply 函数的调用处可以进行内联扩展的优化。这意味着引擎会将 multiply 函数的代码直接插入到调用点。这样做可以减少函数调用的性能开销

   所以，当内联扩展被应用在这个例子中时，calculate 函数的代码可能会被优化为：

   ```js
   function calculate() {
     let x = 5
     let y = 10
     let result = x * y // 内联扩展
     console.log(result)
   }
   calculate()
   ```

2. Copying elision，用于减少数据的显式复制，从而提高内存操作的性能

   createObject 函数返回一个 MyClass 对象。在没有 Copy elision 的情况下，会创建一个临时对象并将其拷贝到返回值中。然而，由于 JavaScript 引擎的优化，实际执行时并没有进行拷贝操作，而是直接构造了返回值对象。

   ```js
   class MyClass {
     constructor() {
       console.log('Constructor called.')
     }
   }
   function createObject() {
     const obj = new MyClass()
     return obj
   }
   const newObj = createObject()
   ```

   