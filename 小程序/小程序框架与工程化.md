## 小程序框架

### 小程序平台区别

微信⽂档：[https://developers.weixin.qq.com/miniprogram/dev/api/](https://developers.weixin.qq.com/miniprogram/dev/api/)

百度⽂档：[https://smartprogram.baidu.com/docs/develop/api/apilist/](https://smartprogram.baidu.com/docs/develop/api/apilist/)

⽀付宝⽂档：[https://opendocs.alipay.com/mini/api](https://opendocs.alipay.com/mini/api)



相似内容：

- 均有原生组件和 webview 中渲染的组件
- ⼤部分配置和项⽬结构（app.json/app.js）都相同，甚至之前出现了支付宝小程序文档直接拷贝微信小程序文档的情况
- 他们都支持第三方平台（TP），来对用户授权的小程序进行操作，例如微信开发者平台，可以通过 sass 软件操作小程序的发布

不同的内容：

- 部分 API 名称和参数不同，例如各自使用不同的全局对象下的方法（wx/swan/my）
- 不同平台侧重的能力不同：
  - 支付宝侧重商家侧，创建的默认为企业用户，同时可以开启支付，使用一些支付宝内部的端能力
  - 百度小程序更侧重流量相关获取，我们可以通过设置自然搜索、提交信息流等手段，增加小程序的曝光率。同时 API 中有很多 AI 能力内置，让我们在使用 AI 上面更加得心应手
  - 微信小程序更侧重基础能力，推广上也增加了搜索快速展示的按钮等等
- 只有微信小程序⽀持个人申请使⽤，百度/⽀付宝仅⽀持企业使⽤

小程序之间的差异具体体现在 api 的差异当中，目前各家的小程序在运行时的差异已经非常小了，底层功能都已经非常稳定。书写小程序代码的过程中只需要注意对应 API 的使用即可



对于语法来说，其实多家小程序大同小异，都是使用类似 html 的模板语法 + 对应的样式文件 + 对应的逻辑脚本即可。每个小程序都需要实例化 App，每个页面都需要实例化，每个页面都需要实例化 Page，最终通过 setData 触发的数据更新从而渲染页面内容

### 小程序框架对比

对于开发者来说，应对多端小程序的开发是比较麻烦的，所以社区出现很多一次书写，多端运行的小程序开发框架。

- kbone：微信官方推出的一个框架，任何语言书写的框架都能直接使用
- mpvue：mpvue 是一个通过 vue 进行开发，同时支持多端的框架。目前支持微信、百度、头条和支付宝小程序
- remax：remax 是由阿里推出的一款小程序制作框架，能同时运行在微信小程序/支付宝小程序/字节跳动小程序当中
- taro：taro 目前支持微信/百度/支付宝/百度小程序和 h5，算是目前支持的平台最多也在持续维护的一个框架平台。它也是一套遵循 React 语法规范的 多端开发解决方案。通过 Taro 的编译工具，将源代码分别编译出可以在不同端(微信/百度/支付宝/字节跳动/QQ/京东小程序、快应 用、H5、React-Native 等)运行的代码

### kbone

kbone 是由腾讯发布的一款解决微信小程序和 web 端同构的框架

- github 地址: [https://github.com/Tencent/kbone](https://github.com/Tencent/kbone)

传统的开发小程序与 web 应用，因为小程序与 web 开发之间有较大区别，代码难以复用。这类同构框架，总结起来就是写一次代码，同时运行在微信小程序端和浏览器端

lerna 优势

- 比如：改了一个模块的版本号，就得去另一个模块里修改对应版本号。使用 lerna 就可以把不同版本挪到一起去，之后通过 lerna.json 维护

#### 仓库内容

通过 lerna 管理的 kbone 仓库，主要分为以下几部分内容

- kbone-cli: 命令行工具。主要在于初始化一些参数的配置相关的内容
- miniprogram-element: （重要）用于在运行时将 html 内容转化为小程序的内置组件以及一些基础模版部分
- miniprogram-render: （重要）在小程序中模拟的一些 DOM/BOM 环境的内容，例如window/location/history/navigator... 的浏览器环境下的对象方法。document.getElementByld 等方法，事件模型等内容。
- mp-webpack-plugin: （重要）主要处理一些小程序基本骨架，reset css 等内容
- reduce-loader:一个 webpack loader 来处理一些无用的代码
- vue-cli-plugin-kbone: vue-cli 的插件，这样就能在 vuecli 初始化的项目中来直接使用 kbone
- vue-improve-loader: 用于精简 vue 项目中 DOM 树结构的 webpack loader

#### miniprogram-element

`subtree.wxml`

```html
<template name="subtree">
  <block wx:for="{{childNodes}}" wx:key="nodeId">
    <view wx:if="{{item.type === 'view'}}">{{item.value}}</view>
    <text wx:if="{{item.type === 'text'}}">{{item.value}}</text>
    <button wx:if="{{item.type === 'button'}}" size="{{item.size}}">{{item.value}}</button>
  </block>
</template>
```

`pages/index/index.wxml`

```html
<import src="../../subtree.wxml" />
<template is="subtree" data="{{childNodes}}" />
```

#### miniprogram-render

![image-20231018080426813](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20231018080426813.png)

#### logger.js

```js
const chalk = require('chalk')

exports.info = function (type, message) {
  console.log(`${chalk.bold.magenta(type)}: ${message}`)
}
exports.error = function (message) {
  console.log(chalk.red(message))
  process.exit(1)
}
exports.success = function (message) {
  console.log(chalk.green(message))
}
```

### Taro

taro 目前支持微信/百度/支付宝/百度小程序和 h5，算是 目前支持的平台最多，也在持续维护的一个框架平台。它也是一套遵循 React 语法规范的 多端开发解决方案。通过 Taro的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码

对于现阶段的 taro 版本来说，taro 是一个完全静态的框架，这也是和 kbone 最大的不同，新版本的 taro 已经采用了运行时染的策略

特性

- 支持使用npm/yarn安装管理第三方依赖
- 支持使用 ES7/ES8 甚至更新的 ES 规范，一切都可自行

配置

- 支持使用 CSS 预编译器，例如 Sass 等 支持使用 Redux 进行状态管理
- 支持使用 MobX 进行状态管理
- 小程序 API 优化，异步 API Promise 化等等

但这样会造成一个比较严重的问题在于，静态框架不能处理一些比较复杂的场景，例如通过 props 的变化，从而更新 UI 的染。

```js
render() {
  return (
    <View>
      {this.props.list.map(item => (
        <View>item</View>
      ))}
    </View>
  )
}
```

在这个例子中，因为 list 从 props 中获取，导致静态编译时，无法处理此种场景 (或者说处理这种场景比较复杂)所以很多时候，依赖动态变量渲染会造成很多问题。

他是一个静态编译的框架，所以也就是说我们最终的代 码都是已经编译为能直接在平台中运行的了，所以主要 的工作对于 taro 来说是在编译阶段进行

对于微信小程序的转译，我们只需要关注 taro-tarnsformer-wx 即可，在 index.ts 中，通过 ts 和 babel将 编译的结果进行分析，将分析到的 AST 结构进行处理，通过不同的 AST 结果执行不同的操作

执行完成之后，通过 parseJsxchildren 等解析方法，将 jsx 转化为 wxml

### mpvue

mpvue 是一个通过 vue 进行开发，同时支持多端的框架。目前支持 微信、百度、头条和支付宝小程序。它在运行时还依赖了部分 vue.runtime.js 的代码

特点

- mpvue 保留了 vue.runtime 核心方法，无缝继承了 Vuejs 的基础能力
- mpvue-template-compiler 提供了将vue的模板语法转换到小程序的 wxml 语法的能力
- 修改了 vue 的建构配置，使之构建出符合小程序项目 结构的代码式:json/wxml/wxss/js 文件

### remax

remax 是最近由阿里推出的一款小程序制作框架，能同时运行在微信小程序/支付宝小程序/字节跳动小程序当中

特性:

- 使用 react 的风格和方式来进行小程序的开发
- 使用 Remax 把代码转换到多个小程序平台
- 完整的 TypeScript 支持

## 小程序工程化

### uni-app

小程序原生，比如每一个页面需要以下四个文件

- index.js
- index.json
- index.wxml
- index.wxss

**编译器**

uni-app 编译器具体要做什么？

- 比较通用的方式就是把单 vue 文件编译成 .js、.json、.wxml、.wxss（业界使用的方式）
- 一步到位，直接把 vue 文件编译成开发者工具打包后的 js，这种方式可读性非常差，在开发者工具里调试也很麻烦

**运行时**

小程序有自己一套运行时设计

1. 生命周期：onLoad、onLaunch、onAttach
2. 事件函数：@tap、@click
3. AppData

vue 和原生小程序宏观架构上是相似的，只是具体内部实现不同

1. 数据同步机制

   uni-app 将数据的控制权完全交给 vue，由 vue 来控制 data，最后再同步给小程序 AppData，小程序负责页面的展示

2. 事件代理机制

   当用户在小程序上进行操作，触发了一些事件，比如：scroll、click，会经过 uni-app 转发给 vue

3. 生命周期

   uni-app 中直接将小程序的生命周期代理到 vue 中，然后开发人员只需要在 vue 中写具体的生命周期

uni-app 在渲染性能优化上做的事情

- vue 在视图更新的时候，会产生 vnode，然后 vnode 和实际的页面 DOM 相关联，但是如果发布到小程序里，vnode 和小程序的 DOM 是对应不起来的
  - 小程序只负责页面渲染，页面 DOM 是由小程序生成的，小程序只接受 data 数据
  - vue 中的 vnode 很难和小程序里的 DOM 对应
  - vue 的 vnode 的 diff 逻辑复杂，无法直接搬到小程序里使用
- uni-app 觉得，vue 中 vnode 在小程序中意义不大，决定彻底干掉
  - vue 编译阶段，vue 会在静态节点上做标注，为了后期 vnode 的 diff 的性能优化，所以这里可以去掉
  - vue render function，vnode 的生成也是在这里实现的，所以可以在 render 里把所有和 vnode 相关的全部去掉
  - vue vnode patch，vue 在数据更新的时候会做 vnode 遍历，这里也可以去掉
- 小程序的更新是 setData，js -> 触发setData -> native客户端 -> view，所以 setData 消耗都是巨大的，uni-app 主要做的就是减少 setData 的频次，减少每次 setData 的数据量
  - 因为直接使用了 vue，vue 中的 nextTick 机制会自动合并短时间内对于 data 的赋值，所以通过 vue 来管理数据，可以间接合并 setData，以达到减少频次的效果
  - 减少数据量
    - 借鉴了 westore JSON diff 库，实现精确、高效的差量更新
    - 改写了 vue 的 patch 逻辑，删掉 vnode，仅保留数据的 diff

![image-20231018152935231](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20231018152935231.png)

```bash
$ npm i -g @vue/cli
$ vue create -p dcloudio/uni-preset-vue xxx
```

