## 纯函数

函数式编程中有一个非常重要的概念叫纯函数，JavaScript 符合函数式编程的范式，所以也有纯函数的概念

- 在 react 开发中纯函数是被多次提及的
- 比如 react 中组件就被要求像是一个纯函数（为什么是像，因为还有 class 组件），redux 中有一个 reducer 的概念，也是要求必须是一个纯函数
- 所以掌握纯函数对于理解很多框架的设计是非常有帮助的

纯函数的维基百科定义：

- 在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数
- 此函数在相同的输入值时，需产生相同的输出
- 函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关
- 该函数不能有语义上可观察的函数副作用，诸如 "触发事件"，使输出设备输出，或更改输出值以外物件的内容等

总结一下：

- 确定的输入，一定会产生确定的输出
- 函数在执行过程中，不能产生副作用

**副作用**

- 副作用（side effect）其实本身是医学的一个概念，比如我们经常说吃什么药本来是为了治病，可能会产生一些其他的副作用
- 在计算机科学中，也引用了副作用的概念，表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，
  比如修改了全局变量，修改参数或者改变外部的存储；

数组操作的两个函数：

- slice：slice 截取数组时不会对原数组进行任何操作,而是生成一个新的数组
- splice：splice 截取数组, 会返回一个新的数组, 也会对原数组进行修改

slice 就是一个纯函数，不会修改数组本身，而 splice 函数不是一个纯函数

为什么纯函数在函数式编程中非常重要呢？

- 因为你可以安心的编写和安心的使用
- 你在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改
- 你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出

React 中就要求我们无论是函数还是 class 声明一个组件，这个组件都必须像纯函数一样，保护它们的 props 不被修改：

![image-20221124093154285](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124093154285.png)

## Redux 核心概念

JavaScript 开发的应用程序，已经变得越来越复杂了：

- JavaScript 需要管理的状态越来越多，越来越复杂
- 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等，也包括一些 UI 的状态，比如某些元素是否被选中，是否显示加载动效，当前分页

管理不断变化的 state 是非常困难的：

- 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View 页面也有可能会引起状态的变化
- 当应用程序复杂时，state 在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪

React 是在视图层帮助我们解决了 DOM 渲染过程，但是 State 依然是留给我们自己来管理：

- 无论是**组件定义自己的 state**，还是**组件之间的通信通过 props 进行传递**；也包括**通过 Context 进行数据之间的共享**
- React主要负责帮助我们管理视图，state 如何维护最终还是我们自己来决定

Redux 就是一个帮助我们管理 State 的容器：Redux 是 JavaScript 的状态容器，提供了可预测的状态管理

### 三个核心概念

**Store**

比如我们有一个朋友列表需要管理：

- 如果我们没有定义统一的规范来操作这段数据，那么整个数据的变化就是无法跟踪的
- 比如页面的某处通过 products.push 的方式增加了一条数据
- 比如另一个页面通过 products[0].age = 25 修改了一条数据

![image-20221124104405801](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124104405801.png)

**action**

Redux 要求我们通过 action 来更新数据：

- 所有数据的变化，必须通过派发（dispatch）action 来更新
- action 是一个普通的 JavaScript 对象，用来描述这次更新的 type 和 content

比如下面就是几个更新 friends 的 action：

- 强制使用 action 的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的
- 当然，目前我们的 action 是固定的对象
- 真实应用中，我们会通过函数来定义，返回一个 action

![image-20221124104516087](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124104516087.png)

**reducer**

如何将 state 和 action 联系在一起呢？答案就是 reducer

- reducer 是一个纯函数
- reducer 做的事情就是将传入的 state 和 action 结合起来生成一个新的 state

![image-20221124104738110](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124104738110.png)

### 三大原则

**单一数据源**

- 整个应用程序的 **state 被存储在一颗 object tree 中**，并且**这个 object tree 只存在一个 store** 中
- Redux 并**没有将强制我们不能创建多个 Store**，但是**那样做并不利于数据的维护**
- **单一数据源**可以让整个应用程序的 state 变得**方便维护、追踪、修改**

**State 是只读的**

- **唯一修改 State 的方法一定是触发 action，不要试图在其他地方通过任何的方式来修改 State**
- 这样就确保了 View 或网络请求都**不能直接修改 state**，它们只能**通过 action 来描述自己想要如何修改 state**
- 这样可以**保证所有的修改都被集中化处理**，并且**按照严格的顺序来执行**，所以**不需要担心 race condition（竞态） 的问题**

**使用纯函数来执行修改**

- 通过 reducer 将**旧的 state 和 actions 联系在一起**，并且**返回一个新的 State**
- 随着**应用程序的复杂度增加**，我们**可以将 reducer 拆分成多个小的 reducers，分别操作不同 state tree 的一部分**
- 但是**所有的 reducer 都应该是纯函数**，不能产生任何副作用

## Redux 基本使用

### Redux 实践

使用过程：

1. 创建一个对象，作为我们要保存的状态
2. 创建 Store 来存储这个 state
   - 创建 store 时必须创建 reducer
   - 通过 store.getState 来获取当前 state
3. 通过 action 来修改 state
   - 通过 dispatch 来派发 action
   - 通常 action 里都会有 type 属性，也可以携带其他数据
4. 修改 reducer 中的代码
   - reducer 是一个纯函数，不需要直接修改 state
5. 可以在派发 action 之前，监听 store 的变化

示例代码：

`index.js`

```js
const store = require('./store')

const unsubscribe = store.subscribe(() => {
  console.log('订阅数据变化', store.getState())
})

// 修改 store 中的数据，必须用 action
store.dispatch({ type: 'change_name', name: 'why' })
store.dispatch({ type: 'add_count', num: 1 })

unsubscribe()
store.dispatch({ type: 'add_count', num: 1 })
```

`store/index.js`

reducer 接收 2 个参数

- 参数1：store 目前保存的 state
- 参数2：本次需要更新的 action

返回值：作为 store 之后存储的 state

```js
const { createStore } = require('redux')

// 初始化的数据
const initialState = {
  name: 'bird',
  count: 12
}
// 定义 reducer 函数，纯函数
function reducer(state = initialState, action) {
  // 有新数据进行更新，那么返回一个新的 state
  switch (action.type) {
    case 'change_name':
      return { ...state, name: action.name }
    case 'add_count':
      return { ...state, count: state.count + action.num }
    default:
      return state
  }
}
// 创建的 store
const store = createStore(reducer)

module.exports = store
```

### 优化

1. 将派发的 action 生成的过程放到一个 actionCreators 函数中
2. 将定义的所有 actionCreators 的函数，放到一个独立的文件中
3. actionCreators 和 reducer 函数中使用的字符串常量是一致的，所以将常量抽取到一个独立 constants 文件中
4. 将 reducer 和默认值（initialState）放到一个独立的 reducer 文件中，而不是在 index.js

![image-20221124150838644](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124150838644.png)

`index.js`

```js
const store = require('./store')
const { changeNameAction, addCountAction } = require('./store/actionCreators')


const unsubscribe = store.subscribe(() => {
  console.log('订阅数据变化', store.getState())
})

// 修改 store 中的数据，必须用 action
store.dispatch(changeNameAction('why'))
store.dispatch(changeNameAction('cat'))
store.dispatch(addCountAction(1))

unsubscribe()
```

`store/index.js`

```js
const { createStore } = require('redux')
const reducer = require('./reducer')

// 创建的 store
const store = createStore(reducer)

module.exports = store
```

`store/reducer.js`

```js
const { CHANGE_NAME, ADD_COUNT } = require('./constants')

// 初始化的数据
const initialState = {
  name: 'bird',
  count: 12
}

// 定义 reducer 函数，纯函数
function reducer(state = initialState, action) {
  // 有新数据进行更新，那么返回一个新的 state
  switch (action.type) {
    case CHANGE_NAME:
      return { ...state, name: action.name }
    case ADD_COUNT:
      return { ...state, count: state.count + action.num }
    default:
      return state
  }
}

module.exports = reducer
```

`store/actionCreators.js`

```js
const { CHANGE_NAME, ADD_COUNT } = require('./constants')

const changeNameAction = name => ({
  type: CHANGE_NAME,
  name
})
const addCountAction = num => ({
  type: ADD_COUNT,
  num
})

module.exports = {
  changeNameAction,
  addCountAction
}
```

`store/constants.js`

```js
const ADD_COUNT = 'add_count'
const CHANGE_NAME = 'change_name'

module.exports = {
  ADD_COUNT,
  CHANGE_NAME
}
```

node 中对 ES6 模块化的支持

- 目前我使用的 node 版本是 v12.16.1，从 node v13.2.0 开始，node 才对 ES6 模块化提供了支持
- node v13.2.0之前，需要进行如下操作：
  - 在 `package.json` 中添加属性： `"type": "module"`
  - 在执行命令中添加如下选项：`node --experimental-modules src/index.js`
- node v13.2.0之后，只需要进行如下操作：
  - 在 `package.json` 中添加属性： `"type": "module"`
- 导入文件时，需要跟上 `.js` 后缀名

![image-20221124153448148](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124153448148.png)

Redux 官方图

![image-20221124153623564](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221124153623564.png)