## React 简介

React：用于构建用户界面的 JavaScript 库

- React的官网文档：[https://zh-hans.reactjs.org/](https://zh-hans.reactjs.org/)

**React 特点**

- 声明式编程 
- 组件化开发
- 多平台适配

**声明式编程**

- 声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI
- 它允许我们只需要维护自己的状态，当状态改变时，React 可以根据最新的状态去渲染我们的 UI 界面

![image-20221031122620811](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031122620811.png)

**组件化开发**

- 组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件
- 如何合理的进行组件的划分和设计也是后面我会讲到的一个重点

![image-20221031122805520](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031122805520.png)

**多平台适配**

- 2013年，React 发布之初主要是开发 Web 页面
- 2015年，Facebook 推出了 ReactNative，用于开发移动端跨平台；（虽然目前 Flutter 非常火爆，但是还是有很多公司在使用 ReactNative）
- 2017年，Facebook 推出 ReactVR，用于开发虚拟现实 Web 应用程序；（VR 也会是一个火爆的应用场景）

![image-20221031122802006](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031122802006.png)

## React 基本使用

开发React必须依赖三个库：

- react：包含 react 所必须的核心代码
- react-dom：react 渲染在不同平台所需要的核心代码
- babel：将 jsx 转换成 React 代码的工具

对于 Vue 来说，我们只是依赖一个 vue.js 文件即可，但是 react 需要依赖三个包

react-dom 针对 web 和 native 所完成的事情不同：

- web端：react-dom 会将 jsx 最终渲染成真实的 DOM，显示在浏览器中
- native端：react-dom 会将 jsx 最终渲染成原生的控件（比如 Android 中的 Button，iOS 中的 UIButton）

React 和 Babel 的关系：

- 默认情况下开发 React 其实可以不使用 babel
- 但是前提是我们自己使用 React.createElement 来编写源代码，它编写的代码非常的繁琐和可读性差
- 那么我们就可以直接编写 jsx（JavaScript XML）的语法，并且让 babel 帮助我们转换成 React.createElement

**React 依赖引入**

```html
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> 
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

**Hello World**

`ReactDOM.createRoot` 函数：用于创建一个 React 根，之后渲染的内容会包含在这个根中

- 参数：将渲染的内容，挂载到哪一个 HTML 元素上

`root.render` 函数:

- 参数：要渲染的根组件

![image-20221031130630872](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031130630872.png)

## React 组件化开发

整个逻辑其实可以看做一个整体，那么我们就可以将其封装成一个组件：

-  `root.render` 参数是一个 HTML 元素或者一个组件
- 所以我们可以先将之前的业务逻辑封装到一个组件中，然后传入到 `ReactDOM.render` 函数中的第一个参数

在 React 中可以使用类的方式封装组件：

1. **定义一个类**（类名大写，组件的名称必须大写，小写会被认为是 HTML 元素）

2. **实现当前组件的 render 函数**

   render 当中返回的 jsx 内容，就是之后 React 会帮助我们渲染的内容

![image-20221031171546882](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031171546882.png)

### 数据在哪里定义

组件化问题一：**数据在哪里定义？**

在组件中的数据，我们可以分成两类：

- **参与界面更新的数据**：当数据变量时，需要更新组件渲染的内容
- **不参与界面更新的数据**：当数据变量时，不需要更新将组建渲染的内容

参与界面更新的数据我们也可以称之为是**参与数据流**，这个数据是**定义在当前对象的 state**中

- 我们可以通过在构造函数中 `this.state = {定义的数据}`

  ![image-20221031172841765](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221031172841765.png)

- 当我们的数据发生变化时，我们可以调用 `this.setState` 来更新数据，并且通知 React 进行 update 操作

- 在进行 update 操作时，就会重新调用 render 函数，并且使用最新的数据，来渲染界面

  ![image-20221114155532154](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221114155532154.png)

### 事件绑定中的 this

组件化问题二：**事件绑定中的this**

- 在类中直接定义一个函数，并且将这个函数绑定到元素的 onClick 事件上，当前这个函数的 this 指向的是谁呢？

- 默认情况下是 undefined

  - 很奇怪，因为在正常的 DOM 操作中，监听点击，监听函数中的this其实是节点对象（比如说是 button 对象）

  这里有 ES6 class 和 babel 的原因

  - 默认情况在 ES6 中 class 定义，默认情况下是严格模式
  - babel 默认也会将代码转换为严格模式

- 我们在绑定的函数中，可能想要使用当前对象，比如执行 this.setState 函数，就必须拿到当前对象的 this

  - 我们就需要在传入函数时，给这个函数直接绑定 this

    ` <button onClick={this.changeText.bind(this)}>改变文本</button>`

### 案例

案例一：列表

![image-20221114163015327](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221114163015327.png)

案例二：计树器

![image-20221114163046813](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221114163046813.png)

## JSX 语法

### 基础语法

**JSX 是什么**

- JSX 是一种 JavaScript 的语法扩展（eXtension），也在很多地方称之为 JavaScript XML，因为看起就是一段XML语法
- 它用于描述我们的 UI 界面，并且其完成可以和 JavaScript 融合在一起使用
- 它不同于 Vue 中的模块语法，你不需要专门学习模块语法中的一些指令（比如v-for、v-if、v-else、v-bind）

React 认为**渲染逻辑**本质上与**其他 UI 逻辑**存在内在耦合

- 比如 UI 需要绑定事件（button、a 原生等等）
- 比如 UI 中需要展示数据状态
- 比如在某些状态发生改变时，又需要改变 UI

他们之间是密不可分，所以 React 没有将标记分离到不同的文件中，而是将它们组合到了一起，这个地方就是组件（Component）

**JSX 的书写规范**

- JSX 的顶层只能有一个根元素，所以我们很多时候会在外层包裹一个 div 或 Fragment 元素
- 为了方便阅读，我们通常在 jsx 的外层包裹一个小括号()，这样可以方便阅读，并且 jsx 可以进行换行书写
- JSX 中的标签可以是单标签，也可以是双标签
- 注意：如果是单标签，必须以 `/>` 结尾

**JSX 注释**

![image-20221114171611975](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221114171611975.png)

### 插入内容

**JSX 嵌入变量作为子元素**

- 情况一：当变量是 Number、String、Array 类型时，可以直接显示
- 情况二：当变量是 null、undefined、Boolean 类型时，内容为空
  - 如果希望可以显示 null、undefined、Boolean，那么需要转成字符串
  - 转换的方式有很多，比如 toString 方法、和空字符串拼接，String(变量) 等方式
- 情况三：Object 对象类型不能作为子元素（not valid as a React child）

```jsx
class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 100,
      message: 'Hello World',
      names: ['abc', 'cba', 'nba'],
      aaa: undefined,
      bbb: null,
      ccc: true,
      friend: { name: 'kobe' },
      firstName: 'kobe',
      lastName: 'bryant',
      age: 20,
      movies: ['流浪地球', '星际穿越', '独行月球']
    }
  }

  render() {
    // 1.插入标识符
    const { message, names, counter } = this.state
    const { aaa, bbb, ccc } = this.state
    const { friend } = this.state

    // 2.对内容进行运算后显示(插入表达式)
    const { firstName, lastName } = this.state
    const fullName = firstName + ' ' + lastName
    const { age } = this.state
    const ageText = age >= 18 ? '成年人' : '未成年人'
    const liEls = this.state.movies.map(movie => <li>{movie}</li>)

    // 3.返回jsx的内容
    return (
      <div>
        {/* 1.Number/String/Array直接显示出来 */}
        <h2>{counter}</h2>
        <h2>{message}</h2>
        <h2>{names}</h2>

        {/* 2.undefined/null/Boolean */}
        <h2>{String(aaa)}</h2>
        <h2>{bbb + ''}</h2>
        <h2>{ccc.toString()}</h2>

        {/* 3.Object类型不能作为子元素进行显示*/}
        <h2>{friend.name}</h2>
        <h2>{Object.keys(friend)[0]}</h2>

        {/* 4.可以插入对应的表达式*/}
        <h2>{10 + 20}</h2>
        <h2>{firstName + ' ' + lastName}</h2>
        <h2>{fullName}</h2>

        {/* 5.可以插入三元运算符*/}
        <h2>{ageText}</h2>
        <h2>{age >= 18 ? '成年人' : '未成年人'}</h2>

        {/* 6.可以调用方法获取结果*/}
        <ul>{liEls}</ul>
        <ul>
          {this.state.movies.map(movie => (
            <li>{movie}</li>
          ))}
        </ul>
        <ul>{this.getMovieEls()}</ul>
      </div>
    )
  }

  getMovieEls() {
    const liEls = this.state.movies.map(movie => <li>{movie}</li>)
    return liEls
  }
}

const root = ReactDOM.createRoot(document.querySelector('#root'))
root.render(<App />)
```

JSX嵌入表达式

- 运算表达式
- 三元运算符
- 执行一个函数

### JSX 绑定属性

- 比如元素都会有 title 属性
- 比如 img 元素会有 src 属性
- 比如 a 元素会有 href 属性
- 比如元素可能需要绑定 class
- 比如原生使用内联样式 style

```jsx
class App extends React.Component {
  constructor() {
    super()
    this.state = {
      title: '哈哈哈',
      href: 'https://www.baidu.com',
      isActive: true,
      objStyle: { color: 'red', fontSize: '30px' }
    }
  }

  render() {
    const { title, imgURL, href, isActive, objStyle } = this.state

    // 需求: isActive: true -> active
    // 1.class绑定的写法一: 字符串的拼接
    const className = `abc cba ${isActive ? 'active' : ''}`
    // 2.class绑定的写法二: 将所有的class放到数组中
    const classList = ['abc', 'cba']
    if (isActive) classList.push('active')
    // 3.class绑定的写法三: 第三方库classnames -> npm install classnames

    return (
      <div>
        {/* 1.基本属性绑定 */}
        <h2 title={title}>我是h2元素</h2>
        <a href={href}>百度一下</a>

        {/* 2.绑定class属性: 最好使用className */}
        <h2 className={className}>哈哈哈哈</h2>
        <h2 className={classList.join(' ')}>哈哈哈哈</h2>

        {/* 3.绑定style属性: 绑定对象类型 */}
        <h2 style={{ color: 'red', fontSize: '30px' }}>呵呵呵呵</h2>
        <h2 style={objStyle}>呵呵呵呵</h2>
      </div>
    )
  }
}

// 2.创建root并且渲染App组件
const root = ReactDOM.createRoot(document.querySelector('#root'))
root.render(<App />)
```

如果原生 DOM 原生有一个监听事件，我们可以如何操作呢？

- 方式一：获取 DOM 原生，添加监听事件
- 方式二：在 HTML 原生中，直接绑定 onclick

在 React 中是如何操作呢？我们来实现一下 React 中的事件监听，这里主要有两点不同

- React 事件的命名采用小驼峰式（camelCase），而不是纯小写
- 我们需要通过 `{}` 传入一个事件处理函数，这个函数会在事件发生时被执行
