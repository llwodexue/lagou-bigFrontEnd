## setState 原理

什么时候是同步？什么时候是异步？

- 这里说的异步不是说异步代码实现，而是说 React 会收集变更，然后统一更新

在 React 中，如果是由 React 引起的事件处理，调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state

- 除此之外指的是，绕过 React 通过 addEventListener 直接添加的事件处理函数，还由通过 setTimeout/setInterval 产生的异步调用

在 React 18 之前，在 setTimeout、Promise.then、原生 DOM 事件 中更新，是同步操作。其余在生命周期或 React 合成事件中更新，是异步操作

在 React 18 之后，默认所有的操作都放到了批处理中

## JSX 原理

JSX 仅仅只是 `React.createElement(component, props, ...children)` 函数的语法糖

`React.createElement(component, props, ...children)`的第一个参数 component的类型是 string/ReactClass type

- string 类型 React会当做原生的DOM节点进行解析
- ReactClass type 类型 自定义组件

简而言之，babel在编译过程中会判断 JSX 组件的首字母，如果是小写，则当做原生的DOM标签解析，就编译成字符串。如果是大写，则认为是自定义组件，编译成对象

## diff 算法

如何从 O(n ^ 3) 变成 O(n)

1. 两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构
2. 同一层级的一组节点，它们可以通过唯一的 id 进行区分

## React 事件机制

- React 事件使用驼峰命名，而不是纯小写
- 通过 JSX，传递一个函数作为事件处理程序
- 在React中，你不能通过返回 false 的方式阻止默认行为，必须显式的使用  `preventDefault`
- 回调函数是直接调用的，如果不手动绑定 this，获取到的 this 为 undefined

## Fiber

js 是单线程的，如果当前在执行一个很耗时的任务，那么剩下的任务就要等当前任务执行完之后再执行。16.x 版本之前，React的更新过程是同步的，当 React 决定要更新 DOM 时，从 diff 到更新 DOM，一气呵成。这种就会有一个问题，更新的组件比较复杂并且多(层级深等)的时候，此时如果用户点击了页面某个按钮，可能会因为正在批量更新 DOM 还未进行完成，按钮无法响应的问题

fiber 架构第一个阶段是分片的，将一个任务成很多个小的任务去执行，每次只执行一个小的任务，然后去看一下有没有优先级更高的任务，如果有，则去执行优先级更好的任务，如果没有，接着再执行下一小段任务

为什么第二个阶段，更新渲染 DOM必须是同步的呢，这个也很好理解。你总不能渲染了一半的时候去干其他的事情吧

## mixin、HOC、render props、hooks

mixin 存在的几个问题：

- 相关依赖：mixin 有可能去依赖其他的 mixin，当我们修改其中一个的时候，可能会影响到其他的 mixin
- 命名冲突：不同的人在写的时候很有可能会有命名冲突，比如像 handleChange 等类似常见的名字
- 增加复杂性：当我们一个组件引入过多的 mixin 时，代码逻辑将会非常复杂，因为在不停的引入状态，和我们最初想的每个组件只做单一的功能背道而驰

HOC的优点为：

- 不会影响组件内部的状态

HOC的问题是：

- 需要在原组件上进行包裹和嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难
- HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突

## vue 和 React 区别

**相同点**

1. 都支持服务器端渲染
2. 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范
3. 数据驱动视图
4. 都有支持native的方案,React的React native,Vue的weex

**不同点**

1. React严格上只针对MVC的view层,Vue则是MVVM模式
2. virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制
3. 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;
4. 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的
5. state对象在react应用中不可变的,需要使用setState方法更新状态; 在vue中,state对象不是必须的,数据由data属性在vue对象中管理