## 模块联邦

### 概述

Module Federation 即为模块联邦，是 Webpack5 新增的一项功能，可以实现跨应用共享模块

![image-20230412090701190](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230412090701190.png)

```bash
products
   ├── package-lock.json
   ├── package.json
   ├── public
   │   └── index.html
   ├── src
   │   └── index.js
   └── webpack.config.js
```

### 应用初始化

1. 在入口 JavaScript 文件中加入产品列表

   ```js
   import faker from 'faker'
   
   let products = ''
   for (let i = 1; i <= 5; i++) {
   	products += `<div>${faker.commerce.productName()}</div>`
   }
   document.querySelector('#dev-products').innerHTML = products
   ```

2. 在入口 html 文件中加入盒子

   ```html
   <div id="dev-products"></div>
   ```

3. webpack 配置

   ```js
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   
   module.exports = {
     mode: 'development',
     devServer: {
       port: 8081
     },
     plugins: [
       new HtmlWebpackPlugin({
         template: './public/index.html'
       })
     ]
   }
   ```

4. 添加启动命令

   ```json
   {
     "scripts": {
       "start": "webpack serve"
     }
   }
   ```

### Module Federation

通过配置模块联邦实现在容器应用中加载产品类别微应用

1. 在产品列表微应用中将自身作为模块进行导出

   ```js
   // 导入模块联邦插件
   const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')
   
   module.exports = {
     plugins: [
       // 将 products 自身当做模块暴露出去
       new ModuleFederationPlugin({
         // 模块名称，具有唯一性，相当于 single-spa 中的组织名称
         name: 'products',
         // 模块文件名称，其他应用引入当前模块时需要加载的文件的名字
         filename: 'remoteEntry.js',
         // 当前模块具体导出的内容
         exposes: {
           './Index': './src/bootstrap.js'
         }
       })
     ]
   }
   ```

2. 在容器应用中导入产品列表微应用

   ```js
   // 导入模块联邦插件
   const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin")
   
   module.exports = {
     plugins: [
       new ModuleFederationPlugin({
         name: "container",
         // 配置导入模块映射
         remotes: {
           // 字符串 products 和被导入模块的 name 属性值对应
           // 属性 products 是映射别名，是在当前应用中导入该模块时使用的名字
           products: "products@http://localhost:8081/remoteEntry.js",
           cart: "cart@http://localhost:8082/remoteEntry.js"
         }
       })
     ]
   }
   ```

文件打包加载分析

1. Products 应用打包分析

   ![image-20230412142826011](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230412142826011.png)

2. Container 应用打包分析

   ![image-20230412143248790](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230412143248790.png)

3. 文件加载顺序分析

   ![image-20230412143817371](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230412143817371.png)

加载 Cart 微应用

```js
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin")

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "cart",
      filename: "remoteEntry.js",
      exposes: {
        "./Index": "./src/bootstrap"
      }
    })
  ]
}
```

### 共享模块

在 Products 和 Cart 中都需要 Faker，当 Container 加载了这两个模块后，Faker 被加载了两次

![image-20230412151803912](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230412151803912.png)

共享模块需要异步加载，在 Products 和 Cart 中需要添加 bootstrap.js

- Cart 中如果使用 4.1.0 版本的 faker，Products 中使用 5.2.0 版本的 faker

```js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      shared: {
        faker: {
          singleton: true
        }
      }
    })
  ]
}
```

在容器应用导入微应用后，应该有权限决定微应用的挂载位置，而不是微应用在代码运行时直接进行挂载。所以每个微应用都应该导出一个挂载方法供容器应用调用

```js
import faker from 'faker'
function mount(el) {
  let products = ''
  for (let i = 1; i <= 5; i++) {
    products += `<div>${faker.commerce.productName()}</div>`
  }
  el.innerHTML = products
}
if (process.env.NODE_ENV === 'development') {
  const el = document.querySelector('#dev-products')
  if (el) mount(el)
}
```

