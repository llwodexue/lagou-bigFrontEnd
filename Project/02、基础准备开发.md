## 微前端实现方式

### Iframe

postMessage， 实现页面之间的传参

**优势:**

- 技术成熟
- 支持页面嵌入
- 天然支持运行沙箱隔离，独立运行

**劣势:**

- 页面之间可以是不同的域名（需要对不同的域名进行鉴权处理，加大开发量与一些跨域问题的处理）
- 需要对应的设计一套应用通讯机制，如何监听，传参格式等内容
- 应用加载，渲染，缓存等体系的实现（交给浏览器处理，如何进行控制比较麻烦）

### web component

H5 的新技术，自定义标签，定义成组件，行为

优势:

- 支持自定义组件
- 支持 shadow dom，并通过关联进行控制
- 支持模板 template 和插槽 slot，引入自定义组件内容

劣势:

- 接入微前端需要重写当前项目
- 生态系统不完善，技术过新容易出现兼容性问题
- 整体架构设计复杂，组件与组件之间拆分过细时候，容易造成通讯和控制繁琐

### 自研框架

优势:

- 高度定制化，满足需要做兼容的一切场景
- 独立的通信机制与沙箱运行环境（Iframe 实现天然支持），可解决应用间相互影响的问题
- 支持不同技术栈子应用，可以无缝实现页面无刷新渲染

劣势:

- 技术实现难度较高（实现独立渲染）
- 需要设计一套定制的通信机制（通信规范）
- 首次加载会出现资源过大的情况

## 技术栈

vue2 子应用

- 实现新能源页面

vue3 子应用

- 首页
- 选车

react15 子应用

- 资讯
- 视频
- 视频详情

react16 子应用

- 新车
- 排行
- 登录

服务端接口

- Koa 实现

## 架构图

1. 主应用

   注册子应用。加载、渲染子应用

   路由匹配（activeWhen、rules 由框架判断）

   获取数据（公共依赖，通过数据做鉴权处理）

   通信（父子应用通信，子父应用通信）

2. 子应用功能

   渲染页面

   监听通信（主应用传递过来的数据，监听主应用传递来的数据进行更新）

3. 微前端框架

   子应用注册

   有开始内容（应用加载完成）

   路由更新判断

   匹配对应的子应用

   加载子应用的内容

   完成所有依赖项的执行

   将子应用渲染在固定的容器内

   公共事件的管理

   异常的捕获和报错

   全局的状态管理的内容

   沙箱的隔离

   通信机制

4. 服务端的功能

   提供数据服务

5. 发布平台

   主子应用的打包和发布

![image-20230420103624686](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230420103624686.png)

![image-20230420103747829](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230420103747829.png)