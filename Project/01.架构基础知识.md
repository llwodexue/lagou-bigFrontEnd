## 架构前世今生

初始：无架构，前端代码内嵌到后端应用中

后端 mvc 架构

- 将视图层、数据层、控制层做分离
- 缺点：重度依赖开发环境，代码混淆严重

前后端分离架构

- 将前端代码从后端环境中提炼出来（ajax 促进了前后端分离架构的发展）多页面架构
- 缺点：前端缺乏独立部署能力，整体流程依赖后端环境
- Nodejs 的广泛使用促进了前端技术的飞速发展，诞生了多元化前端开发方式，使得前端开发可以脱离整体后端环境

单页面架构

- 优点：切换页面无刷新浏览器，用户体验好。组件化开发方式，极大提升了代码复用率
- 缺点：不利于 SEO，首次渲染会出现较长时间的白屏

微前端新型架构

- 技术栈无关，可以使用 vue、react

- 主框架不限制接入应用的技术栈，微应用具备完全自主权

- 独立开发、独立部署

- 增量升级

- 微前端是一种非常好的实施 **渐进式重构** 的手段和策略

  需要把一部分页面重写，但不想失去无刷新过程

- 微应用仓库独立，前后端可独立开发，主框架自动完成同步更新

- 独立运行时，每一个子应用都可以独立运行

- 每个微应用之间状态隔离，运行时状态不共享

微前端劣势

- 接入难度较高
- 应用场景 - 移动端少、管理端多

## 软件设计原则与分层

### 软件设计原则

单一职责原则

- 永远不应该有多于一个原因来改变某个类
- 理解：对于一个类而言，应该仅有一个引起它变化的原因
- 应用：如果一个类拥有了两种职责，那就可以将这个类分成两个类

开放封闭原则

- 软件实体扩展应该是开放的, 但对于修改应该是封闭的
- 理解：对扩展开放，对修改封闭。**可以去扩展类,但不要去修改类**
- 应用：当需求有改动，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码

里氏替换原则

- Class 面向对象原则，函数式编程考虑不多
- 理解：父类一定能够被子类替换

最少知识原则

- 只与你最直接的对象交流
- 理解：低耦合，高内聚
- 应用：做系统设计时，尽量减少依赖关系

接口隔离原则

- 一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口
- 理解：不要对外暴露没有实际意义的接口。用户不应该依赖它不需要的接口
- 应用：当需要对外暴露接口时，如果是非必要对外提供，尽量删除

依赖倒置原则

- 高层模块不应该依赖于低层模块，他们应该依赖于抽象。**抽象不应该依赖于细节,细节应该依赖于抽象**
- 理解：应该面向接口编程，不应该面向实现类编程
- 并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程

以上六大原则的英文首字母拼在一起就是 SOLID(稳定的)，所以也称之为 SOLID 原则

### 补充设计原则

组合/聚合复用原则

- 当要扩展类的功能时，优先考虑使用组合，而不是继承
- 该原则在 23 种经典设计模式中频繁使用
- 如：代理模式，装饰模式，适配器模式等

无环依赖原则

- 当 A 模块依赖于 B 模块,B 模块依赖于 C 模块，C 模块依赖于 A 模块,此时将出现循环依赖
- 在设计中避免该问题，可通过引入中介者模式解决

共同封装原则

- 应该将易变的类放在同一个包里，将变化隔离出来
- 该原则是 "开放-封闭原则" 的延生

共同重用原则

- 如果重用了包中的一个类,那么也就相当于重用了包中的所有类,我们要尽可能减少包的大小

好莱坞原则

- Don’t call me, I’ll call you.
- "控制反转"(或称为"依赖注入")
- 不需要主动创建对象，而是由容器帮我们来创建并管理这些对象

不要重复你自己

- 不要让重复的代码到处都是，要让他们足够的重用，所以要尽可能的封装

保持它简单与傻瓜

- 保持系统界面简洁，功能实用，操作方便

高内聚低耦合

- 模块内部需要做到内聚度高，模块之间需要做到耦合度低

关注点分离

- 将一个复杂问题分离为多个简单的问题，然后逐个解决
- 难点：如何进行分离？分离的颗粒度，分离的原则

你不需要它

- 不要一开始就把系统设计得非常复杂，不要陷入 "过渡设计" 的深渊
- 让系统足够简单，而不失去扩展性

### 软件设计分层

系统级架构

- 设计前端首要条件：了解前端系统与其他系统之间的关系
- 关系包括：业务关系和协作机制
- 设计后端：只需要规定与后台数据传递的机制
- 包括：api 设计规则，访问授权的一个开发标准（OAuth）跳转 token 的验证，数据传递 cookie 等
- 前后端分离架构其实是如何实施技术决策，用户鉴权、API 接口管理和设计、API 文档管理、Mock 的使用、BFF（服务于前端的后端、nodejs），是否需要服务端渲染等

微前端

- 在一个系统内微前端是应用间的架构方案
- 在多个应用之间，微前端则是一种系统间等架构方案
- 微前端是将多个前端应用以某种形式结合在一起进行应用
- 旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员，团队的增多、变迁，从一个普通应用演变为一个巨石应用 (Frontend Monolith) 后，随之而来的应用不可维护的问题
  - 单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用周期形式
  - 多实例：通常基于 url 的变化来做子应用的切换，同一时刻可展示多个子应用
  - 通常使用 Web Components 方案做子应用封装，子应用更像是一个业务组件而不是应用

应用级架构

- 应用级别架构可以看作是系统级架构的细化
- 单个应用与其他外部应用的关系，微服务架构下多个应用的协作，数据交换等
  - 脚手架
  - 模式库
  - 设计系统

模块级别架构

- 在开始业务编码之前进行设计,称之为迭代

代码级架构

- 规范与原则
- 实操
  - 开发流程
  - 代码质量以及改善
  - 规范而非默契

### 稳定性与健壮性

当一个实际的系统处于一个平衡状态时候，如果受到外来作用影响时，系统经过一个过渡过程仍然能够回到原来的平衡状态，我们称这个系统就是稳定的，否则称系统不稳定

计算机软件在 **输入错误，磁盘故障，网络过载，或者有意攻击** 情况下，能否不死机，不崩溃，就是该软件健壮性的具体表现

- 一个软件可以从错误的输入推断出合理的输入
- 一个软件可以正确的运行在不同环境下
- 一个软件能够检测出自己内部设计或者编码错误,并得到正确的结果

架构质量的衡量

- 扩展性
- 维护性
- 可管理
- 高可用(故障修复，容灾，降级，熔断)

日常开放过程中的架构质量

- 理解难度
- 接入依赖的成本。提高**扩展性**和**维护性**

- 崩溃率和错误率的指标
- 开发效率,便于开发设计
- **错误上报**与**信息收集**功能

### 架构前期准备

架构师分类

- 系统架构师
- 应用架构师
- 业务架构师

系统架构师(技术追求)

- 从系统的维度，负责整体系统的架构设计
- 主要是基础服务和各个系统间协调，着眼全局
- 比如关注负载、可靠性、伸缩、扩展，整体项目切分，缓存应用等方面的基础架构设计

应用架构师(业务更好实现、数据更好交互、设计易于扩展，对业务系统的流转做架构设计)

- 应用程序维度，负责某个应用的技术架构，主要偏向于业务系统
- 关注理解业务，梳理模型，设计模式，接口，数据交换等方面

业务架构师

- 从业务流程的维度，关注某一个行业，业务领域分析，获取领域模型，最终获得系统的模型
- 也可以叫业务领域专家，行业专家，产品咨询师，资深顾问

**技术前期准备**

- 技术选型：技术氛围、发展规模、未来发展趋势、与当前团队的契合度、执行成本、
  维护成本与迁移成本、执行效率等方面内容的调研
- 充分调研每一项技术可能带来的利与弊
- 最大程度上预测架构设计中的缺陷,以防止问题的发生

**技术优化**

- 在架构发展过程中，可能会存在一些有悖于当前架构设计的实现，造成了架构发展阻塞，所以需要进行架构优化，使得架构设计的适应性更高

**架构优化**

- 代码集中一个文件,冗余,不易于查错, 将功能进行划分利用差错优化

- 架构不是一蹴而就，在业务发展过程中，架构也在不断演进

- 对架构设计进行实时调优，使得架构优化成为常态化

  通过不断的调整架构实现，改进初始架构中设计的不足，补足短板，是设计不足导致，易于维护与扩展

## 技术填补与崩溃预防

### 技术填补

技术填补-问题1

- 开发过程中因为时间紧迫导致的实现不合理
- 举例：查找 10000 以内的质数

```js
function findPrime(number) {
  const result = []
  for (let i = 0; i < number; i++) {
    let m = 0
    for (let j = 0; j < i; j++) {
      if (i % j === 0) {
        m = 1
        break
      }
    }
    if (m === 0) {
      result.push(i)
    }
  }
  return result
}

function prime(number) {
  const result = new Array(number).fill(1)
  const len = result.length
  for (let i = 2; i <= number; i++) {
    let m = 2
    let middle = m * i
    while (middle < len) {
      result[middle] = 0
      m++
      middle = m * i
    }
  }
  return result
    .map((item, index) => {
      if (item && index > 1) {
        return index
      }
    })
    .filter(item => item)
}
```

技术填补-问题2

- 暂时没有想到更好的实现方式而妥协的版本

- 刚开始使用 if…else 实现

  判断过多，体积过大，不好查找问题在哪，演变为责任链模式

```js
function judge(a) {
  if (a > 100) {
    return 100
  }
  if (a > 50) {
    return 50
  }
  if (a > 20) {
    return 20
  }
  if (a > 10) {
    return 10
  }
  return 0
}

function is100(a) {
  if (a > 100) {
    return 100
  }
  return is50(a)
}
function is50(a) {
  if (a > 50) {
    return 50
  }
  return is20(a)
}
function is20(a) {
  if (a > 20) {
    return 20
  }
  return is10(a)
}
function is10(a) {
  if (a > 10) {
    return 10
  }
  return 0
}
```

技术填补-问题3

- 架构设计前期没有考虑到的细节
- 交互细节 -> props 传递参数(交互冗余,流程较长)
- 使用全局状态管理方式实现参数传递

技术填补-问题4

- 不合理的交互设计，导致技术实现复杂
- 交互难度，与设计人员沟通

技术填补-问题5

- 旧功能文档缺失，无正确扩展，修改与兼容旧功能，导致上线后问题剧增.
- 所有设计都是面向功能开发，并没有预留扩展与接口，这样在做新功能时候，需要兼容旧功能的功能，为之前的旧功能提供兼容版本，兼容版本与当前版本可能相背，并不能按照之前的架构设计，进行设计，而要兼容旧功能



技术填补-后果1

- 修复变重构
- 小的技术债务不做偿还，最后会演变成一场大规模的重构工作，导致产出不高

技术填补-后果2

- 影响开发速度
- 旧功能可能会影响新功能开发
- 技术债务的存在会导致整体开发需要兼容的点过多，影响开发效率，极大影响上线速度，导致整体项目迭代缓慢，失去核心竞争力

技术填补-后果3

- 容易陷入 维护旧功能---->开发新功能---->兼容旧功能---->维护旧功能---->开发新功能 …这样的恶性循环
- 直到旧功能维护时间过长



技术填补—解决方案1

- 优秀的架构设计是基础
- 必须能够有效处理当前需求可预见的情况，对于未知的，可能出现的特殊情况，很小的改动就能解决问题

技术填补—解决方案2

- 根据当前业务，进行合理的项目拆分，尽量的代码解耦合
- 必须有**日志模块，操作日志，错误日志，业务日志等等.**

技术填补—解决方案3

- 良好的技术培训与传帮带能力
- 技术能力妥协方案，注意的点与开发
- 让每一位开发者能够从更深一层次理解自己所需要实现的功能，对业务的理解
- 从最开始的代码规范，到熟悉业务，最后再到编写文档，从根源上解决

技术填补—解决方案4

- 充分的技术方案可以避免一部分技术债务的产生
- 技术方案是充分理解需求之后所能产生的对需求理想的实现方式，必要性不言而喻
- 不同工程师之前可以相互 review
- CodeReview 是非常重要的，同事也是对自身的一个提高，需要看下别人的代码是如何实现的
- 学习别人优秀的点能否被自己借鉴，如果有的化，可以运用到自己的开发过程中

技术填补—解决方案5

- 提升对于修复技术债务重要性的认知
- 工程师如果能够预见一个债务可能导致的问题，自然愿意花时间去处理。避免出现测试与一些问题

技术填补—解决方案6

- 善于发现和定期处理一些技术债务



### 崩溃预防

预防架构崩溃

- 根据日志，用户行为抓取 -> 争取在最新时间获取到用户操作链条
- 解决存量问题 -> 技术债务
- 遏制新增 -> 减少新增问题的概率。codeReciew、单元测试
- 对脏数据进行兜底和检验
- 单元测试
- 崩溃报警
- 自动化测试
- 更广的灰度触达
- 性能优化体系

## 系统重构

架构不是永恒不变的。架构也是具有生命周期的，也会经历 **初生、发展、巅峰、衰弱、消亡** 的过程

- **运用大量微小且保持软件行为的步骤，一步步达成大规模的修改** (小部分修改)
- **快刀斩乱麻**

早期系统优势:

1. 开发速度快
2. 快速迭代，代码复杂度低，组织度低
3. 代码规范都保持完好
4. 严格注重开发规范，不会允许危及架构设计的代码产生
5. 以上因素导致添加功能难点低，成本低

晚期系统:

早期系统的优势在这里都将转换为晚期系统的劣势

1. 具备所有早期系统的劣势
2. 代码复杂度高
3. 修改时候不易，代码规范不完善，对代码规范越界不完善
4. 很多需求或功能，出现，逾越当前架构设计的情况(不可避免这种了)
5. 添加新功能兼顾较多，涉及较多模块，牵一发而动全身
   