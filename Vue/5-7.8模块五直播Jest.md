## 自动化测试背景

**应用中有各种各样的 bug**

- 安全
- 逻辑
- 性能
- 展示

**减少 bug 的方式**

- code review
- 测试人员
- 灰度发布

**编码层面提高代码质量，减少 bug 数量**

- TypeScript
- Flow
- EsLint
- StyleLint

**测试分类**

- **单元测试**：颗粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合"设计"，是对软件中的最小可测试单元进行检查和验证
- **集成测试**：介于单元测试和系统测试之间，一般有开发小组采用白盒+黑盒方法来测试，即验证"设计"又验证"需求"。主要用来测试模块与模块之间的接口，同时还要测试一些主要的业务功能
- 回归测试
- 性能测试
- 系统测试：颗粒度最大，一般由独立的测试小组采用黑盒的方式来测试，主要测试系统是否符合"需求规格说明书"。在经过以上各阶段测试确认后，把系统完整的模拟客户环境进行测试
- 白盒测试：主要应用于单元测试阶段，主要对代码级别的测试，针对程序内部的逻辑结构。测试的手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖和条件组合覆盖
- 黑盒测试：不考虑程序内部结构和逻辑结构，主要是测试系统的功能是否满足"需求规格说明书"。一般会有一个输入值和一个输出值，和期望值做比较。黑盒测试也被称为功能测试或数据驱动测试，它是通过测试来检测每个功能是否都能正常使用
- **端到端测试（e2e）**
- 组件测试
- 压力测试

## Jest

> [https://jestjs.io/zh-Hans/](https://jestjs.io/zh-Hans/)

### 安装使用

```bash
$ npm i jest
```

初始化 jest 配置文件

```bash
$ npx jest --init
```

![image-20221102141742540](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221102141742540.png)

安装 babel

```bash
$ npm i babel-jest @babel/core @babel/preset-env
```

配置 `babel.config.js`

```json
module.exports = {
  presets: [['@babel/preset-env', { targets: { node: 'current' } }]]
}
```

`math.js`

```js
export function sum(x, y) {
  return x + y
}
export function subtract(x, y) {
  return x - y
}
```

`math.test.js`

```js
import { sum, subtract } from './math'

test('测试 sum', () => {
  expect(sum(1, 2)).toBe(3)
})
test('测试 subtract', () => {
  expect(subtract(2, 1)).toBe(1)
})
```

配置 `package.json`

```json
{
  "scripts": {
    "test": "jest"
  },
}

```

之后 `npm run test` 运行即可进行测试

### 匹配器

常用匹配器

- `toBe` 使用 `Object.is` 来进行精准匹配的测试（检测的是引用）
- `toRqual` 会递归检查对象或数组的每个字段

真值

- `toBeNull` 只匹配 `null`
- `toBeUndefined` 只匹配 `undefined`
- `toBeDefined` 与 `toBeUndefined` 相反
- `toBeTruthy` 匹配任何 `if` 语句为真
- `toBeFalsy` 匹配任何 `if` 语句为假

数字

- `toBeGreaterThan` 大于
- `toBeGreaterThanOrEqual` 大于等于
- `toBeLessThan` 小于
- `toBeLessThanOrEqual` 小于等于
- `toBeCloseTo` 比较浮点数相等，使用 `toBeCloseTo` 而不是 `toEqual`

字符串

- `toMatch` 检测正则表达式的字符串

数组和可迭代对象

- `toContain` 检查一个数组或可迭代对象是否包含某个特定项

错误

- `toThrow` 测试某函数在调用时是否抛出了错误

### 测试异步代码

```js
import axios from 'axios'

export function getPosts(callback) {
  return axios.get('https://jsonplaceholder.typicode.com/posts').then(res => {
    callback(res.data)
  })
}

export function getPosts2() {
  return axios.get('https://jsonplaceholder.typicode.com/posts').then(res => {
    return res.data.length
  })
}
```

`.resolves` / `.reject`

```js
import { getPosts, getPosts2 } from './async'

test('posts length is 100', () => {
  return getPosts(posts => {
    expect(posts.length).toBe(100)
  })
})

test('posts promise1', () => {
  return expect(getPosts2()).resolves.toBe(100)
})

test('posts promise2', async () => {
  const count = await getPosts2()
  expect(count).toBe(100)
})
```

### 钩子函数

如果有多次测试重复设置的工作，可以使用 `beforeEach` 和 `afterEach`

某些情况下，你只需要在文件的开头做一次设置，Jest 提供 `beforeAll` 和 `afterAll` 处理这种情况

```js
import { Counter } from './count'

let counter = null
beforeEach(() => {
  console.log('beforeEach')
  counter = new Counter()
})
afterEach(() => {
  console.log('afterEach')
})
// 所有测试用例执行之前执行
beforeAll(() => {
  console.log('beforeAll')
})
// 所有测试用例执行之后执行
afterAll(() => {
  console.log('afterAll')
})

test('Counter increment', () => {
  // const counter = new Counter()
  counter.increment()
  expect(counter.count).toBe(1)
})

test('Counter decrement', () => {
  // const counter = new Counter()
  counter.decrement()
  expect(counter.count).toBe(-1)
})
```

可以通过 `describe` 块来将测试分组，当 `beforeEach` 的块在 `describe` 内部时，其只适用 `describe` 块内的测试

```js
describe('Counter group1', () => {
  test('Counter increment', () => {
    counter.increment()
    expect(counter.count).toBe(1)
  })

  test('Counter decrement', () => {
    counter.decrement()
    expect(counter.count).toBe(-1)
  })
})

describe('Counter group2', () => {
  // 当前组里面的每个测试用例执行之前都来调用
  beforeEach(() => {
    console.log('group beforeEach')
  })
  test('Counter incrementTwo', () => {
    counter.incrementTwo()
    expect(counter.count).toBe(2)
  })

  test('Counter decrementTwo', () => {
    counter.decrementTwo()
    expect(counter.count).toBe(-2)
  })
})
```

## TodoMVC

> [https://todomvc.com/](https://todomvc.com/)

初始化 vue 项目，当执行 `test:unit` 时，会去 `test` 目录找所有以 `.spec.js` 结尾的文件进行测试

![image-20221103110928953](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20221103110928953.png)

测试分类

- 单元测试：检查给定函数、类或组合函数的输入是否产生预期的输出或副作用
- 组件测试：检查你的组件是否正常挂载和渲染、是否可以与之互动，已经表现是否符合预期（需要考虑各种边界情况）
- 端到端测试：检查跨多个页面的功能，并且对生产构建的 Vue 应用进行实际的网络请求

工具库

> [vue/test-utils](https://v1.test-utils.vuejs.org/zh/)
>
> [Vue测试指南](https://lmiller1990.github.io/vue-testing-handbook/zh-CN/)

- [`@testing-library/vue`](https://github.com/testing-library/vue-testing-library) 是一个 Vue 的测试库，专注于测试组件而不依赖其他实现细节。因其良好的设计使得代码重构也变得非常容易。它的指导原则是，测试代码越接近软件的使用方式，它们就越值得信赖。
- [`@vue/test-utils`](https://github.com/vuejs/test-utils) 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API

**API**

- `mount()`：创建一个包含被挂载和渲染的 Vue 组件的 wrapper

  深渲染，包括所有子组件都会渲染

- `shallowMount`：和 [`mount`](https://v1.test-utils.vuejs.org/zh/api/mount.html) 一样，创建一个包含被挂载和渲染的 Vue 组件的 [`Wrapper`](https://v1.test-utils.vuejs.org/zh/api/wrapper/)，不同的是被存根的子组件

  浅渲染，子渲染表层组件，不包括子组件

`toDoApp.spec.js`

```js
import toDoApp from '@/components/toDoApp'
import { shallowMount } from '@vue/test-utils'
import Vue from 'vue'

describe('TodoApp.vue', () => {
  /** @type {import('@vue/test-utils').Wrapper} */
  let wrapper = null
  // 运行每个测试之前执行 beforEach 这个钩子函数
  beforeEach(async () => {
    wrapper = shallowMount(toDoApp)
    wrapper.vm.todos = [
      { id: 1, text: 'eat', done: false },
      { id: 2, text: 'sleep', done: true },
      { id: 3, text: 'play', done: false }
    ]
    // 确保视图更新只会再进行后续的内容测试
    await Vue.nextTick()
  })
  it('任务列表展示正常', () => {
    const todoItems = wrapper.findAll('[data-testid="todo-item"]')
    expect(todoItems.length).toBe(3)
  })
})
```

`toDoHeader.spec.js`

```js
import toDoHeader from '@/components/toDoHeader'
import { shallowMount } from '@vue/test-utils'

describe('toDoHeader', () => {
  test('标题内容是 todos', () => {
    const wrapper = shallowMount(toDoHeader)
    const title = wrapper.find('[data-testid="header-title"]')
    expect(title.text()).toBe('todos')
  })

  test('添加任务 输入有效数据发布 new-todo 事件', async () => {
    const wrapper = shallowMount(toDoHeader)
    const newTodoInput = wrapper.find('[data-testid="todo-input"]')

    // 输入有效数据，发布 new-todo 事件
    const text = 'hello'
    newTodoInput.setValue(text)
    // 触发回车时间
    await newTodoInput.trigger('keyup.enter')
    // 断言
    expect(wrapper.emitted()['new-todo']).toBeTruthy() // 对外发布了 new-todo 事件
    expect(wrapper.emitted()['new-todo'][0][0]).toBe(text) // new-todo 事件参数必须是 hello
    expect(newTodoInput.element.value).toBe('')
  })

  test('添加任务 输入无效数据不发布 new-todo 事件', async () => {
    const wrapper = shallowMount(toDoHeader)
    const newTodoInput = wrapper.find('[data-testid="todo-input"]')

    // 输入无效数据，不会往外发射 new-todo 事件
    newTodoInput.setValue('')
    // 触发回车时间
    await newTodoInput.trigger('keyup.enter')
    // 断言
    expect(wrapper.emitted()['new-todo']).toBeFalsy()
  })
})
```

`toDoItem.spec.js`

```js
import todoItem from '@/components/todoItem'
import { shallowMount } from '@vue/test-utils'
import Vue from 'vue'

describe('测试每一个 item', () => {
  /** @type {import('@vue/test-utils').Wrapper} */
  let wrapper = null
  // 运行每个测试之前执行 beforEach 这个钩子函数
  beforeEach(async () => {
    wrapper = shallowMount(todoItem, {
      propsData: {
        todo: {
          id: 1,
          text: 'eat',
          done: false
        }
      }
    })
    // 确保视图更新只会再进行后续的内容测试
    await Vue.nextTick()
  })

  test('任务标题展示正常', () => {
    const label = wrapper.find('[data-testid="todo-text"]')
    expect(label.text()).toBe('eat')
  })

  test('任务标题展示正常', () => {
    const done = wrapper.find('[data-testid="todo-done"]')
    expect(done.element.checked).toBeFalsy()
  })

  // 结合 babel，可以实现 data-testid 批量删除
  // 但是不建议，e2e 就是真实的 html 页面，它也要去获取元素
})
```

