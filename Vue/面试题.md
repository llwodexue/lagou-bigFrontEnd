## diff 算法理解

- diff 算法是虚拟 dom 技术的必然产物：通过新旧虚拟 dom 做对比（diff），将变化的地方更新在真实 DOM 上；另外，也需要 diff 高效的执行对比过程，从而降低时间复杂度为 O(n)
- vue2.x 中为了降低 watcher 粒度，每个组件只有一个 watcher 与之对应，只有引入 diff 才能精确找到发生变化的地方
- vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch
- diff 过程遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做 4 次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点，借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效



## vue 优化

### diff 算法

vue2 才用了 **双端 diff 算法**，核心方法是 **updateChildren**，通过 **新前与旧前、新后与旧后、新后与旧前、新前与旧后、暴力对比** 5 种查找

- 新前与旧前对比，如果相同，老开始下标往后移动一格。如果不相同会进入新后与旧后对比
- 新后与旧后对比，如果相同，新、老结束下标往前移动一格。如果不相同会进入新后与旧后对比
- 新后与旧前对比，如果相同，老开始节点移动到老结束节点后面，老开始下标往后移动一格，新的结束下标往前移动一格。如果不相同会进入新前与旧后对比
- 新前与旧后对比，如果相同，老结束节点移动到老开始节点前面，新开始下标往后移动一格，老结束下标往前移动一格。如果不相同会进入暴力比对（乱序）
- 暴力比对，首先我们需要循环 oldChildren 生成一个 key 和 index 的映射表 `{ 'a': 0, 'b': 1 }`，然后我们用新的开始节点的 key 去映射表中查找，如果找到就把该节点移动到最前面，原来的位置用 undefined 占位，避免数组塌陷，防止老节点移动走了之后破坏了初始映射表位置，如果没有找到直接把新节点插入
  - 如果新节点有剩余，newChildren 还有剩余的节点还没有处理，我们需要循环这些节点，逐个插入
  - 如果老节点有剩余，oldChildren 还有剩余的节点还没有处理，我们需循环这些节点，逐个删除

vue2 虚拟 dom 是进行全量的对比，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变化时，会遍历判断虚拟 DOM 所有节点有没有发生变化。vue3 在 diff 算法中相比 vue2 增加了静态标记，在模板编译时，编译器会在动态标签上加上 patchFlag

### v-if 和 v-show

- v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是**惰性的**；如果在初始化渲染时条件为假，则什么也不做，一直到条件第一次变为真时，才会开始渲染条件块
- v-show 就简单得多，不管初始条件是什么，元素总会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景，v-sho 则适用于非常频繁切换条件的场景

### 多使用计算属性

- computed 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值才会重新计算 computed 的值

当我们需要进行数值计算，并且依赖于其它数据时

1. 使用方式
   - 方法需要调用，可以传参
   - 计算属性不能调用，不可传参
2. 缓存
   - 方法没有缓存
   - 计算属性默认会有缓存计算结果

计算属性就是可以写逻辑的 data，还可以结合 v-model 使用，需要实现 getter 和 setter 方法

### v-for 遍历同时使用 v-if

vue2 v-for 优先级其实是比 v-if 高，所以两个指令出现在一个 DOM 中，那么 v-for 渲染的当前列表，每一次都需要进行 v-if 的判断。而相应的列表也会重新变化，这个看起来是非常不合理的。因此当你需要进行同步指令的时候，进行使用计算属性，先将 v-if 不需要的值先过滤掉

```vue
<template>
  <ul>
    <li v-for="item in filterList" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
</template>
<script>
export default {
  computed: {
    filterList() {
      return this.showData.filter(data => data.isShow)
    }
  }
}
</script>
```

### v-for key

在列表数据进行遍历渲染时，需要为每一项 item 设置唯一值 key 值，方便 Vue.js 内部机制精准找到该列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff

并且 v-for 并不推荐使用 index 下标作为 key 的值，这个是一个非常好理解的知识点。当 index 作为标识的时候，插入一条数据的时候，列表中它后面的 key 都发生了变化，那么 v-for都会对 key 变化的 Element 重新渲染，但是其实它们除了插入的 Element 数据都没有发生改变，这就导致了没有必要的开销。所以，尽量不要用 index 作为标识，而去采用数据中的唯一值，如 id 字段

### 长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有时候我们封装的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？

- 可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了

**优化无限列表性能**

项目当中，会设计到非常多的长列表场景，区别于普通的分页来说，大部分想的多一点的就是做一个分页，滚动到底部的时候我们就继续请求 API。随着数据的加载，DOM 会越来越多，这样就导致了性能开销问题，当页面上 DOM 太多的时候，难免给我们的客户端造成一定的压力，所以对于长列表渲染的时候，建议将 DOM 移除掉，类似于图片懒加载的模式，只有出现在视图上的 DOM 才是重要的 DOM。网络上有一些好的解决方案，比如：vue-virtual-scroller、ve-virtual-scroll-list

- 可以采用分页方式获取，渲染大量数据
- vue-virtual-scroller 滚动方案，只渲染视口范围内的数据
- 如果不需要更新，使用 v-once 只渲染一次
- v-memo 可以缓存结果，结合 v-for 使用，避免数据变化时不必要的 vnode 创建
- 采用懒加载方式，在用户需要的时候再加载数据

IntersectionObserver 接口 (从属于 Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗 (viewport) 交叉状态的方法。祖先元素与视窗 (viewport) 被称为根 (root)

### 图片资源优化

在网页中，往往存在大量的图片资源，这些资源或大或小。当我们页面中的 DOM 中存在大量的图片时，难免不会碰到一些家长缓慢的问题，甚至加载失败的问题

- 小图标使用 svg 或者字体图标，或者制作雪碧图
- 通过 base64 和 webp 的方式加载小型图片
- 能通过 cdn 加速的大图尽量使用 cdn
- 对图片资源进行懒加载
- 压缩图片大小
  - 如果是纯静态图片，建议使用统一的工具进行压缩 tinypng
  - 注意：不建议用 webpack 构建压缩图片，会严重影响打包时间
  - 如果是动态图片，比如用户创建的文章中的图片，建议由后端来压缩

### 路由懒加载

vue 是单页面应用，可能会有很多的路由引入，这样使用 webpack 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验，如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问时候才加载对应的组件，这样就更高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来

- 注意：懒加载的路由太多的话会导致打包性能下降。路由懒加载就是异步组件，异步组件不宜太多，否则会有打包性能问题

```js
// require 语法
component: resolve => (require(['@/components/HelloWorld'], resolve))

// import 语法
component: () => import('@/components/HelloWorld')
```

### 首屏渲染优化

- 预渲染，没什么动态数据的页面直接预渲染成静态页面
- 路由懒加载
- 在首页加入 loading 动画，骨架屏
- 权限方案：服务端渲染，如果仅仅是因为首屏渲染慢，其实也不建议引入服务端渲染方案，因为成本还是比较高的，除非你要解决 SEO，这时你就不得不上服务端渲染了



## 组件化理解

- 组件是独立和可复用的代码组织单元，组件系统是 Vue 核心特性，它使开发者使用小型、独立和通常可复用的逻辑构建大型应用
- 组件化开发能大幅提高应用开发效率、测试性、复用性等
- 组件使用按分类有：页面组件、业务组件、通用组件
- vue 组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成器构造函数，它们基于 VueComponent，扩展于 Vue



## React 与 Vue 对比

### Hooks 与 Composition API 区别

都是解决代码组织性问题

- React 用 class 或 Vue 用 Options API，逻辑是混在一起的，共享一个 data，很难对代码进行一个拆分
- 继承方面，React 用 class 或 Vue 用 extend，同样放在 this 上面会有命名冲突、污染问头需要考虑
- React Hooks 或 Vue Composition API 可以让代码按照功能进行区分，做一个纯函数的调用

区别

- 比如做 reactive 的 state，React useState 把值和更新的方法做了区分，值是一个字面量，每一次执行 Hook 都会得到一个新的值。Vue 把 get 和 set 合到一起，形成一个 ref
- Vue 的 setup 函数只执行一次，根据数据变化执行 computed 或 watch。React Hooks 底层基于链表实现，每次组件被 render 会按顺序执行所有的 hooks

![image-20230426180407661](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230426180407661.png)



### 虚拟 DOM 区别

- vue3.0 通过 Proxy 响应式 + 组件内部 dom + 静态标记，把任务颗粒度控制的足够细致

  - 事件缓存：将事件缓存（静态）
  - 添加静态标记：vue2 是全量 diff，vue3 是静态标记 + 非全量 diff
  - 静态提升：创建静态节点时保存，后续直接复用
  - 使用最长递增子序列优化对比流程

  block Tree，其实就是把哪些 DOM 结构可能发生改变的地方作为一个动态节点进行收集。

- React 通过把 vdom 微观变成了链表，利用浏览器空闲时间来做 diff，如果超过 16ms 或有动画用户交互任务，就把主进程还给浏览器，等空闲了继续



### diff 算法区别

> [深入浅出虚拟 DOM 和 Diff 算法，及 Vue2 与 Vue3 中的区别](https://juejin.cn/post/7010594233253888013#heading-6)

diff 算法优化

1. 只比较同一层级，不跨级比较
2. 比较标签名
3. 比较 key

vue2 diff 算法采用的是 双端比较算法。updateChildren 会进行

- 头和头比较
- 尾和尾比较
- 头和尾比较
- 尾和头比较
- 都没有命中的对比

vue3 diff 算法采用的是 去头尾的最长递增子序列算法。patchKeyedChildren 会进行

- 头和头比较
- 尾和尾比较
- 基于最长递增子序列进行移动/添加/删除





### 核心开发思想区别

- 核心开发思想
  - vue 双向数据绑定
  
    vue 在编译期做了很多优化
  
  - react 单向数据绑定
  
    react 编译只用了 babel 做了个简单的 jsx 编译。始终走的是运行时进行优化，react16.8 有很多黑科技，比如：任务调度（有高优先级、低优先级），定义 userBlock 优先级
  
- 模板使用

  - vue 使用 template
  - react 使用 jsx




## 导航守卫实现原理

为什么我需要在每个导航中提供 next 函数来进行到下一个守卫？



vue router 的守卫执行过程本质上就是执行一个异步队列，实现异步队列的方法有很多种：callback、promise、generator、async/await

runQueue 按照队列顺序自己执行，在必要的时候可以终止队列的执行

```js
function runQueue(queue, fn, cb) {
  const step = (index) => {
    if (index >= queue.length) {
      cb()
    } else {
      if (queue[index]) {
        fn(queue[index], () => {
          step(index + 1)
        })
      } else {
        step(index + 1)
      }
    }
  }
  step(0)
}
```

iterator 方法用于迭代我们的守卫钩子

```js
const iterator = (hook, next) => {
  try {
    // 这个地方的 hook 就相当于我们自己定义的路由守卫
    // NavigationGuard(to, from, next)
    hook(route, current, (to) => {
      next(to)
    })
  } catch (error) {
    console.log(error)
  }
}
```

## keep-alive 原理

keep-alive 组件的作用就是缓存已经创建过的 vnode

1. 判断当前组件是否要被缓存

   获取 keep-alive 包裹的第一个子组件对象及其组件名，根据设置的 include/exclude 进行条件匹配，决定是否缓存。如果不匹配，则直接返回组件实例

2. 命中缓存则直接获取，同时更新 key 的位置

   根据组件 id 和 tag 生成缓存 key，并在缓存对象中查找是否已缓存过该组件实例对象，如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置

3. 不命中缓存则设置进缓存，同时检查缓存的实例数量是否超过 max

   在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 的设置值，超过 max 的设置值，根据 LRU 置换策略删除最近最久未使用的实例（下标为 0 的那个 key）

4. 当前组件实例的 keepAlive 属性设置为 true，这个在缓存选中过程中会用到

keep-alive `abstract: true`：是一个抽象组件，它不会渲染一个 DOM 元素，也不会出现在父组件链中

LRU 缓存策略

使用一个链表保存缓存数据，根据历史记录访问记录来进行淘汰数据（如果数据最近被访问过，那么将来被访问的几率也更高）

1. 新数据插入到链表头部
2. 每当缓存命中（被访问），则将数据移到链表头部
3. 链表满时，将链表尾部的数据丢弃

```js
class LRUCache {
  constructor(max) {
    this.max = max
    this.cache = new Map()
    this.keys = new Set()
  }

  get(key) {
    if (this.cache.has(key)) {
      // 如果换成有这个键，就将它移到最后面
      this.keys.delete(key)
      this.keys.add(key)
      // 返回对应的缓存数据
      return this.cache.get(key)
    } else {
      return -1
    }
  }

  set(key, value) {
    if (this.cache.has(key)) {
      // 缓存中有这个键，就先给它移除
      this.keys.delete(key)
    } else {
      // 缓存没有这个键，判断缓存是否已满
      if (this.keys.size >= this.max) {
        // 缓存已满，取出最近最少使用的键
        const leastUsedKey = this.keys.values().next().value
        this.cache.delete(leastUsedKey)
        this.keys.delete(leastUsedKey)
      }
    }
    // 添加新的缓存策略
    this.cache.set(key, value)
    this.keys.add(key)
  }
}
```



## nextTick 原理

1. nextTick 接收一个回调函数时，传入的回调函数会在 callbacks 中存起来，根据一个标记状态 pending 来判断当前是否要执行 timerFunc()
2. timerFunc() 是根据当前环境判断使用哪种方式实现，按照 Promise.then 和 MutationObserver 以及 setImmediate 的优先级来判断，支持哪个就用哪个，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替
3. timerFunc() 函数中会执行 flushCalbacks 函数，flushCallbacks 函数作用就是对所有 callback 进行遍历，然后指向相应的回调函数

Promise > MutationObserver > setImmediate > setTimeout



## scoped 原理

当 style 标签有 scoped 属性时，它通过 postcss 对其进行如下转换

```html
<style scoped>
.example {
  color: red;
}
</style>
<template>
  <div class="example">hi</div>
</template>

<style>
.example[data-v-f3f3eg9] {
  color: red;
}
</style>
<template>
  <div class="example" data-v-f3f3eg9>hi</div>
</template>
```

1. 为组件实例生成一个唯一标识，给组件的每个标签对应的 DOM 元素添加一个标签属性，data-xxx

2. 给 style scoped 中的每个选择器的最后一个选择器添加一个属性选择器，原选择器 `[data-v-xxx]`，如：原选择器为 `.container #id div`，则更改后选择器为 `.container #id div[data-v-xxx]`

3. 对于同一个选择器，父子组件加 scoped　标签，样式互不影响

4. 对于同一个选择器，父子组件不加 scoped　标签，父组件优先级会高于子组件

   因为 vue 会先对子组件进行加载，子组件都加载完，父组件才会加载完，CSS 是层叠样式，父组件加载的样式在后面

样式穿透：>>>、/deep/、::v-deep

- scoped 后选择器最后默认会加上当前组件的一个标识，比如：`[data-v-xxx]`
- 用了样式穿透后，在 deep 之后的选择器就不会加上标识

## computed 原理

computed 本质是一个惰性求值的观察者 computed watcher，其内部通过 this.dirty 属性标记计算属性是否需要重新求值

- 当 computed 的依赖状态发生改变时，就会通知这个惰性 watcher，computed watcher 通过 this.dep.subs.length 判断有没有订阅者
- 有的话，会重新计算，然后对比新旧值，如果变化了，会重新渲染（Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染）
- 没有的话，仅仅把 this.dirty=true（当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，才会真正计算，即具备 lazy 特性）

watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调，当我们需要深度监听对象中的属性时，可以打开 depp: true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听

- computed 是一种被动数据计算方式，当它所依赖的数据发生变化时才会重新计算。它适用于需要根据其它属性计算得到的属性值，并且这些属性值没有直接绑定到 DOM 上
  - 根据列表长度计算出当前页码数
  - 根据用户评分计算出星级评分显示
  - 根据输入框内容进行搜索过滤
- watch 是一种主动的监听数据变化方式，当它监测的数据发生变化时就会执行回调函数
  - 监听表单输入框的值变化并校验它是否符合规则
  - 监听数据变化并及时保存到服务器端
  - 监听路由变化并根据路由参数展示不同的页面

Watcher 观察者对象，实例分为：render watcher、computed watcher、user watcher

1. computed watcher

   通过计算属性实现 Watcher，它会依赖被计算所使用到的所有 reactive 属性，当这些 reactive 属性，就会通知 computed watcher 去重新执行计算属性的方法，并缓存结果

2. user watcher

   在组件使用 $watch API 或 watch 选项定义的函数都会创建一个 user watcher，可以监听任何你指定的数据源，当数据源变化时，就会执行回调函数

3. render watcher

   用来监测组件中的 rendering 函数是否需要重新执行。当组件中的状态发生变化时，render watcher 就会通知组件重新渲染，更新视图。beforeUpdate、updated 

   
