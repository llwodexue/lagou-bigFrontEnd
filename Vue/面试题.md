## diff 算法理解

- diff 算法是虚拟 dom 技术的必然产物：通过新旧虚拟 dom 做对比（diff），将变化的地方更新在真实 DOM 上；另外，也需要 diff 高效的执行对比过程，从而降低时间复杂度为 O(n)
- vue2.x 中为了降低 watcher 粒度，每个组件只有一个 watcher 与之对应，只有引入 diff 才能精确找到发生变化的地方
- vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会上一次渲染结果 oldVnode 和新的渲染结果 newVnode，此过程称为 patch
- diff 过程遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做 4 次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点，借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效



## vue 优化

### v-if 和 v-show

- v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是**惰性的**；如果在初始化渲染时条件为假，则什么也不做，一直到条件第一次变为真时，才会开始渲染条件块
- v-show 就简单得多，不管初始条件是什么，元素总会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景，v-sho 则适用于非常频繁切换条件的场景

### 多使用计算属性

- computed 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值才会重新计算 computed 的值

当我们需要进行数值计算，并且依赖于其它数据时

1. 使用方式
   - 方法需要调用，可以传参
   - 计算属性不能调用，不可传参
2. 缓存
   - 方法没有缓存
   - 计算属性默认会有缓存计算结果

计算属性就是可以写逻辑的 data，还可以结合 v-model 使用，需要实现 getter 和 setter 方法

### v-for 遍历同时使用 v-if

vue2 v-for 优先级其实是比 v-if 高，所以两个指令出现在一个 DOM 中，那么 v-for 渲染的当前列表，每一次都需要进行 v-if 的判断。而相应的列表也会重新变化，这个看起来是非常不合理的。因此当你需要进行同步指令的时候，进行使用计算属性，先将 v-if 不需要的值先过滤掉

```vue
<template>
  <ul>
    <li v-for="item in filterList" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
</template>
<script>
export default {
  computed: {
    filterList() {
      return this.showData.filter(data => data.isShow)
    }
  }
}
</script>
```

### v-for key

在列表数据进行遍历渲染时，需要为每一项 item 设置唯一值 key 值，方便 Vue.js 内部机制精准找到该列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff

并且 v-for 并不推荐使用 index 下标作为 key 的值，这个是一个非常好理解的知识点。当 index 作为标识的时候，插入一条数据的时候，列表中它后面的 key 都发生了变化，那么 v-for都会对 key 变化的 Element 重新渲染，但是其实它们除了插入的 Element 数据都没有发生改变，这就导致了没有必要的开销。所以，尽量不要用 index 作为标识，而去采用数据中的唯一值，如 id 字段

### 长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有时候我们封装的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？

- 可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了

**优化无限列表性能**

项目当中，会设计到非常多的长列表场景，区别于普通的分页来说，大部分想的多一点的就是做一个分页，滚动到底部的时候我们就继续请求 API。随着数据的加载，DOM 会越来越多，这样就导致了性能开销问题，当页面上 DOM 太多的时候，难免给我们的客户端造成一定的压力，所以对于长列表渲染的时候，建议将 DOM 移除掉，类似于图片懒加载的模式，只有出现在视图上的 DOM 才是重要的 DOM。网络上有一些好的解决方案，比如：vue-virtual-scroller、ve-virtual-scroll-list

### 图片资源优化

在网页中，往往存在大量的图片资源，这些资源或大或小。当我们页面中的 DOM 中存在大量的图片时，难免不会碰到一些家长缓慢的问题，甚至加载失败的问题

- 小图标使用 svg 或者字体图标，或者制作雪碧图
- 通过 base64 和 webp 的方式加载小型图片
- 能通过 cdn 加速的大图尽量使用 cdn
- 对图片资源进行懒加载
- 压缩图片大小
  - 如果是纯静态图片，建议使用统一的工具进行压缩 tinypng
  - 注意：不建议用 webpack 构建压缩图片，会严重影响打包时间
  - 如果是动态图片，比如用户创建的文章中的图片，建议由后端来压缩

### 路由懒加载

vue 是单页面应用，可能会有很多的路由引入，这样使用 webpack 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验，如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问时候才加载对应的组件，这样就更高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来

- 注意：懒加载的路由太多的话会导致打包性能下降。路由懒加载就是异步组件，异步组件不宜太多，否则会有打包性能问题

```js
// require 语法
component: resolve => (require(['@/components/HelloWorld'], resolve))

// import 语法
component: () => import('@/components/HelloWorld')
```

### 首屏渲染优化

- 预渲染，没什么动态数据的页面直接预渲染成静态页面
- 路由懒加载
- 在首页加入 loading 动画，骨架屏
- 权限方案：服务端渲染，如果仅仅是因为首屏渲染慢，其实也不建议引入服务端渲染方案，因为成本还是比较高的，除非你要解决 SEO，这时你就不得不上服务端渲染了

## 组件化理解

- 组件是独立和可复用的代码组织单元，组件系统是 Vue 核心特性，它使开发者使用小型、独立和通常可复用的逻辑构建大型应用
- 组件化开发能大幅提高应用开发效率、测试性、复用性等
- 组件使用按分类有：页面组件、业务组件、通用组件
- vue 组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成器构造函数，它们基于 VueComponent，扩展于 Vue



## React 与 Vue 对比

### Hooks 与 Composition API 区别

都是解决代码组织性问题

- React 用 class 或 Vue 用 Options API，逻辑是混在一起的，共享一个 data，很难对代码进行一个拆分
- 继承方面，React 用 class 或 Vue 用 extend，同样放在 this 上面会有命名冲突、污染问头需要考虑
- React Hooks 或 Vue Composition API 可以让代码按照功能进行区分，做一个纯函数的调用

区别

- 比如做 reactive 的 state，React useState 把值和更新的方法做了区分，值是一个字面量，每一次执行 Hook 都会得到一个新的值。Vue 把 get 和 set 合到一起，形成一个 ref
- Vue 的 setup 函数只执行一次，根据数据变化执行 computed 或 watch。React Hooks 底层基于链表实现，每次组件被 render 会按顺序执行所有的 hooks

### 虚拟 DOM 区别

- vue3.0 通过 Proxy 响应式 + 组件内部 dom + 静态标记，把任务颗粒度控制的足够细致

  - 事件缓存：将事件缓存（静态）
  - 添加静态标记：vue2 是全量 diff，vue3 是静态标记 + 非全量 diff
  - 静态提升：创建静态节点时保存，后续直接复用
  - 使用最长递增子序列优化对比流程

  block Tree，其实就是把哪些 DOM 结构可能发生改变的地方作为一个动态节点进行收集。

- React 通过把 vdom 微观变成了链表，利用浏览器空闲时间来做 diff，如果超过 16ms 或有动画用户交互任务，就把主进程还给浏览器，等空闲了继续

### diff 算法区别

> [深入浅出虚拟 DOM 和 Diff 算法，及 Vue2 与 Vue3 中的区别](https://juejin.cn/post/7010594233253888013#heading-6)

diff 算法优化

1. 只比较同一层级，不跨级比较
2. 比较标签名
3. 比较 key

vue2 diff 算法采用的是 双端比较算法。updateChildren 会进行

- 头和头比较
- 尾和尾比较
- 头和尾比较
- 尾和头比较
- 都没有命中的对比

vue3 diff 算法采用的是 去头尾的最长递增子序列算法。patchKeyedChildren 会进行

- 头和头比较
- 尾和尾比较
- 基于最长递增子序列进行移动/添加/删除





### 核心开发思想区别

- 核心开发思想
  - vue 双向数据绑定
  
    vue 在编译期做了很多优化
  
  - react 单向数据绑定
  
    react 编译只用了 babel 做了个简单的 jsx 编译。始终走的是运行时进行优化，react16.8 有很多黑科技，比如：任务调度（有高优先级、低优先级），定义 userBlock 优先级
  
- 模板使用

  - vue 使用 template
  - react 使用 jsx


## 导航守卫实现原理

为什么我需要在每个导航中提供 next 函数来进行到下一个守卫？



vue router 的守卫执行过程本质上就是执行一个异步队列，实现异步队列的方法有很多种：callback、promise、generator、async/await

runQueue 按照队列顺序自己执行，在必要的时候可以终止队列的执行

```js
function runQueue(queue, fn, cb) {
  const step = (index) => {
    if (index >= queue.length) {
      cb()
    } else {
      if (queue[index]) {
        fn(queue[index], () => {
          step(index + 1)
        })
      } else {
        step(index + 1)
      }
    }
  }
  step(0)
}
```

iterator 方法用于迭代我们的守卫钩子

```js
const iterator = (hook, next) => {
  try {
    // 这个地方的 hook 就相当于我们自己定义的路由守卫
    // NavigationGuard(to, from, next)
    hook(route, current, (to) => {
      next(to)
    })
  } catch (error) {
    console.log(error)
  }
}
```

## keep-alive 原理

keep-alive 组件的作用就是缓存已经创建过的 vnode

1. 判断当前组件是否要被缓存

   获取 keep-alive 包裹的第一个子组件对象及其组件名，根据设置的 include/exclude 进行条件匹配，决定是否缓存。如果不匹配，则直接返回组件实例

2. 命中缓存则直接获取，同时更新 key 的位置

   根据组件 id 和 tag 生成缓存 key，并在缓存对象中查找是否已缓存过该组件实例对象，如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置

3. 不命中缓存则设置进缓存，同时检查缓存的实例数量是否超过 max

   在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 的设置值，超过 max 的设置值，根据 LRU 置换策略删除最近最久未使用的实例（下标为 0 的那个 key）

4. 当前组件实例的 keepAlive 属性设置为 true，这个在缓存选中过程中会用到

keep-alive `abstract: true`：是一个抽象组件，它不会渲染一个 DOM 元素，也不会出现在父组件链中

LRU 缓存策略

使用一个链表保存缓存数据，根据历史记录访问记录来进行淘汰数据（如果数据最近被访问过，那么将来被访问的几率也更高）

1. 新数据插入到链表头部
2. 每当缓存命中（被访问），则将数据移到链表头部
3. 链表满时，将链表尾部的数据丢弃



## nextTick 原理

1. nextTick 接收一个回调函数时，传入的回调函数会在 callbacks 中存起来，根据一个标记状态 pending 来判断当前是否要执行 timerFunc()
2. timerFunc() 是根据当前环境判断使用哪种方式实现，按照 Promise.then 和 MutationObserver 以及 setImmediate 的优先级来判断，支持哪个就用哪个，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替
3. timerFunc() 函数中会执行 flushCalbacks 函数，flushCallbacks 函数作用就是对所有 callback 进行遍历，然后指向相应的回调函数
