## 请简述 Vue 首次渲染过程

1. Vue 初始化，添加实例成员、静态成员，并在原型上挂载 `__patch__` 方法和 `$mount` 方法
2. 初始化结束，调用 `new Vue()`。在 `new Vue()` 的过程中，调用 `this.init()` 方法， 给 vue 的实例挂载各种功能
3. 在 `this.init()` 内部最终会调用 `entry-runtime-with-compiler.js` 中的 `vm.$mount()`，用于获取 render 函数
4. `$mount` 获取 render 过程: 如果用户没有传入 render，会将 template 编译为 render，如果 template 也没有，则将 el 中的内容作为模版，通过 `compileToFunctions()` 生成render
5. 接下来调用 `runtime/index.js` 中的 `$mount`， 重新获取 el 并调用 `mountComponent()` 方法
    `mountComponent` 用于触发 `beforeMount`，定义 `updateComponent`，创建 watcher 实例，触发 mounted，并最终返回 vm 实例
6. 创建完watcher的实例后会调用一次 `watcher.get()` 方法，该方法会调用 `updateComponent()`， `updateComponent()` 又会调用 `vm.render()` 以及 `vm.update()`， `vm._update()` 会调用 `vm.__patch__()` 挂载真实 dom，并将真实 dom 记录于 `vm.$el` 中

## 请简述 Vue 响应式原理

- 响应式处理整体过程为 `initState() => initData() => observe()`

- 其中 observe 是响应式处理的入口，通过该方法为 data 对象转化为响应式对象。

- observe 方法接收的是对象且该对象不是响应式时，会为该对象创建一个 observe 对象，会调用 Observer 类

- Observer 类中判断该 value 是数组还是对象，进行不同的处理
  - 数组的响应化处理，是重写 push，pop，sort 等会修改原数组的方法，调用对应的 `notify.` 然后遍历数组中的成员，判断其类型决定是否调用 observe 方法
  - 对象的响应化处理，会调用 walk 方法，遍历对象中的每个属性，调用 `defineReactive`
  
- `defineReactive` 的核心是为每一个属性定义 getter 和 setter，getter 中收集依赖，setter 中派发更新，即调用 `dep.notify`

- `dep.notify()` 会调用 watcher 的 `update()`方法。如果该 watcher 未被处理，会被添加到 queue 队列中，并调用 `flushSchedulerQueue()` 方法，该方法会触发对应的钩子函数以及调用 `watcher.run()` 更新视图

## 请简述虚拟 DOM 中 Key 的作用和好处

- 作用： 标识节点在当前层级的唯一性
- 好处： 在执行 updateChildren 对比新旧 Vnode 的子节点差异时，通过设置 key 可以进行更高效的比较，便于复用节点。 降低创建销毁节点成本，从而减少 dom 操作，提升更新 dom 的性能

## 请简述 Vue 中模版编译过程

- 模版编译入口函数是 `compileToFunctions`，首先判断是否有缓存好的 render 函数，如果没有，则调用 compile。compile 用作于合并options， 它将用户传入的 options 和初始化的 options 合并起来。然后将 template 和合并好的 options 传递给 `baseCompile`
- 在 `baseCompile` 中完成了模版编译的核心部分：
  - 调用 `parse()` 将template转换成 AST 对象；
  - 调用 `optimize()` 优化 AST tree；
  - 调用 `generate()` 将优化后的 AST tree 转换成字符串形式的代码。
- 最后回到 `compileToFunctions`，通过 `createFunction()` 将字符串形式的代码转换为函数，并将其挂载到 Vue 实例的 options 对应的属性中。