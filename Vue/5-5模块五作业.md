## Vue 3.0 性能提升主要是通过哪几方面体现的？

- 编译阶段优化
- 源码体积优化
- 数据劫持优化

编译阶段优化：

- diff 算法优化

  vue3 在 diff 算法中相比 vue2 增加了静态标记，已经标记静态节点的标签在 diff 过程中不会比较

- 静态提升 `hoistStatic`

  vue3 对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用

- 事件监听缓存 `cacheHandlers`

  在下次 diff 算法时可以在直接使用

- SSR 优化

  在静态内容打到一定量级，会用 createStaticVNode 方法在客户端去生成一个 static node，这些静态 node 会直接 innerHtml

源码体积优化:

- Tree-shaking，任何一个函数，比如：ref、reactive、computed，仅仅在用到的时候打包，没用到的模块都会被摇掉
- `Tree shaking`是基于`ES6`模板语法（`import`与`exports`），主要是借助`ES6`模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

数据劫持优化：

- vue2中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式

- vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历

  - 可以监听动态属性的添加

  - 可以监听到数组的索引和数组 length 属性

  - 可以监听删除属性

## Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

使用 Vue2 开发的项目，普遍会存在以下问题：

- 代码的可读性随着组件变大而变差
- 每一种代码复用的方式，都存在缺点
- TypeScript 支持有限

在 Vue2 中，我们是用过 mixin 去复用相同的逻辑

- 命名冲突
- 数据来源不清晰

优点：

- 在逻辑组织和逻辑复用方面，`Composition API`是优于`Options API`
- 因为`Composition API`几乎是函数，会有更好的类型推断
- `Composition API`对 `tree-shaking` 友好，代码也更容易压缩
- `Composition API`中见不到`this`的使用，减少了`this`指向不明的情况
- 如果是小型组件，可以继续使用`Options API`，也是十分友好的

## Proxy 相对于 Object.defineProperty 有哪些优点？

`Object.defineProperty`

- 检测不到对象属性的添加和删除
- 数组 API 方法无法监听到
- 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

`Proxy` 

- 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9

## Vue 3.0 在编译方面有哪些优化？



## Vue.js 3.0 响应式系统的实现原理？