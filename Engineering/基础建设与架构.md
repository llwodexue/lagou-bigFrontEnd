## 突破思维

### 前端之路

> [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)

面试造火箭，工作拧螺丝

- 我精通 Vue.js，看过 Vue.js 源码

  我能熟记Object.defineProperty/ Proxy，也知道发布订阅模式

- 我精通 AST

  我知道 AST 是抽象语法树，知道能用它做些什么

- 我熟练使用并了解 Babel

  我能记清楚很多 Babel 配置项，甚至默写出 Babel Plugin 模板代码

你知道 Vue.js 完整版和运行时版本的区别吗？

- 如果你不理解 Vue.runtime.js 运行时版本不包含模板编译器，就大概率无法说清 Vue 在模板编译环节具体做了什么。如果只知道几个 APIs 实现数据劫持和发布订阅模式，又何谈精通原理

请你手写一个“匹配有效括号”算法？

- 如果连 LeetCode 上 easy 难度的编译原理相关算法题都无法做出，那么何谈分词、AST 这些概念

如何设计一个 C 端 Polyfill 方案？

- 如果不清楚`@babel/preset-env`的`useBuiltIns`不同配置背后的设计理念，又何谈了解 Babel，更别说设计一个性能更好的降级方案

从 0 到 1 打造应用的基础建设、制定应用的工程化方案、实现应用的构建和发布流程、设计应用中公共方法和底层架构。系统性地研究这些知识，才能真正打通开发者“任督二脉”，实现个人和团队更大的价值

对于业务来说，在工程化基建当中：

- 团队并非一个人单打独斗，那么如何设计工作流程，如何打造一个众人皆赞的项目根基？
- 项目依赖纷繁复杂，如何做好依赖管理和公共库管理？
- 如何深入理解框架，真正做到框架的精通和技术选型的准确拿捏？
- 从最基本的网络请求库说起，如何设计一个稳定灵活的多端 Fetch 库？
- 如何借力 Low Code / No Code 技术，实现越来越智能的应用搭建方案？
- 如何统一中后台项目架构，实现跨业务线的产研效率提升？
- 如何开发设计一套适合业务的组件库，封装分层样式，最大限度做到复用，提升开发效率？
- 如何制定跨端方案，Write Once，Run Everywhere 是否真的可行？
- 如何处理各种模块化规范，以及精确做到代码拆分的最佳实践？
- 如何区分开发边界，比如前端如何更好地利用 Node.js 方案开疆扩土？

### 技术回顾

MVVM 和 MVC 最大的区别在于：MVVM 采用双向绑定（Data Binding）或自动渲染更新

- View 层的变动，可以自动反映在 ViewModel 层。Angular 和 Vue 都采用这种模式
- 虽然 React 官方声称自己只是一个 View 层类库，但是 React 搭配数据状态管理生态，也符合 MVVM 模式

![image-20230224161202315](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161202315.png)

> [Rendering on the Web](https://developers.google.com/web/updates/2019/02/rendering-on-the-web)

CSR 渲染架构图

![image-20230224161711485](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161711485.png)

- 实现了前后端架构分离，实现了前后端职责分离
- TTFB 时间最小，但由于客户端和服务端会有多次交互（获取静态资源、获取数据）才能进行渲染，实际首屏效果以及 FCP/FMP 时间不够理想

SSR 渲染架构图

![image-20230224161831332](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161831332.png)

我们可以将 SSR 和 CSR 相结合，即实现一个基于 hydration（注水） 的 SSR 和 CSR 结合方案

## 前端工程化管理工具

### npm

项目依赖出现问题你可能有出现问题：

- 删除 node_modules 和 lockfiles，再重新 install，这样操作是否存在风险？
- 把所有依赖都安装到 dependencies 中，不区分 devDependencies 会有问题吗？
- 我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗？
- 一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题？
- 我们是否应该提交 lockfiles 文件到项目仓库呢？

Ruby 的 Gem、Python 的 pip 都是全局安装，但是 npm 安装机制秉承着不同的设计哲学

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yF_axkqAclTFAAJmlxGYSmI551.png)

npm 缓存机制

- 对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计

  `npm config get cache `

- 当 npm install 执行时，通过 pacote 把相应的包解压在对应的 node_modules 下面。npm 下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下

  pacote 依赖 npm-registry-fetch 来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据 IETF RFC 7234 来生成缓存数据

- 在安装资源时，根据 `package-lock.json` 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录

  如果发现有缓存资源，找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过 pacote 把对应的二进制文件解压到响应的 node_modules 下面，省去了网络下载资源的开销

npm link

- 假如我开发一个组件库，某个组件开发完成之后，如何验证该组件能在我的业务项目中正常运行呢？

  除了写一个完备的测试以外，常见的思路就是**在组件库开发中，设计 examples 目录或者一个 playground，启动一个开发服务，以验证组件的运行情况**

- npm link 本质就是软链接，主要做了两件事

  - 为目标 npm 模块（npm-package 1）创建软链接，将其链接到全局 node 模块安装路径 /usr/local/lib/node_modules 中
  - 为目标 npm 模块（npm-package 1）的可执行 bin 文件创建软链接将其链接到全局 node 命令安装路径 /usr/local/bin 中

npx

- 可以直接执行 node_modules/.bin 文件夹下的文件
- 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在

npm 多源镜像和企业级部署私服原理

- 可是使用 preinstall 的钩子

  ```json
  {
    "script": {
      "preinstall": "node ./bin/preinstall.js"
    }
  }
  ```

  preinstall 脚本内容

  ```js
  require('child_process').exec('npm config get registry', function (error, stdout, stderr) { 
  	if (!stdout.toString().match(/registry\.x\.com/)) {
      exec('npm config set @xscope:registry https://xxx.com/npm/')
    }
  })
  ```

  **部署镜像后**，确保高速、稳定 npm 服务，使发布私有模块更加安全

  **审核机制**，保障私服上的 npm 模块质量和安全

- 如何部署一个私有 npm镜像

  nexus、verdaccio、cnpm

  nexus 工作在 client 和外部 npm 之间，并通过 group repository 合并 npm 仓库以及私有仓库，这样就起到了代理转发的作用

  ![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_Tba6AcJj0AAGPl9HW2qg745.png)
  
  > [聊聊 NPM 镜像那些险象环生的坑](https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ)

### yarn

- **确定性**：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的 [npm-shrinkwrap.json](https://docs.npmjs.com/cli/shrinkwrap)）
- 采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）
- 网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制
- 采用缓存机制，实现了离线模式（npm 目前也有类似实现）

`yarn cache dir`

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_ZflCANVu8AAJJZZYzwhs026.png)

检测包：

- 检测项目中是否存在一些 npm 相关文件，比如 package-lock.json

解析包：

- 首先获取当前项目中 package.json 定义的 dependencies、devDependencies 的内容，这属于首层依赖
- 接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_TbimACnDOAAFMC14gP8I289.png)

获取包

- 如何判断缓存中是否存在当前的依赖包

  yarn 会根据 cacheFolder + slug + node_modules + pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载

- 没有命中缓存的包，yarn 会维护一个 fetch 队列，按照规则进行网络请求

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1F_TbjKAThkOAAEsp0sOHUc622.png)

链接包

- 将项目中的依赖复制到项目 node_modules 下，遵循扁平化原则

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1F_Tbj2AWiPOAADyaZB-wGw502.png)

构建包：

- 依赖包中存在二进制包的进行编译

Yarn 在安装依赖时会自动执行 dedupe 命令。**整个优化的安装过程，就是上一讲提到的扁平化安装模式，也是需要你掌握的关键内容**

### CI

npm ci

- npm ci 要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json
- npm ci 完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖
- 正因为 npm ci 完全根据 package-lock.json 安装依赖，在安装过程中，它不需要计算求解依赖满足问题、构造依赖树，因此安装过程会更加迅速
- npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装
- npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包
- 如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles
- npm ci 永远不会改变 package.json 和 package-lock.json

一个 package-lock.json 的 dependency 主要由以下部分构成：

- version：依赖包的版本号
- resolved：依赖包安装源
- integrity：表明包完整性的 hash 值
- dev：该模块是否为顶级模块的开发依赖或者是一个传递依赖关系
- requires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项
- dependencies：依赖包 node_modules 中依赖的包

![image-20230227153124893](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230227153124893.png)

如果开发的库依赖了一个精确版本号的模块，那么提交 lockfiles 到仓库可能会造成同一个依赖不同版本都会被下载的情况

- 如果作为库开发者，真的有使用某个特定版本依赖的需要一个更好的定义方式是定义 peerDependencies

- 把 package-lock.json 一起提交到代码仓库中，不需要 ignore

  但是执行 npm publish 命令，发布一个库的时候，应该被忽略而不是直接发布出去

npm 设计的依赖类型声明：

- dependencies 项目依赖
- devDependencies 开发依赖
- peerDependencies 同版本依赖
- bundledDependencies 捆绑依赖
- optionalDependencies 可选依赖

peerDependencies

- 插件不能单独运行
- 插件正确运行的前提是核心依赖库必须下载安装
- 我们不希望核心依赖库重复下载
- 插件 API 的设计必须要符合核心依赖库的插件编写规范
- 在项目中，同一插件体系下，核心依赖库版本最好相同

SemVer 版本规范

### 构建工具

> [Tooling.Report](https://bundlers.tooling.report/)

![image-20230227162717413](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230227162717413.png)

- Code Splitting

  **代码分割**，能够导出公共模块，避免重复打包，以及在页面加载运行时，实现最合理的按需加载策略

  - 不同模块间的代码分割机制能否支持不同的上下文环境（Web worker 环境等特殊上下文情况）
  - 如何实现对 Dynamic Import 语法特性的支持
  - 应用配置多入口/单入口时是否支持重复模块的抽取并打包，代码模块间是否支持 Living Bindings

- Hashing

  对打包资源进行版本信息映射，构建工具进行打包的前提就是对各个模块依赖关系进行分析，并根据依赖关系，支持开发者自定义哈希策略

  - hash 如果项目里某个模块发生更改，触发项目的重新构建，那么文件的 hash 值将会相应地改变
  - chunkhash 会根据入口文件（Entry）进行依赖解析
  - contenthash 则会根据文件具体内容，生成 hash 值

- Importing Modules

  **依赖机制**。一个构建工具的设计当然也就要兼容不同类型的 modules importing 方案

- Non-JavaScript Resources

  对其他非 JavaScript 类型资源导入的支持能力

- Output Module Formats

  构建输出内容的模块化方式也需要更加灵活，比如开发者可配置 ESM、CommonJS 等规范的构建内容导出

- Transformations

  我们在设计构建工具时，对于类似 JSX 的编译、.vue 文件的编译，不会内置到构建工具当中，而是利用 Babel 等社区能力，“无缝融合”到构建流程里

### Vite

找到 Vite 源码中，命令行实现部分，这里根据不同的命令行命令，执行不同的入口函数

```js
if (!options.command || options.command === 'serve') {
  runServe(options)
} else if (options.command === 'build') {
  runBuild(options)
} else if (options.command === 'optimize') {
  runOptimize(options)
} else {
  console.error(chalk.red(`unknown command: ${options.command}`))
  process.exit(1)
}
```

Vite 通过 runServe 方法，启动了一个 koaServer，来实现对浏览器请求的响应

```js
const server = require('./server').createServer(options)
```

createServer 做了如下事情

```typescript
export function createServer(config: ServerConfig): Server {
  const {
    root = process.cwd(),
    configureServer = [],
    resolvers = [],
    alias = {},
    transforms = [],
    vueCustomBlockTransforms = {},
    optimizeDeps = {},
    enableEsbuild = true
  } = config
  // 创建 Koa 实例
  const app = new Koa<State, Context>()
  const server = resolveServer(config, app.callback())
  const resolver = createResolver(root, resolvers, alias)
  // 相关上下文信息
  const context: ServerPluginContext = {
    root,
    app,
    server,
    resolver,
    config,
    port: config.port || 3000
  }
  // 一个简单中间件，扩充 context 上下文内容
  app.use((ctx, next) => {
    Object.assign(ctx, context)
    ctx.read = cachedRead.bind(null, ctx)
    return next()
  })
  const resolvedPlugins = [
    // ...
  ]
}
```

当 script 标签 type 属性为 module 时，浏览器会请求模块相应内容

- 浏览器会发起 HTTP 请求，请求 HTTP Server 对应的 js 文件
- 经过 Vite Server 处理请求后，最后返回如下

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1F_ltQGAaQZkAAXD68sxUe4161.png)

在 Vite Server 处理请求时，通过 serverPluginModuleRewrite 中间件把请求地址进行修改

Vite 处理 import 方法做一个简单总结：

- 在 koa 中间件里获取请求 path 对应的 body 内容

- 通过 es-module-lexer 解析资源 AST，并拿到 import 的内容

- 如果判断 import 的资源是绝对路径，即可认为该资源为 npm 模块，并返回处理后的资源路径

  比如：vue -> /@modules/vue

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1F_gYEGAL6S2AASUUhepUGQ785.png)

Vite 这种 bundleless 方案的运行原理图：

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yF_ltUqAV2zLAADo9NOnOvk745.png)

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1F_ltVCAEgT6AAERxP80SRw964.png)

总结：

- Vite 利用浏览器原生支持 ESM 这一特性，省略了对模块的打包，也就不需要生成 bundle，因此初次启动更快，HMR 特性友好
- Vite 开发模式下，通过启动 koa 服务器，在服务端完成模块的改写（比如单文件的解析编译等）和请求处理，实现真正的按需编译
- Vite Server 所有逻辑基本都依赖中间件实现。这些中间件，拦截请求之后，完成如下内容：
  - 处理 ESM 语法，比如将业务代码中的 import 第三方依赖路径转换为浏览器可识别的依赖路径
  - 对 .ts、.vue 等文件进行即时编译
  - 对 Sass、Less 的需要预编译的模块进行编译
  - 和浏览器端建立 socket 连接，实现 HMR

Vite HMR 实现原理：

- 通过 watcher 监听文件改动
- 通过 server 端编译资源，并推送新模块内容给浏览器
- 浏览器收到新的模块内容，执行框架层面的 rerender/reload

在服务端，通过 chokidar 创建了一个监听文件改动的 watcher 来监听文件改动：

```typescript
const watcher = chokidar.watch(root, {
	ignored: [/node_modules/, /\.git/],
	// #610
	awaitWriteFinish: {
	  stabilityThreshold: 100,
	  pollInterval: 10
	}
}) as HMRWatcher
```

通过 serverPluginHmr 发布变动，通知浏览器

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgpVE1_ltm6AN8nCAAMSQ8AjILg631.png)

## 现代化前端开发和架构

### core-js

core-js 是由 lerna 搭建的 monorepo 风格的项目，在它的 packages 中，我们能看到五个相关包：

- core-js

  核心

  ```js
  import 'core-js'
  ```

- core-js-pure

  提供了不污染全局变量的垫片能力 

  ```js
  import _from from 'core-js-pure/features/array/from'
  ```

- core-js-compact

  维护了按照 browserlist 规范的垫片需求数据，来帮助我们找到符合目标环境的 polyfills 需求集合

  ```js
  const {
    list, // array of required modules
    targets, // object with targets for each module
  } = require('core-js-compact')({
    targets: '> 2.5%'
  });
  ```

- core-js-builder

  可以结合 core-js-compact 以及 core-js，并利用 webpack 能力，根据需求打包出 core-js 代码

  ```js
  require('core-js-builder')({
    targets: '> 0.5%',
    filename: './my-core-js-bundle.js',
  }).then(code => {}).catch(error => {});
  ```

- core-js-bundle

  把符合需求的 core-js 垫片打包到 my-core-js-bundle.js 文件当中

  ```js
  require('./packages/core-js-builder')({ filename: './packages/core-js-bundle/index.js' }).then(done).catch(error => {
    // eslint-disable-next-line no-console
    console.error(error);
    process.exit(1);
  });
  ```

$every 源码

```js
var bind = require('../internals/function-bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var arraySpeciesCreate = require('../internals/array-species-create');
var push = [].push;
// 对 `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` 等方法进行接模拟和接入
var createMethod = function (TYPE) {
  // 通过魔法数字来表示具体需要对哪种方法进行模拟
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    // 通过 bind 方法创建一个 boundFunction，保留 this 指向
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    // 遍历循环并执行回调方法
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
module.exports = {
  forEach: createMethod(0),
  map: createMethod(1),
  filter: createMethod(2),
  some: createMethod(3),
  every: createMethod(4),
  find: createMethod(5),
  findIndex: createMethod(6)
};
```

**polyfill 就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性**

那么如何能在工程中，寻找并设计一个“最完美”的 polyfill 方案呢？注意，这里的完美指的是侵入性最小，工程化、自动化程度最高，业务影响最低

**手动打补丁**

- es5-shim 和 es6-shim 轮子出现，经过一段艰辛岁月，被 babel-polyfill 取代

- babel-polyfill 结合 @babel/preset-env + useBuiltins(entry) + preset-env targets 的方法如今更为流行

  ```json
  {
    "presets": [
      ["@babel/env", {
        useBuiltIns: 'entry',
        targets: { chrome: 44 }
      }]
    ]
  }
  ```

**在线打补丁**

- 以 [Polyfill.io](https://polyfill.io/v3/) 为代表，它提供了 CDN 服务，使用者可以按照所需环境
- 因为按需加载补丁，意味着更小的 bundle size，直接决定了应用的性能

### Babel

Babel 可以做到如下内容：

- 语法转换，一般是高级语言特性的降级
- Polyfill（垫片/补丁）特性的实现和接入
- 源码转换，比如 JSX 等

Babel 设计，从工程化角度上，要秉承以下理念：

- 可插拔（Pluggable），比如 Babel 需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具
- 可调式（Debuggable），比如 Babel 在编译过程中，要提供一套 Source Map，来帮助使用者在编译结果和编译前源码之间建立映射关系，方便调试
- 基于协定（Compact），Compact 可以简单翻译为基于协定，主要是指实现灵活的配置方式，比如你熟悉的 Babelloose 模式，Babel 提供 loose 选项，帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡

Babel 是一个使用 Lerna 构建的 Monorepo 风格的仓库

- [@babel/core](https://babeljs.io/docs/en/babel-core) **是 Babel 实现转换的核心**，它可以根据配置，进行源码的编译转换

  @babel/core 的能力由更底层的 **@babel/parser**、**@babel/code-frame**、**@babel/generator**、**@babel/traverse、@babel/types** 等包提供

- [@babel/cli](https://babeljs.io/docs/en/babel-cli) **是 Babel 提供的命令行**，它可以在终端中通过命令行方式运行，编译文件或目录

- [@babel/standalone](https://github.com/babel/babel/tree/main/packages/babel-standalone) 这个包非常有趣，它可以在非 Node.js 环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx 的 type 值的 script 标签，并进行编译

Babel 底层原理

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_u4niAOtOmAAEw7EQpjEI596.png)

**@babel/polyfill 其实就是 core-js 和 regenerator-runtime 两个包的结合**

- **注意：@babel/polyfill 目前已经计划废弃**，新的 Babel 生态（@babel/preset-env V7.4.0 版本）鼓励开发者直接在代码中引入 core-js 和 regenerator-runtime

**@babel/runtime**含有 Babel 编译所需的一些运行时 helpers 函数，**供业务代码引入模块化的 Babel helpers 函数**，同时它提供了 [regenerator-runtime](https://www.npmjs.com/package/regenerator-runtime)，对 generator 和 async 函数进行编译降级

总结一下：

- @babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用
- @babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用
- @babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的
- @babel/runtime 用于运行时，作为 dependencies 使用

@babel/plugin-transform-runtime 和 @babel/runtime 结合还有一个作用：**它除了可以对产出代码瘦身以外，还能避免污染全局作用域**

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yF_tojyAfvQeAAMW8bbGBAY698.png)

### babel-preset

![image-20230301174435846](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230301174435846.png)

制定一个统一标准化 babel-preset

1. 支持 `NODE_ENV='development' | 'production' | 'test'` 三种环境，并有对应优化
2. 配置插件默认不开启 Babel `loose: true` 配置，让插件的行为尽可能地遵循规范，但对有较严重性能损耗或有兼容性问题的情况保留修改入口
3. 应该支持应用编译和公共库编译
4. 对于企业级公共库，建议使用标准 ES 特性发布，对 tree-shaking 有强烈需求的库，应同时发布 ES Module 格式代码
5. 对于企业级公共库，发布的代码不包含 polyfills，由使用方统一处理
6. 对于应用编译，使用 @babel/preset-env 同时编译应用代码与第三方库代码
7. 对于应用编译，需要对 node_modules 进行编译，并且为 node_modules 配置 `sourceType: 'unambiguous'`，以确保第三方依赖包中的 CommonJS 模块能够被正确处理
8. 对于应用编译，启用 plugin-transform-runtime，避免同样的 helper 代码被重复注入多个文件，以缩减打包后文件的体积。同时自动注入 regenerator-runtime，避免污染全局变量
9. 注入绝对路径引用的 @babel/runtime 包中对应的 helper，以确保能够引用到正确版本的 @babel/runtime 包中的文件

```js
// webpack.config.js
module.exports = {
  presets: ['@lucas/babel-preset/app'],
}
// 相关 webpack 配置
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        oneOf: [
          {
            exclude: /node_modules/,
            loader: 'babel-loader',
            options: {
              cacheDirectory: true,
            },
          },
          {
            loader: 'babel-loader',
            options: {
              cacheDirectory: true,
              configFile: false,
              // 使用我们的 preset
              presets: ['@lucas/babel-preset/dependencies'],
              compact: false,
            },
          },
        ],
      },
    ],
  },
}
```

- 对于 node_modules，我们开启 cacheDirectory 缓存
- 对于应用，我们直接使用 babel-loader 进行编译

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_0Bs2AS-oEABN0rwjVVsY144.png)

- 对于 node_modules 第三方依赖，使用 babel-preset/dependencies 预设
- 对于非 node_modules 的业务代码，使用 babel-preset/app 

![image-20230301181652978](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230301181652978.png)

### 公共库

Jest 运行在 Node.js 环境中，大部分 Node.js 版本（v10 以下）运行时并不支持 ESM

- 我们需要安装 babel-jest 和 babel 相关依赖到开发环境中

```js
module.exports = {
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          node: 'current',
        },
      },
    ],
  ],
};
```

在大部分不支持 import 语法特性的浏览器中，为了让我们的脚本直接在浏览器中使用 script 标签引入代码，首先我们**需要将已有公共库脚本编译为 UMD 方式**。类似上面使用 babel-jest 将测试脚本编译降级为当前 Node.js 版本支持的代码，我们还是需要 Babel 进行降级

- 使用 @babel/plugin-transform-modules-umd 来完成对代码的降级编译

![image-20230302094442956](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230302094442956.png)

如上结构通过 if...else 判断是否根据环境加载代码，这种 umd 格式，天然支持浏览器和 node.js  环境

- 但是并不优雅，也不利于使用方优化
- 另一种常见的做法是：将公共库按环境区分，分别产出两个 bundle，分别支持 node.js 和浏览器环境

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgpVE1_4C-KADRY4AAFZJiKE29s142.png)

如果一个 npm 需要在不同环境下加载 npm 包不同的入口文件，就会牵扯到 main、module、browser 字段

- main 定义了 npm 入口文件，browser 环境和 node 环境均可使用
- module 定义 npm 包的 esm 规范的入口文件，browser 环境和 node 环境均可使用
- browser 定义 npm 包在 browser 环境下的入口文件

webpack 在 web 浏览器环境配置下，优先选择：browser > module > main。在 node 环境下 module > main

### 代码拆分按需加载

按需打包一般通过两种方式进行：

- 使用 es module 支持的 tree-shaking 方案，在使用构建工具打包时，完成按需打包
- 使用以 babel-plugin-import 为主的 Babel 插件，实现自动按需打包

如果第三方库不支持 Tree Shaking，我们可以通过 Babel 插件，改变业务代码中对模块的引用路径来实现按需打包

- [babel-plugin-import](https://github.com/umijs/babel-plugin-import/blob/master/src/Plugin.js)

- 首先通过 buildExpressionHandler 方法对 import 路径进行改写

  buildExpressionHandler 方法依赖 importMethod 方法

- importMethod 方法调用了 @babel/helper-module-imports 中的 addSideEffect 方法执行路径的转换操作

静态导入对于绝大多数场景来说性能是友好的，因为这意味着对工程代码的静态分析成为可能，进而使得类似 tree-shaking 的技术有了应用空间

对于某些特殊场景，静态导入可能成为性能的短板，比如，我们需要：

- 按需加载一个模块
- 按运行事件选定一个模块
- [MDN import](https://developer.mozilla.org/zh-CN/docs/web/javascript/reference/statements/import)

**dynamic import 只是一个 function like 的语法形式**。在 ES class 特性中，super() 与 dynamic import 类似，也是一个 function like 语法形式

- dynamic import 并非继承自 Function.prototype，因此不能使用 Function 构造函数原型上的方法 impoort.call(null, ${path})，调用它是不合法的
- dynamic import 并非继承自 Object.prototype，因此不能使用 Object 构造函数原型上的方法

webpack 提供三种相关能力有关代码拆分和按需加载

- **通过入口配置手动分割代码**
- **动态导入支持**
- **通过 splitChunk 插件提取公共代码（公共代码分割）**

`webpackChunkName: "chunk-name"` 表示自定义新 chunk 名称

`webpackMode: "lazy"` 表示每个 import() 导入的模块，会生成一个可延迟加载（lazy-loadable） chunk

```js
import(
  /* webpackChunkName: "chunk-name" */
  /* webpackMode: "lazy" */
  'module'
);
```

webpack 对于业务中使用的 dynamic import 代码，会自动转换为自己定义的 `__webpack_require__.e` 函数，这个函数返回了一个 promise 数组，最终模拟出了动态导入的效果

![image-20230302113259624](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230302113259624.png)

- 定义一个 promise 数组 promises，最终以 Promise.all(promises) 形式返回
- 通过 installedChunks 变量判断当前模块是否已经被加载，如果已经加载过，将模块内容 push 到 promises 数组中
- 如果当前模块没有被加载过，则先定义一个 promise，然后创建一个 script 标签，加载模块内容，并定义 script 的 onload 和 onerror 回调
- 最终对新增 script 标签对应的 promise（resolve/reject）处理定义在 webpackJsonpCallback 回函数中

![image-20230302140555521](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230302140555521.png)

webpackJsonpCallback 在被重写的 push 方法中，执行异步脚本 promise 的回调

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yF_9BziALsMpAAFUvdp7KoQ251.png)

代码分割的核心意义在于**避免重复打包以及提升缓存利用率，进而提升访问速度**。比如，我们将不常变化的第三方依赖库进行代码拆分，方便对第三方依赖库缓存，同时抽离公共逻辑，减少单个文件的 size 大小

### Tree Shaking

**问题一：Tree Shaking 为什么要依赖 ESM 规范？**

Tree Shaking 是在编译时进行无用代码消除的，因为它需要在编译时确定依赖关系，进而确定哪些代码可以被摇掉，而 ESM 具备以下特点：

- import 模块名只能是字符串常量
- import 一般只能在模块最顶层出现
- import binding 是 immutable 的

**问题二：什么是副作用模块，如何对副作用模块进行 Tree Shaking?**

```js
export function add(a, b) {
	return a + b
}
export const memoizedAdd = window.memoize(add)
```

当该模块被 import 时，window.memoize 方法会被执行，那么对于工程化工具（Webpack）来说，分析思路是这样的：

- 创建一个纯函数 add，如果没有其他模块引用 add 函数，那么 add 函数可以被 Tree Shaking 掉
- 接着调用 window.memoize 方法，并传入 add 函数作为其参数
- 工程化工具并不知道 window.memoize 方法做什么事情，也许 window.memoize 会调用 add 函数，并触发某些副作用（比如维护一个全局的 Cache Map）
- 工程化工具为了安全起见，即便没有其他模块依赖 add 函数，那么也要将 add 函数打包到最后的 bundle 中

为了解决具有副作用的模块难以被 Tree Shaking 优化这个问题，Webpack 提供 sideEffects 属性来告诉工程化有哪些模块具有副作用

Webpack 真正执行模块去除，是依赖了 TerserPlugin、UglifyJS 等压缩插件。**Webpack 负责对模块进行分析和标记，而这些压缩插件负责根据标记结果，进行代码删除**。Webpack 在分析时，有三类相关的标记：

- harmony export，被使用过的 export 会被标记为 harmony export
- unused harmony export，没被使用过的 export 标记为 unused harmony export
- harmony import，所有 import 标记为 harmony import

在 Vue2.0 中，如果我们没有使用 nextTick，那么 nextTick 这种的全局 API 就成了 dead code，且不容易被 Tree Shaking 掉

在 Vue3.0 中，考虑了 Tree Shaking 兼容，进行了重构，全局 API 需要通过原生 ES Module 的引用方式进行具名引用

如何设计一个兼顾 Tree Shaking 和易用性的公共库

- 普遍做法是在第三方库打包构建时，参考 antd，一般都会构建出 lib/ 和 es/ 两个文件夹，并配置`package.json`的`main`、`module`字段即可

```json
{
  "main": "lodash.js",
  "module": "lodash.js",
  "name": "lodash-es",
  "sideEffects": false,
  //...
}
```

**CSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除**。那么我们只需要：

- 遍历所有 CSS 文件的选择器
- 根据所有 CSS 文件的选择器，在 JavaScript 代码中进行选择器匹配
- 如果没有匹配到，则删除对应选择器的样式代码

```js
export default class PurgeCSSPlugin {
  options: UserDefinedOptions
  purgedStats: PurgedStats = {}
  constructor(options: UserDefinedOptions) {
    this.options = options
  }
  apply(compiler: Compiler): void {
    compiler.hooks.compilation.tap(
      pluginName,
      this.initializePlugin.bind(this)
    )
  }
}
```

将所有的 CSS 文件交给 PostCss 处理（[源码](https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L274)关键部分，对 CSS AST 应用规则）

```js
public walkThroughCSS(
    root: postcss.Root,
    selectors: ExtractorResultSets
  ): void {
    root.walk((node) => {
      if (node.type === "rule") {
        return this.evaluateRule(node, selectors)
      }
      if (node.type === "atrule") {
        return this.evaluateAtRule(node)
      }
      if (node.type === "comment") {
        if (isIgnoreAnnotation(node, "start")) {
          this.ignore = true
          // remove ignore annotation
          node.remove()
        } else if (isIgnoreAnnotation(node, "end")) {
          this.ignore = false
          // remove ignore annotation
          node.remove()
        }
      }
    })
  }
```

### AST

[AST explorer](https://astexplorer.net/)，在这个平台中，可以实时看到 JavaScript 代码转换为 AST 之后的产出结果

acorn 是一个完全使用 JavaScript 实现的、小型且快速的 JavaScript 解析器

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yGAGmc2AAm_DAADuYazKZ4U044.png)

acorn 实现解析 AST 的入口骨架，实际的分词环节主要解决以下问题：

1. 明确需要分析哪些 Token 类型
   - 关键字：import，function，return 等
   - 变量名称
   - 运算符号
   - 结束符号
2. 状态机
   - Program —— 整个程序
   - Statement —— 语句
   - Expression —— 表达式

实现一个简易的 Tree Shaking 脚本

- JSEmitter 类创建了很多 visitXXX 方法，最终都会产出 JavaScript 代码

```js
class JSEmitter {
  // 访问变量声明，以下都是工具方法
  visitVariableDeclaration(node) {
    let str = ''
    str += node.kind + ' '
    str += this.visitNodes(node.declarations)
    return str + '\n'
  }
  visitVariableDeclarator(node, kind) {
    let str = ''
    str += kind ? kind + ' ' : str
    str += this.visitNode(node.id)
    str += '='
    str += this.visitNode(node.init)
    return str + ';' + '\n'
  }
  visitIdentifier(node) {
    return node.name
  }
  visitLiteral(node) {
    return node.raw
  }
  visitBinaryExpression(node) {
    let str = ''
    str += this.visitNode(node.left)
    str += node.operator
    str += this.visitNode(node.right)
    return str + '\n'
  }
  visitFunctionDeclaration(node) {
    let str = 'function '
    str += this.visitNode(node.id)
    str += '('
    for (let param = 0; param < node.params.length; param++) {
      str += this.visitNode(node.params[param])
      str += node.params[param] == undefined ? '' : ','
    }
    str = str.slice(0, str.length - 1)
    str += '){'
    str += this.visitNode(node.body)
    str += '}'
    return str + '\n'
  }
  visitBlockStatement(node) {
    let str = ''
    str += this.visitNodes(node.body)
    return str
  }
  visitCallExpression(node) {
    let str = ''
    const callee = this.visitIdentifier(node.callee)
    str += callee + '('
    for (const arg of node.arguments) {
      str += this.visitNode(arg) + ','
    }
    str = str.slice(0, str.length - 1)
    str += ');'
    return str + '\n'
  }
  visitReturnStatement(node) {
    let str = 'return '
    str += this.visitNode(node.argument)
    return str + '\n'
  }
  visitExpressionStatement(node) {
    return this.visitNode(node.expression)
  }
  visitNodes(nodes) {
    let str = ''
    for (const node of nodes) {
      str += this.visitNode(node)
    }
    return str
  }
  // 根据类型，执行相关处理函数
  visitNode(node) {
    let str = ''
    switch (node.type) {
      case 'VariableDeclaration':
        str += this.visitVariableDeclaration(node)
        break
      case 'VariableDeclarator':
        str += this.visitVariableDeclarator(node)
        break
      case 'Literal':
        str += this.visitLiteral(node)
        break
      case 'Identifier':
        str += this.visitIdentifier(node)
        break
      case 'BinaryExpression':
        str += this.visitBinaryExpression(node)
        break
      case 'FunctionDeclaration':
        str += this.visitFunctionDeclaration(node)
        break
      case 'BlockStatement':
        str += this.visitBlockStatement(node)
        break
      case 'CallExpression':
        str += this.visitCallExpression(node)
        break
      case 'ReturnStatement':
        str += this.visitReturnStatement(node)
        break
      case 'ExpressionStatement':
        str += this.visitExpressionStatement(node)
        break
    }
    return str
  }
  // 入口
  run(body) {
    let str = ''
    str += this.visitNodes(body)
    return str
  }
}
module.exports = JSEmitter
```

- 首先获取到目标文件，对目标文件通过 fs.readFileSync() 方法读取出字符串形式的内容 buffer，对于这个 buffer，我们使用 acorn.parse 进行解析，并对产出内容进行遍历

- 遍历过程中，对于不同的节点类型，调用 JSEmitter 实例不同的处理方法，整个过程中，我们维护了：

  - decls - Map 类型
  - calledDecls - 数组类型
  - code - 数组类型

  遍历过程中，我们对所有函数和变量的声明，都维护到 decls 中。接着，对所有的 callExpression 和 IDentifier 进行检测

  经过整个 AST 遍历，我们就可以只遍历 calledDecls 数组，并从 decls 变量中获取使用到的变量和函数声明，最终使用 concat 方法合并带入 code 变量中，使用 join 方法转换为字符串类型

```js
const acorn = require('acorn')
const JSEmitter = require('./js-emitter')
const fs = require('fs')

// 获取命令行参数
const args = './test.js' // process.argv[2]
const buffer = fs.readFileSync(args).toString()
const body = acorn.parse(buffer).body
const jsEmitter = new JSEmitter()
let decls = new Map()
let calledDecls = []
let code = []

// 遍历处理
body.forEach(function (node) {
  if (node.type == 'FunctionDeclaration') {
    const code = jsEmitter.run([node])
    decls.set(jsEmitter.visitNode(node.id), code)
    return
  }
  if (node.type == 'ExpressionStatement') {
    if (node.expression.type == 'CallExpression') {
      const callNode = node.expression
      calledDecls.push(jsEmitter.visitIdentifier(callNode.callee))
      const args = callNode.arguments
      for (const arg of args) {
        if (arg.type == 'Identifier') {
          calledDecls.push(jsEmitter.visitNode(arg))
        }
      }
    }
  }
  if (node.type == 'VariableDeclaration') {
    const kind = node.kind
    for (const decl of node.declarations) {
      decls.set(
        jsEmitter.visitNode(decl.id),
        jsEmitter.visitVariableDeclarator(decl, kind)
      )
    }
    return
  }
  if (node.type == 'Identifier') {
    calledDecls.push(node.name)
  }
  code.push(jsEmitter.run([node]))
})

// 生成 code
code = calledDecls
  .map(c => {
    return decls.get(c)
  })
  .concat([code])
  .join('')
fs.writeFileSync('test.shaked.js', code)
```

### 换肤

如何高效地支持深色模式（工程化、自动化方案，必须要开发中 hard coding）

使用 CSS 自定义属性只是其中一个环节，站在更高、更中中台化的视觉思考，我们还需要设计：

- 如何维护不同主题色值
- 谁来维护不同主题色值
- 研发和设计之间，如何保持不同主题色值的同步沟通
- 如何最小化前端工程师的开发量，不需要 hard coding 两份颜色数值
- 如何做到一键切换时的性能最优
- 如何配合 JavaScript 状态管理，同步主题切换的信号

基于以上考虑，以一个超链接样式为例，我们希望做到开发时，编写如下代码

```css
a {
  color: cc(GBK05A);
}
/* <==> */
a {
  color: #646464;
}
```

这样代码就能一劳永逸支持两套主题模式，我们来看看在编译时，构建环境发生了什么：

- `cc(GBK05A)` 这样的声明，被编译为 `#646464`
- 也就是说，`cc` 是一个 CSS function，而 `GBK05A` 是一组色值，分别包含了 light 和 dark 两种主题的颜色
- 同时在 HTML 根节点上，添加属性选择器 `data-theme='dark'`，并添加 a 标签 color 色值样式为 `#808080`

维护一个色值，结合上例就是：

```yaml
GBK05A: [BK05, BK06]
BK05: '#808080'
BK06: '#999999'
```

postcss-theme-colors 需要：

1. 识别 `cc` 方法
2. 读取色值
3. 通过色值，对 `cc` 方法求值，得到两种颜色，分别对应 dark 和 light 模式
4. 原地编译 CSS 中的颜色为 light 模式色值
5. 同时 dark 模式色值写到 HTML 节点上

为了将 dark 模式色值按照 `html[data-theme='dark']` 方法写到 HTML 节点上，使用两个 PostCSS 插件完成：

- [PostCSS Nested](https://www.npmjs.com/package/postcss-nested)
- [PostCSS Nesting](https://www.npmjs.com/package/postcss-nesting)

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgpVE2AJHHCAbXrZAAH5kg-FP4Q349.png)

### Webpack

Webpack 实质就是一个 "前端模块打包器"。前端为什么需要一个模块打包器呢？

- 不是所有浏览器都直接支持 JavaScript 规范
- 前端需要管理依赖脚本，把控不同脚本加载的顺序
- 前端需要按顺序加载不同类型的静态资源

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1GAOlIOAYZLfAAFmQUf14uQ501.png)

探寻 Webpack 打包奥秘，为了简化，我们以 ESM 模块化规范举例

```js
// filename: circle.js
const PI = 3.141;
export default function area(radius) {
  return PI * radius * radius;
}

// filename: square.js
export default function area(side) {
  return side * side;
}

// filename: app.js
import squareArea from './square';
import circleArea from './circle';
console.log('Area of square: ', squareArea(5));
console.log('Area of circle', circleArea(5));
```

经过 webpack 打包后，我们用 bundle.js 来表示 webpack 处理结果（精简并可读化处理后）：

```js
// filename: bundle.js
const modules = {
  'circle.js': function(exports, require) {
    const PI = 3.141;
    exports.default = function area(radius) {
      return PI * radius * radius;
    }
  },
  'square.js': function(exports, require) {
    exports.default = function area(side) {
      return side * side;
    }
  },
  'app.js': function(exports, require) {
    const squareArea = require('square.js').default;
    const circleArea = require('circle.js').default;
    console.log('Area of square: ', squareArea(5))
    console.log('Area of circle', circleArea(5))
  }
}
webpackBundle({
  modules,
  entry: 'app.js'
});
```

webpackBundle 方法接收 modules 模块信息以及一个入口脚本：

```js
function webpackBundle({ modules, entry }) {
  const moduleCache = {};
  const require = moduleName => {
    // 如果已经解析并缓存过，直接返回缓存内容
    if (moduleCache[moduleName]) {
      return moduleCache[moduleName];
    }
    const exports = {};
    // 这里是为了防止循环引用
    moduleCache[moduleName] = exports;
    // 执行模块内容，如果遇见了 require 方法，则继续递归执行 require 方法 
    modules[moduleName](exports, require);
    return moduleCache[moduleName];
  };
  require(entry);
}
```

rollup 打包过后的产出为：

```js
const PI = 3.141;
function circle$area(radius) {
  return PI * radius * radius;
}
function square$area(side) {
  return side * side;
}
console.log('Area of square: ', square$area(5));
console.log('Area of circle', circle$area(5));
```

webpack 与 rollup 打包方式对比：

- webpack
  - 使用了 module map，维护项目中的依赖关系
  - 使用了包裹函数，对每个模块进行包裹
  - 使用了一个 runtime 方法（这里举例为 webpackBundle），最终合成 bundle 内容
- rollup
  - 将每个模块拍平
  - 不使用包裹函数，不需要对每个模块进行包裹

**在 Rollup 处理理念下，如果模块出现了循环依赖，会发生什么现象呢**？

- rollup 本身是不支持 commonjs 模块，要想打包，必须借助 @rollup/plugin-node-resolve 和 @rollup/plugin-commonjs 这两个插件，并且在打包过程中会把 cjs 的模块转换成 es modules
- esm 模块加载机制中，import 是静态执行的，export 是动态绑定的。也就是说 js 引擎会对 import 语句进行提升，不管写在哪，总是最先执行，并递归加载所有导入的模块，遇到加载过的模块直接跳过，是一个深度优先遍历的过程
- 所以 esm 模块加载机制根本不关心是否出现了循环引用，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值

**手动实现打包器**

核心思路如下：

1. 读取入口文件（比如`entry.js`）
2. 基于 AST 分析入口文件，并产出依赖列表
3. 使用 Babel 将相关模块编译到 ES5
4. 对每个依赖模块产出一个唯一的 ID，方便后续读取模块相关内容
5. 将每个依赖以及经过 Babel 编译过后的内容，存储在一个对象中进行维护
6. 遍历上一步中的对象，构建出一个依赖图（Dependency Graph）
7. 将各模块内容 bundle 产出

安装以下依赖：

- `@babel/parser`用于分析源代码，产出 AST
- `@babel/traverse`用于遍历 AST，找到 import 声明
- `@babel/core`用于编译，将源代码编译为 ES5
- `@babel/preset-env`搭配`@babel/core`使用
- `resolve`用于获取依赖的绝对路径

```js
const fs = require('fs')
const path = require('path')
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const babel = require('@babel/core')
const resolve = require('resolve').sync
```

我们维护一个全局 ID，并通过遍历 AST，访问 `ImportDeclaration` 节点，收集依赖到 `deps` 数组中，同时完成 Babel 降级编译：

- 这里采用了自增 ID，如果采用随机的 GUID，会更安全
- 我们实现了一个模块的分析，并产出：该模块对应 ID、该模块路径、该模块的依赖数组、该模块经过 Babel 编译后的代码

```js
let ID = 0

function createModuleInfo(filePath) {
  // 读取模块源代码
  const content = fs.readFileSync(filePath, 'utf-8')
  // 对源代码进行 AST 产出
  const ast = parser.parse(content, {
    sourceType: 'module'
  })
  // 相关模块依赖数组
  const deps = []
  // 遍历模块 AST，将依赖推入 deps 数组中
  traverse(ast, {
    ImportDeclaration: ({ node }) => {
      deps.push(node.source.value)
    }
  })
  const id = ID++
  // 编译为 ES5
  const { code } = babel.transformFromAstSync(ast, null, {
    presets: ['@babel/preset-env']
  })
  return {
    id,
    filePath,
    deps,
    code
  }
}
```

我们使用一个数组类型的变量 graphArr 来描述整个项目的依赖树情况。最后，基于 graphArr 内容，将相关模块进行打包

```js
function createDependencyGraph(entry) {
  // 获取模块信息
  const entryInfo = createModuleInfo(entry)
  // 项目依赖树
  const graphArr = []
  graphArr.push(entryInfo)
  // 以入口模块为起点，遍历整个项目依赖的模块，并将每个模块信息维护到 graphArr 中
  for (const module of graphArr) {
    module.map = {}
    module.deps.forEach(depPath => {
      const baseDir = path.dirname(module.filePath)
      const moduleDepPath = resolve(depPath, { baseDir })
      const moduleInfo = createModuleInfo(moduleDepPath)
      graphArr.push(moduleInfo)
      module.map[depPath] = moduleInfo.id
    })
  }
  return graphArr
}
```

最后，我们基于 garphArr 内容，将相关模块进行打包

```js
function pack(graph) {
  const moduleArgArr = graph.map(module => {
    return `${module.id}: {
          factory: (exports, require) => {
              ${module.code}
          },
          map: ${JSON.stringify(module.map)}
      }`
  })
  const iifeBundler = `(function(modules){
      const require = id => {
          const {factory, map} = modules[id];
          const localRequire = requireDeclarationName => require(map[requireDeclarationName]); 
          const module = {exports: {}};
          factory(module.exports, localRequire); 
          return module.exports; 
      }
      require(0);
      
      })({${moduleArgArr.join()}})
  `
  return iifeBundler
}
```

我们创建一个对应每个模块的模板对象：

```js
return `${module.id}: {
  factory: (exports, require) => {
    ${module.code}
  },
  map: ${JSON.stringify(module.map)}
  }`
```

在 factory 对应的内容中，我们包裹模块代码，并注入 exports 和 require 两个参数

- 我们构造了一个 IIFE 风格的代码区块，用于将依赖树中的代码串联在一起
- 使用 IIFE 的方式，来保证模块变量不会影响到全局作用域
- 构建好的项目依赖树数组，将会作为名为 modules 的形参，传递给 IIFE
- 我们构造了 `require(id)` 方法，这个方法的意义在于：
  - 通过 `require(map[requireDeclarationName])` 方式，按顺序递归调用各个依赖模块
  - 通过调用 `factory(module,.exports, localRequire)` 执行模块相关代码
  - 该方法最终返回 `module.exports` 对象，`module.exports` 最初值为空对象（`{exports: {}}`），但在一次次调用 `factory()` 函数后，`module.exports` 对象内容已经包含了模块对外暴露的内容了

```js
const iifeBundler = `(function(modules){
  const require = id => {
    const {factory, map} = modules[id];
    const localRequire = requireDeclarationName => require(map[requireDeclarationName]); 
    const module = {exports: {}};
    factory(module.exports, localRequire); 
    return module.exports; 
  } 
  require(0);
})({${moduleArgArr.join()}})
`
```

打包过程主要分为两步：依赖解析（Dependency Resolution）和代码打包（Bundling）：

- 在依赖解析过程中，我们通过 AST 技术，找到每个模块的依赖模块，并组合为最终的项目依赖树
- 在代码打包过程中，我们使用 Babel 对源代码进行编译，其中也包括了对 imports / exports（即对 ESM） 的编译

### 小程序

类 Vue 风格的编译时和运行时结合方案

Vue DSL(Domain Specific Language) 静态编译

**小程序多端——编译时方案**

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHmAT7b2AYQJdAADnHNucgjE454.png)

以微信小程序举例，转换目标如下图：

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1GAT7auABbA4AAD1EDPUmAQ243.png)

可能你会想到正则，但正则的能力有限，复杂度也较高。更普遍的做法，如 mpvue、uni-app 等，都依赖了 AST（抽象语法树）技术

**小程序多端——运行时方案**

一般在 Vue 单文件组件的 script 部分，我们会使用以下代码来初始化一个 Vue 实例。

```js
new Vue({
  data() {},
  methods: {},
  components: {}
})
```

对于多端方案来说，就完全可以引入一个 Vue 的运行时版，对上述代码进行解析和执行。mpvue 就是 fork 了一份 Vue.js 的代码，因此内置了 Vue runtime 能力，同时添加了小程序平台的支持

下面要做的就是在运行时将 Vue 实例和小程序实例进行关联，以做到：数据变动时，小程序实例能够调用 setData() 方法，进行渲染层更新

- Vue 基于响应式，对数据进行监听，在数据改动时，新生成一份虚拟节点 VNode。接下来对比新旧两份虚拟节点，找到 Diff，并进行 patch 操作，最终更新了真实的 DOM 节点
- 因为小程序架构中，并没有提供操作小程序节点的 API 方法，因此对于小程序多端方案，我们显然不需要进行 Vue 源码中的 patch 操作
- 又因为小程序隔离了渲染进程（渲染层）和逻辑进程（逻辑层），我们不需要处理渲染层，只需要调用 setData() 方法，更新一份最新的数据就可以了

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHmAXmvKAEQr9AAErNUu9oi4120.png)

网易考拉 Megalo 在上述方案的基础上，将整个数据结构进行了扁平化，目的是在调用 setData() 方法时，可以获得更好的性能

类 React 风格的编译时和运行时结合方案

- 如何将 JSX 转换为小程序模版？
- 我们知道不同于 Vue 模版理念，React 生态选择了 JSX 来表达视图，但是 JSX 过于灵活，单纯基于 AST（抽象语法树）技术很难进行一对一转换

类 React 风格的小程序多端方案就可以分成两个流派

- 强行静态编译型，代表有：京东的 Taro 1/2，去哪儿的 Nanachi 等
- 运行时处理型，代表有：Taro Next，蚂蚁的 Remax

运行时开发者能够处理 React JSX 的核心基础其实在于 React 的设计理念，React 将自身能力充分解耦，并提供给社区接入关键环节

React 核心理念可以分为三大部分：

- React Core：处理最核心的 APIs，与终端平台和渲染解耦，主要提供了下面这些能力：
  1. React.createElement()
  2. React.createClass()
  3. React.Component
  4. React.Children
  5. React.PropTypes
- React Renderer：渲染器定义了一个 React Tree 如何构建接轨不同平台，比如：
  1. React-dom 渲染组件树为 DOM elements
  2. React Native 渲染组件树为不同原生平台视图
- Reconciler：负责 diff 算法，接驳 patch 行为。可以被 React-dom、React Native、React ART 这些 renderers 共用，并提供基础计算能力。现在 React 主要有两种类型的 reconcilers：
  1. Stack reconciler，React 15 以及更早期 React 版本使用
  2. Fiber reconciler，新一代的架构

核心架构可以总结为下图：

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHmAT8DSAGRn-AAJEN4yKmdI464.png)

以 Remax 为例，上图所示 VNodeData 数据中，包含了节点信息，比如 type="view"，我们可以通过递归 VNodeData 这个数据结构，根据不同的 type 渲染出不同的小程序模版

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1GAXmzmACf4fAAVidO1Nf0U984-16780674914921.png)

### Flutter

基于 WebView 到 JSBridge 的 Hybrid 方案发展

- 最早的实践就是通过 WebView 双端运行 Web 代码。事实上，虽然 iOS 和 Android 系统难以统一，但是它们都对 Web 技术开放。Hybrid 方案算是最古老，但也是最成熟、应用最为广泛的技术

- 在 iOS 和 Android 系统上运行 JavaScript 并不是一件难事儿，但是对于一个真正意义上的跨平台应用来说，还需要做到H5（即 WebView 容器）和原生平台的交互，于是 JSBridge 技术就诞生了

  JavaScript 代码是运行在一个单独的 JS Context 中（比如 WebView 的 WebKit 引擎、JavaSriptCore 等），这个独立的上下文和原生能力的交互过程是双向的

  1. JavaScript 调用 Native，方法有：
     1. 注入 APIs
     2. 拦截 URL Scheme
  2. Native 调用 JavaScript

前端调用原生能力主要有两种方式，注入 APIs 其实就是原生平台通过 WebView 提供的接口，向 JavaScript Context 中（一般使用 Window 对象），注入相关方案和数据；另一种拦截 URL Scheme 就更加简单了，前端通过发送定义好的 URL Scheme 请求，并将相关数据放在请求体中，该请求被原生平台拦截后，由原生平台做出响应

Native 调用 JavaScript，实现起来也很简单。因为 Native 实际上是 WebView 的宿主，因此 Native 具有更大权限，故而原生平台可以通过 WebView APIs 直接执行 JavaScript 代码

随着 JSBridge 这种方式实现跨平台技术的成熟，社区上出现了 Cordova、Ionic 等框架，它们本质上都是使用 HTML、CSS 和 JavaScript 进行跨平台原生应用的开发。该方案说到底是在 iOS 和 Androd 上运行 Web 应用，因此也存在较多问题，比如：

- JavaScript Context 和原生通信频繁，导致性能体验较差
- 页面逻辑由前端负责，组件也是前端渲染，也造成了性能短板
- 运行 JavaScript 的 WebView 内核在各平台上不统一
- 国内厂商对于系统的深度定制，导致内核碎片化

因此，新一代的 Hybrid 跨平台方式，以React Native 为代表的方案就诞生了，这种方案主要思想是：开发者依然使用 Web 语言（如 React 框架或其他 DSL），但渲染基本交给原生平台处理。 这样一来，在视图层面就可以摆脱 WebView 的束缚，保障了开发体验和效率，以及使用性能。我把这种技术叫作基于 OEM 的 Hybrid 方案

React Native 脱胎于 React 理念，它将数据与视图相隔离，React Native 代码中的标签映射为虚拟节点，由原生平台解析虚拟节点并渲染出原生组件。美好的愿景是：开发者使用 React 语法，同时开发原生应用和 Web 应用，其中组件渲染、动画效果、网络请求等都由原生平台来负责。整体技术架构如下图：

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Ciqc1GAZK5-ASl0rAAMYrAXB4Po374.png)

React Native 主要由：

- JavaScript
- C++ 适配层
- iOS/Androd

三层组成，最重要的 C++ 层实现了动态链接库，起到了衔接适配前端和原生平台作用，这个衔接具体指：使用 JavaScriptCore 解析 JavaScript 代码（iOS 上不允许用自己的 JS Engine，iOS 7+ 默认使用 JavaScriptCore，Android 也默认使用 JavaScriptCore），通过 MessageQueue.js 实现双向通信，实际上通信格式类似 JSON-RPC

新的 React Native 技术架构将从三个方面进行革新。

1. 改变线程模型（Threading Model），以往 React Native 的 UI 更新需要在三个不同的线程进行，新的方案使具有高优先级更新的线程，直接同步调用 JavaScript；同时低优先级的 UI 更新任务不会占用主线程。这里提到的三个并行线程是：
   - JavaScript 线程，在这个线程中，Metro 负责生成 JS bundles，JavaScriptCore 负责在应用运行时解析执行 JavaScript 代码
   - 原生线程，这个线程负责用户界面，每当需要更新 UI 时，该线程将会与 JavaScript 线程通信，可以细分为原生模块和原生 UI
   - Shadow 线程，该线程负责计算布局，React Native 具体通过 Yoga 布局引擎来解析并计算 Flexbox 布局，并将结果发送回原生 UI 线程
2. 引入异步渲染能力，实现不同优先级的渲染，同时简化渲染数据信息
3. 简化 Bridge 实现，使之更轻量可靠，使 JavaScript 和原生平台的调用更加高效

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHmAYzj-ANDk6AAyPBuKOtmk965.png)

## 核心框架原理

### Axios

Node.js 基于 V8 JavaScript Engine，顶层对象是 global，不存在 Window 对象和浏览器宿主，因此使用传统的 XMLHttpRequest/Fetch 在 Node.js 上发送请求是行不通的

单就浏览器环境发送请求来说，一般存在两种技术方法：

- XMLHttpRequest 规范
- Fetch 规范

XMLHttpRequest 存在一些缺点，比如：

- 配置和使用方式较为烦琐
- 基于事件的异步模型不够友好

Fetch 基于 Promise，语法更加简洁，语义化更加突出，但兼容性不如 XMLHttpRequest

对于请求库来说，是否要处理以下看似通用，但又具有定制性的功能呢？

- 自定义 headers 添加
- 统一断网/弱网处理
- 接口缓存处理
- 接口统一错误提示
- 接口统一数据处理
- 统一数据层结合
- 统一请求埋点

拦截器它赋予了分层开发时借助拦截行为，注入自定义能力的功能

axios 拦截器主要由：任务注册 -> 任务编排 -> 任务调度（执行）三步骤

任务注册部分源码：

- 定义的请求/响应拦截器，会在每一个 axios 实例的 interceptors 属性中维护，里面是一个 InterceptorManager 实例，该实例的 handlers 属性以数组形式存储使用定义的一个个拦截器逻辑

```js
// lib/core/Axios.js
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

// lib/core/InterceptorManager.js
function InterceptorManager() {
  this.handlers = [];
}
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  // 返回当前的索引，用于移除已注册的拦截器
  return this.handlers.length - 1;
};
```

任务调度阶段执行各个拦截器：

- 通过 chain 数组来编排调度任务，`dispatchRequest` 方法实际执行请求的发送，编排过程实现：**在实际发送请求的方法** `dispatchRequest` 前插入请求拦截器
- 通过一个 While 循环，通过一个 Promise 实例，遍历迭代 chain 数组方法，并给予 Promise 回调特性，将各个拦截器串联执行起来

```js
// lib/core/Axios.js
Axios.prototype.request = function request(config) {
  config = mergeConfig(this.defaults, config);
  // ...
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  // 任务编排
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  // 任务调度
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  return promise;
};
```

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHmAY6WuAA9A_AAEfckV_ZjM495.png)

Node.js 中，需要通过 HTTP 模块发送请求。对此，axiso 是如何设计实现的呢？

为了支持适配不同环境，axios 实现了适配器：Adapter，具体实现在`dispatchRequest`方法中:

```js
// lib/core/dispatchRequest.js
module.exports = function dispatchRequest(config) {
  // ...
  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    // ...
    return response;
  }, function onAdapterRejection(reason) {
    // ...
    return Promise.reject(reason);
  });
};
```

axios 支持使用方实现自己的 Adapter，自定义不同环境中的请求实现方式，也提供了默认的 Adapter。默认 Adapter 逻辑代码如下：

```js
// lib/defaults.js
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}
```

安全思想：

> Cross—Site Request Forgery，攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说，这个请求是完全合法的，但是却完成了攻击者期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至购买商品、虚拟货币转账等

axios 主要依赖双重 cookie 的方式防御 CSRF

```js
// lib/defaults.js
var defaults = {
  adapter: getDefaultAdapter(),
  // ...
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
};
```

### Koa
