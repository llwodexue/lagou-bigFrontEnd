## 突破思维

### 前端之路

> [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)

面试造火箭，工作拧螺丝

- 我精通 Vue.js，看过 Vue.js 源码

  我能熟记Object.defineProperty/ Proxy，也知道发布订阅模式

- 我精通 AST

  我知道 AST 是抽象语法树，知道能用它做些什么

- 我熟练使用并了解 Babel

  我能记清楚很多 Babel 配置项，甚至默写出 Babel Plugin 模板代码

你知道 Vue.js 完整版和运行时版本的区别吗？

- 如果你不理解 Vue.runtime.js 运行时版本不包含模板编译器，就大概率无法说清 Vue 在模板编译环节具体做了什么。如果只知道几个 APIs 实现数据劫持和发布订阅模式，又何谈精通原理

请你手写一个“匹配有效括号”算法？

- 如果连 LeetCode 上 easy 难度的编译原理相关算法题都无法做出，那么何谈分词、AST 这些概念

如何设计一个 C 端 Polyfill 方案？

- 如果不清楚`@babel/preset-env`的`useBuiltIns`不同配置背后的设计理念，又何谈了解 Babel，更别说设计一个性能更好的降级方案

从 0 到 1 打造应用的基础建设、制定应用的工程化方案、实现应用的构建和发布流程、设计应用中公共方法和底层架构。系统性地研究这些知识，才能真正打通开发者“任督二脉”，实现个人和团队更大的价值

对于业务来说，在工程化基建当中：

- 团队并非一个人单打独斗，那么如何设计工作流程，如何打造一个众人皆赞的项目根基？
- 项目依赖纷繁复杂，如何做好依赖管理和公共库管理？
- 如何深入理解框架，真正做到框架的精通和技术选型的准确拿捏？
- 从最基本的网络请求库说起，如何设计一个稳定灵活的多端 Fetch 库？
- 如何借力 Low Code / No Code 技术，实现越来越智能的应用搭建方案？
- 如何统一中后台项目架构，实现跨业务线的产研效率提升？
- 如何开发设计一套适合业务的组件库，封装分层样式，最大限度做到复用，提升开发效率？
- 如何制定跨端方案，Write Once，Run Everywhere 是否真的可行？
- 如何处理各种模块化规范，以及精确做到代码拆分的最佳实践？
- 如何区分开发边界，比如前端如何更好地利用 Node.js 方案开疆扩土？

### 技术回顾

MVVM 和 MVC 最大的区别在于：MVVM 采用双向绑定（Data Binding）或自动渲染更新

- View 层的变动，可以自动反映在 ViewModel 层。Angular 和 Vue 都采用这种模式
- 虽然 React 官方声称自己只是一个 View 层类库，但是 React 搭配数据状态管理生态，也符合 MVVM 模式

![image-20230224161202315](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161202315.png)

> [Rendering on the Web](https://developers.google.com/web/updates/2019/02/rendering-on-the-web)

CSR 渲染架构图

![image-20230224161711485](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161711485.png)

- 实现了前后端架构分离，实现了前后端职责分离
- TTFB 时间最小，但由于客户端和服务端会有多次交互（获取静态资源、获取数据）才能进行渲染，实际首屏效果以及 FCP/FMP 时间不够理想

SSR 渲染架构图

![image-20230224161831332](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230224161831332.png)

我们可以将 SSR 和 CSR 相结合，即实现一个基于 hydration（注水） 的 SSR 和 CSR 结合方案

## 前端工程化管理工具

### npm

项目依赖出现问题你可能有出现问题：

- 删除 node_modules 和 lockfiles，再重新 install，这样操作是否存在风险？
- 把所有依赖都安装到 dependencies 中，不区分 devDependencies 会有问题吗？
- 我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗？
- 一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题？
- 我们是否应该提交 lockfiles 文件到项目仓库呢？

Ruby 的 Gem、Python 的 pip 都是全局安装，但是 npm 安装机制秉承着不同的设计哲学

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/Cip5yF_axkqAclTFAAJmlxGYSmI551.png)

npm 缓存机制

- 对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计

  `npm config get cache `

- 当 npm install 执行时，通过 pacote 把相应的包解压在对应的 node_modules 下面。npm 下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下

  pacote 依赖 npm-registry-fetch 来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据 IETF RFC 7234 来生成缓存数据

- 在安装资源时，根据 `package-lock.json` 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录

  如果发现有缓存资源，找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过 pacote 把对应的二进制文件解压到响应的 node_modules 下面，省去了网络下载资源的开销

npm link

- 假如我开发一个组件库，某个组件开发完成之后，如何验证该组件能在我的业务项目中正常运行呢？

  除了写一个完备的测试以外，常见的思路就是**在组件库开发中，设计 examples 目录或者一个 playground，启动一个开发服务，以验证组件的运行情况**

- npm link 本质就是软链接，主要做了两件事

  - 为目标 npm 模块（npm-package 1）创建软链接，将其链接到全局 node 模块安装路径 /usr/local/lib/node_modules 中
  - 为目标 npm 模块（npm-package 1）的可执行 bin 文件创建软链接将其链接到全局 node 命令安装路径 /usr/local/bin 中

npx

- 可以直接执行 node_modules/.bin 文件夹下的文件
- 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在

npm 多源镜像和企业级部署私服原理

- 可是使用 preinstall 的钩子

  ```json
  {
    "script": {
      "preinstall": "node ./bin/preinstall.js"
    }
  }
  ```

  preinstall 脚本内容

  ```js
  require('child_process').exec('npm config get registry', function (error, stdout, stderr) { 
  	if (!stdout.toString().match(/registry\.x\.com/)) {
      exec('npm config set @xscope:registry https://xxx.com/npm/')
    }
  })
  ```

  **部署镜像后**，确保高速、稳定 npm 服务，使发布私有模块更加安全

  **审核机制**，保障私服上的 npm 模块质量和安全

- 如何部署一个私有 npm镜像

  nexus、verdaccio、cnpm

  ![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_Tba6AcJj0AAGPl9HW2qg745.png)

  > [聊聊 NPM 镜像那些险象环生的坑](https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ)

### yarn

- **确定性**：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的 [npm-shrinkwrap.json](https://docs.npmjs.com/cli/shrinkwrap)）
- 采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）
- 网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制
- 采用缓存机制，实现了离线模式（npm 目前也有类似实现）

`yarn cache dir`

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CgqCHl_ZflCANVu8AAJJZZYzwhs026.png)

检测包：

- 检测项目中是否存在一些 npm 相关文件，比如 package-lock.json

解析包：

- 首先获取当前项目中 package.json 定义的 dependencies、devDependencies 的内容，这属于首层依赖
- 接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析

![img](E:\learn\lagouBigFront\md\Engineering\img\CgqCHl_TbimACnDOAAFMC14gP8I289.png)

获取包

- 如何判断缓存中是否存在当前的依赖包

  yarn 会根据 cacheFolder + slug + node_modules + pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载

- 没有命中缓存的包，yarn 会维护一个 fetch 队列，按照规则进行网络请求

![img](E:\learn\lagouBigFront\md\Engineering\img\Ciqc1F_TbjKAThkOAAEsp0sOHUc622.png)

链接包

- 将项目中的依赖复制到项目 node_modules 下，遵循扁平化原则

![img](E:\learn\lagouBigFront\md\Engineering\img\Ciqc1F_Tbj2AWiPOAADyaZB-wGw502.png)

构建包：

- 依赖包中存在二进制包的进行编译

Yarn 在安装依赖时会自动执行 dedupe 命令。**整个优化的安装过程，就是上一讲提到的扁平化安装模式，也是需要你掌握的关键内容**

### CI

npm ci

- npm ci 要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json
- npm ci 完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖
- 正因为 npm ci 完全根据 package-lock.json 安装依赖，在安装过程中，它不需要计算求解依赖满足问题、构造依赖树，因此安装过程会更加迅速
- npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装
- npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包
- 如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles
- npm ci 永远不会改变 package.json 和 package-lock.json

一个 package-lock.json 的 dependency 主要由以下部分构成：

- version：依赖包的版本号
- resolved：依赖包安装源
- integrity：表明包完整性的 hash 值
- dev：该模块是否为顶级模块的开发依赖或者是一个传递依赖关系
- requires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项
- dependencies：依赖包 node_modules 中依赖的包

![image-20230227153124893](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230227153124893.png)

如果开发的库依赖了一个精确版本号的模块，那么提交 lockfiles 到仓库可能会造成同一个依赖不同版本都会被下载的情况

- 如果作为库开发者，真的有使用某个特定版本依赖的需要一个更好的定义方式是定义 peerDependencies

- 把 package-lock.json 一起提交到代码仓库中，不需要 ignore

  但是执行 npm publish 命令，发布一个库的时候，应该被忽略而不是直接发布出去

npm 设计的依赖类型声明：

- dependencies 项目依赖
- devDependencies 开发依赖
- peerDependencies 同版本依赖
- bundledDependencies 捆绑依赖
- optionalDependencies 可选依赖

peerDependencies

- 插件不能单独运行
- 插件正确运行的前提是核心依赖库必须下载安装
- 我们不希望核心依赖库重复下载
- 插件 API 的设计必须要符合核心依赖库的插件编写规范
- 在项目中，同一插件体系下，核心依赖库版本最好相同

SemVer 版本规范

### 构建工具

> [Tooling.Report](https://bundlers.tooling.report/)

![image-20230227162717413](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20230227162717413.png)

- Code Splitting

  **代码分割**，能够导出公共模块，避免重复打包，以及在页面加载运行时，实现最合理的按需加载策略

  - 不同模块间的代码分割机制能否支持不同的上下文环境（Web worker 环境等特殊上下文情况）
  - 如何实现对 Dynamic Import 语法特性的支持
  - 应用配置多入口/单入口时是否支持重复模块的抽取并打包，代码模块间是否支持 Living Bindings

- Hashing

  对打包资源进行版本信息映射，构建工具进行打包的前提就是对各个模块依赖关系进行分析，并根据依赖关系，支持开发者自定义哈希策略

  - hash 如果项目里某个模块发生更改，触发项目的重新构建，那么文件的 hash 值将会相应地改变
  - chunkhash 会根据入口文件（Entry）进行依赖解析
  - contenthash 则会根据文件具体内容，生成 hash 值

- Importing Modules

  **依赖机制**。一个构建工具的设计当然也就要兼容不同类型的 modules importing 方案

- Non-JavaScript Resources

  对其他非 JavaScript 类型资源导入的支持能力

- Output Module Formats

  构建输出内容的模块化方式也需要更加灵活，比如开发者可配置 ESM、CommonJS 等规范的构建内容导出

- Transformations

  我们在设计构建工具时，对于类似 JSX 的编译、.vue 文件的编译，不会内置到构建工具当中，而是利用 Babel 等社区能力，“无缝融合”到构建流程里

### Vite

找到 Vite 源码中，命令行实现部分

```js
if (!options.command || options.command === 'serve') {
  runServe(options)
} else if (options.command === 'build') {
  runBuild(options)
} else if (options.command === 'optimize') {
  runOptimize(options)
} else {
  console.error(chalk.red(`unknown command: ${options.command}`))
  process.exit(1)
}
```

