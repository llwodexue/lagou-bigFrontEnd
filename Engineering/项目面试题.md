## 拦截器

> [完整的Axios封装-单独API管理层、参数序列化、取消重复请求、Loading、状态码...](https://juejin.cn/post/6968630178163458084)

拦截器常用功能：

1. 封装实现配置化

2. 表单序列化（qs.stringify）

   表单序列化：`Content-Type: application/x-www-form-urlencoded`

3. 基础鉴权（jwt）

   无痛刷新Token：判断 Token 是否过期，没有过期正常处理。过期则发起刷新 Token 的请求，拿到新的 Token 进行保存，重新发送 Token 过期这段时间内发起的请求

   [前端无痛刷新Token](https://juejin.cn/post/7075348765162340383)

4. 接口报错捕获弹窗提示、报错重定向

5. 取消重复请求，两次重复请求间隔大于防抖时间（map、qs.stringify、cancelToken）

   场景：快速点击一个按钮（订单后端也会做幂等控制）、tab频繁切换

   [axios 拦截器配置重复请求取消](https://juejin.cn/post/7004721390767046686)

6. 全局 Loading

   [如何在 Axios 中去控制 Loading？大有学问！](https://mp.weixin.qq.com/s/R-drKObZrO2OOKiIKmj6MA)

   如果实现按钮 loading，需要给接口传入 ref 类

   - Axios 在接口调用传入的配置项和拦截器返回的配置项并不是同一个内存地址。ref 返回的对象是 RefImpl 类的实例，并不是普通的对象，Axios 深拷贝的时候没有处理该实例对象

7. 其他：国际化（Accpet-Language）、接口加解密

## 组件化

> [如何开发一个人人爱的组件?](https://mp.weixin.qq.com/s?__biz=MzUxNzk1MjQ0Ng==&mid=2247514450&idx=1&sn=318b462c6db6e2a1f2915fcf26e02305)

1. 注重 TypeScript API 定义

   - DOM 属性：className 可以使用 classnames 处理，data-xxx 可以直接对 props 类型做一个基础封装 `{ className?: string, style?: CSSProperties } & Record<'data-${string}', string>`
   - 类型注释：为组件暴露的类型添加规范的注释
   - 组件插槽：`{ label?: React.ReactNode }`
   - 受控于非受控：组件数据输入使用泛型规范
   - 表单类型、选择类型

2. 不应该引入副作用依赖，比如全局状态（Vuex、Redux）

3. 组件设计

   - 服务请求：很多场景来说，只是替换一下请求的 url
   - Hooks：对于业务组件需要传特殊参数可以使用 Hooks，保证逻辑高度复用性
   - Consumer：`({ isExpand }) => { return isExpand ? <Table /> : <AnotherTable /> }`

4. 文档设计

   注重 README 和 Mock

   注重 package.json 常见的入口定义，比如：main、module、types、exports

   ```json
   {
     "name": "xxx-ui",
     "version": "1.0.0",
     "description": "Out-of-box UI solution for enterprise applications from B-side.",
     "author": "yee.wang@xxx.com",
     "exports": {
       ".": {
         "import": "./dist/esm/index.js",
         "require": "./dist/cjs/index.js"
       }
     },
     "main": "./dist/cjs/index.js",
     "module": "./dist/esm/index.js",
     "types": "./dist/cjs/index.d.ts",
     "repository": {
       "type": "git",
       "url": "git@github.com:yee94/xxx.git"
     }
   }
   ```

## 多语言

多语言切换工作:

1. 模板中的内容，如 Vuejs 的 `template` 标签的文字内容
2. JS 代码中的文字内容
3. 图片中的文案内容
4. 页面 `title`
5. 第三方组件中的文案（Vux、Element）
6. 后端接口中需要展示到前端的数据内容
7. 后端接口返回的错误提示

基本思路：

1. 需要确定以什么样的方式来获取当前应该展示的语言

   - URL传递 `?lang=en`
   - localstorage、vuex 的 state

   优先级：地址栏参数、localstorage、navigator.language、默认语言

2. 采用什么工具来解决语言转换和打包问题

   - i18n 工具选择：vuex-i18n、vue-i18n、simplest-i18n。结合 i18n Ally 插件
   - 语言包怎么组织，怎么打包处理：yaml 支持多语言字段写在一起、json 更常见的配置文件（缺点：必须双引号、不可以出现注释）
     - 使用 json-loader 和 yaml-loader，将 yaml 转换成需要的 json 格式

3. 如何通知后端接口返回何种语言数据

   - 在 axios 的 interceptor 中给请求统一添加 header：`Accpet-Language`

4. 自定义组件多语言处理

   - 避免命名冲突：每个字段名字+组件名的前缀。对于页面标题和错误提示，可以单独新建 gloabl.yml 进行存储

5. 图片多语言处理

   1. 根据不同的语言展示不同的图片
   2. 尽量将文字从图片背景抽离出来，采用文字+图片背景方式处理

6. 点击切换如何更新页面内容

   1. 刷新页面
   2. watch 当前页 data 中的 lang 字段变化，通过 v-if 局部刷新相关组件
   3. 集合 vuex 派发全局语言状态

7. yaml 特殊字符转义

   - 使用单引号引起来。如果语言信息中有单引号，必须使用连续两个单引号转义

## 缓存

### 页面缓存

需求：列表页进入详情页后，切换回列表页，需要对列表页进行缓存，如果从首页进入列表页，就要重新加载列表页

- 想法：使用 keep-alive 缓存列表页，列表和详情页切换时，列表页会被缓存。从首页进入列表页时，就重置列表数据并重新获取数据达到列表重新加载效果
- 问题：如果列表页足够复杂，有下拉刷新、下拉加载，有弹框、有轮播，在清除缓存时就需要重置很多数据和状态，而且手动去销毁和重新加载某些组件，这样既增加了复杂度又容器出 bug

keep-alive 最大难题就是缓存清理，incldue 是可以用来清除缓存（将组件名添加到 include 里，组件会被缓存，移除组件名，缓存会被清除）

```js
const caches = ref([])
export default function useRouteCache() {
  function addCache(comName) {
    if (Array.isArray(comName)) return comName.forEach(addCache)
    if (!comName || caches.value.includes(comName)) return
    caches.value.push(comName)
  }
  function removeCache(comName) {
    const index = caches.value.indexOf(comName)
    if (index > -1) return caches.value.splice(index, 1)
  }
  async function removeCacheEntry(comName) {
    if (removeCache(comName)) {
      await nextTick()
      addCache(comName)
    }
  }
  return {
    caches,
    addCache,
    removeCache,
    removeCacheEntry
  }
}
```

列表页清除缓存时机：进入列表路由组件的 beforeRouteEnter 钩子中判断是否从其他页面进入，是则清除缓存，不是则使用缓存

- 缺点：但是这种缓存有个不友好的地方：当从首页进入列表页，列表页和详情页来回切换，列表页是缓存的；但是在首页和列表页间用浏览器的前进后退来切换时，我们更多的是希望列表页能保留缓存，就像在多页面中浏览器前进后退会缓存原页面一样的效果

```js
beforeRouteEnter((to, from) => {
  if (from.name === 'Home') {
    const { removeCacheEntry } = useRouteCache()
    removeCacheEntry('List')
  }
})
```

通过状态管理库存储页面的状态和数据也能实现页面缓存

- 缺点：状态多起来的话，会有点繁琐，而且状态写在 store 里肯定没有写在组件列表里来的直观。状态管理由于只做列表页数据的缓存，对于一些非受控组件来说，组件内部状态改变是缓存不了的，这就导致页面渲染后跟原来有差别，需要额外代码操作
- 引用第三方库，这时表单数据将由 DOM 节点处理，非受控组件不定义 value

> keep-alive 涉及到 LRU（least-recently-used） 缓存策略
>
> ```js
> class LRUCache {
>   constructor(max) {
>     this.max = max
>     this.cache = new Map()
>     this.keys = new Set()
>   }
>   get(key) {
>     if (this.cache.has(key)) {
>       this.keys.delete(key)
>       this.keys.add(key)
>       return this.cache.get(key)
>     } else {
>       return -1
>     }
>   }
>   set(key, value) {
>     if (this.cache.has(key)) {
>       this.keys.delete(key)
>     } else {
>       if (this.keys.size >= this.max) {
>         const leastUsedKey = this.keys.values().next().value
>         this.cache.delete(leastUsedKey)
>         this.keys.delete(leastUsedKey)
>       }
>     }
>     this.cache.set(key, value)
>     this.keys.add(key)
>   }
> }
> ```

### 数据缓存

响应式 localStorage

```js
function useMediator() {
  const topics = {}
  let uuid = 0
  const subscribe = (topic, callback) => {
    uuid++
    topics[topic] = topics[topic] ? [...topics[topic], { callback, uuid }] : [{ callback, uuid }]
  }
  const publish = (topic, ...args) => {
    if (topics[topic]) topics[topic].forEach(item => item.callback(...args))
  }
  return { subscribe, publish }
}
const sub = useMediator()

const keyMap = new Map()
export function useLocalStorage() {
  const getItem = key => {
    const value = localStorage.getItem(key)
    if (value == null) return null
    try {
      return JSON.parse(value)
    } catch (e) {
      return value
    }
  }
  const setItem = (key, value) => {
    if (!keyMap.get(key)) keyMap.set(key)
    sub.publish(key, value)
    localStorage.setItem(key, value)
  }
  const clear = () => {
    keyMap.forEach((val, key) => sub.publish(key, undefined))
    keyMap.clear()
    localStorage.clear()
  }
  const removeItem = key => {
    keyMap.delete(key)
    sub.publish(key, undefined)
    localStorage.removeItem(key)
  }
  return { getItem, setItem, clear, removeItem }
}

export function useStorage(key) {
  const string = ref(null)
  sub.subscribe(key, value => (string.value = value))
  return string
}
```

## 打包部署

1. 打包 `npm run build`

2. 同步到远端服务器

   ```bash
   # git-bash 或 powershell 使用 scp 命令
   scp -r dist/* root@1.1.1.1:/www
   # linux 开发还可以使用 rsync 命令
   rsync -avr --delete-after dist/* root@1.1.1.1:/www
   ```

   还有一个问题，就是执行命令时候要输入远程服务器的账号密码，可以将本机 ssh 同步到服务器的 `authorized_keys` 文件中

3. 同步 ssh key

   ```bash
   # 使用 ssh-keygen 生成 ssh key
   ssh-keygen
   # 同步 ssh key 到远程服务器
   ssh-copy-id -i ~/.ssh/id_rsa.pub root@1.1.1.1
   ```

4. 如果希望项目部署到 `http://a.com/test` 访问到的是项目的首页，而非 test 前缀的网址，可以配置 

   ```nginx
   location /test { 
     alias /www;
   }
   ```

   为了解决资源路径不对问题，需要配置 publicPath，有两种配置方式：`./`（打包后资源引用路径为相对路径） 或 `/test`（打包资源相对路径从域名根目录开始的绝对路径）

   注意：public 下的静态资源都不会被 webpack 处理，我们需要通过绝对路径来引用它们

   ```js
   Vue.prototype.$pb = process.env.BASE_URL // publicPath
   <img :src="`${$pb}static/logo.png`">
   ```

   关于静态资源，vue-cli 推荐尽量将该资源作为你的模块依赖图的一部分导入（存放到 assests 中，使用相对路径）

   - 脚本和样式表会被压缩并且打包在一起，从而避免额外的网络请求
   - 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误
   - 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本

5. history 模式部署

   假设项目部署到域名下的 /test 目录，访问 `http://xxx/test/about` 的时候，服务器会去找 `/test` 指向的目录下的 about 子目录或文件，很显然因为是单页面应用，并不会存在 about 这个目录或者文件，就会导致 404 错误。nginx 需要配置如下内容

   ```nginx
   location /test { 
     alias /www;
     try_files $uri $uri/ /test/index.html;
   }
   ```

## 服务端渲染

> [带你五步学会Vue SSR](https://juejin.cn/post/6844903688830468109)

### 不包含`Ajax`初始化数据

在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。

所以，我们要对 `app.js` 做修改，将其包装为一个工厂函数，每次调用都会生成一个全新的根组件

```js
import Vue from 'vue'
import App from './App.vue'

export function createApp() {
  const app = new Vue({
    render: h => h(App)
  })
  return { app }
}
```

在服务器端，我们就要返回一个函数，该函数的作用是接收一个 `context` 参数，同时每次都返回一个新的根组件。这个 `context` 在这里我们还不会用到，后续的步骤会用到它

```js
// entry-server.js
import { createApp } from './app.js'

export default context => {
  const { app } = createApp()
  return app
}
```

然后来看一下 `index.ssr.html` 这里 `<!--vue-ssr-outlet-->` 的作用是作为一个占位符，后续通过 `vue-server-renderer` 插件，将服务器解析出的组件 `html` 字符串插入到这里

```html
<!--vue-ssr-outlet-->
<script type="text/javascript" src="<%= htmlWebpackPlugin.options.files.js %>"></script>
```

服务端吐出来的就是一个 `html` 字符串，后续的 `Vue` 相关的响应式、事件响应等等，都需要浏览器端来接管，所以就需要将为浏览器端渲染打包的文件在这里引入。用官方的词来说，叫客户端激活（client-side hydration）

在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：

```js
app.$mount('#app')
```

这里有几个点需要注意一下：

1. 入口文件是 `entry-server.js`
2. 因为是打包服务器端依赖的代码，所以 `target` 要设为 `node`，同时，`output` 的 `libraryTarget` 要设为 `commonjs2`

```js
module.exports = {
  target: 'node',
  entry: {
    server: path.resolve(__dirname, '../src/entry-server.js')
  },
  output: {
    libraryTarget: 'commonjs2'
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../src/index.ssr.html'),
      filename: 'index.ssr.html',
      files: {
        js: 'client.bundle.js'
      },
      excludeChunks: ['server']
    })
  ]
}
```

server 端关于 http 服务代码

```js
const Router = require('koa-router')
const frontendRouter = new Router()

const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.bundle.js'), 'utf-8')
const renderer = require('vue-server-renderer').createBundleRenderer(bundle, {
  template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8')
})

backendRouter.get('/index', (ctx, next) => {
  // 这里用 renderToString 的 promise 返回的 html 有问题，没有样式
  renderer.renderToString((err, html) => {
    if (err) {
      console.error(err)
      ctx.status = 500
      ctx.body = '服务器内部错误'
    } else {
      console.log(html)
      ctx.status = 200
      ctx.body = html
    }
  })
})
```

### 包含Ajax初始化数据

先提出几个问题：

1. 服务端拿到异步数据的步骤在哪做？
2. 如果确定哪些组件需要获取异步数据？
3. 获取到异步数据之后要如何塞回组件内？

服务器端渲染和浏览器端渲染组件经过的生命周期是有区别的，**在服务器端，只会经历`beforeCreate`和`created`两个生命周期**。因为SSR服务器直接吐出`html`字符串就好了，不会渲染DOM结构，所以不存在`beforeMount`和`mounted`的，也不会对其进行更新，所以也就不存在`beforeUpdate`和`updated`等

在纯浏览器渲染的`Vue`项目中，我们是怎么获取异步数据并渲染到组件中的？一般是在`created`或者`mounted`生命周期里发起异步请求，然后在成功回调里执行`this.data = xxx`，`Vue`监听到数据发生改变，走后面的`Dom Diff`，打`patch`，做`DOM`更新

那么服务端渲染可不可以也这么做呢？**答案是不行的**

1. 在`mounted`里肯定不行，因为`SSR`都没有`mounted`生命周期，所以在这里肯定不行
2. 在`beforeCreate`里发起异步请求是否可以呢，也是不行的。因为请求是异步的，可能还没有等接口返回，服务端就已经把`html`字符串拼接出来了

可以这么做：

1. 在渲染前，要预先获取所有需要的异步数据，然后存到 `Vuex` 的 `store` 中
2. 在后端渲染时，通过 `Vuex` 将获取到的数据注入到相应组件中
3. 把 `store` 中的数据设置到 `window.__INITIAL_STATE__` 属性中
4. 在浏览器环境中，通过 `Vuex` 将 `window.__INITIAL_STATE__` 里面的数据注入到相应组件中

```js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

const fetchBar = function() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('bar 组件返回 ajax 数据')
    }, 1000)
  })
}
function createStore() {
  const store = new Vuex.Store({
    state: {
      bar: ''
    },
    mutations: {
      SET_BAR(state, data) {
        state.bar = data
      }
    },
    actions: {
      fetchBar({ commit }) {
        return fetchBar()
          .then(data => {
            commit('SET_BAR', data)
          })
          .catch(err => {})
      }
    }
  })
  if (typeof window !== 'undefined' && window.__INITIAL_STATE__) {
    console.log('window.__INITIAL_STATE__', window.__INITIAL_STATE__)
    store.replaceState(window.__INITIAL_STATE__)
  } else {
    console.log('no browser')
  }
  return store
}
export default createStore
```

因为 `store.js` 同样也会被打包到服务器运行的 `server.bundle.js` 中，所以运行环境不一定是浏览器，这里需要对 `window` 做判断，防止报错，同时如果有 `window.__INITIAL_STATE__` 属性，说明服务器已经把所有初始化需要的异步数据都获取完成了，要对`store`中的状态做一个替换，保证统一

我们通过导出的 `App` 拿到了所有它下面的 `components`，然后遍历，找出哪些 `component` 有 `asyncData` 方法，有的话调用并传入 `store`，该方法会返回一个`Promise`，我们使用 `Promise.all` 等所有的异步方法都成功返回，才 `resolve(app)`

`context.state = store.state` 作用是，当使用 `createBundleRenderer` 时，如果设置了`template`选项，那么会把 `context.state` 的值作为 `window.__INITIAL_STATE__` 自动插入到模板 `html` 中

```js
import { createApp } from './app.js'

export default context => {
  return new Promise((resolve, reject) => {
    const { app, store, App } = createApp()
    let components = App.components
    let asyncDataPromiseFns = []
    Object.values(components).forEach(component => {
      if (component.asyncData) {
        asyncDataPromiseFns.push(component.asyncData({ store }))
      }
    })
    Promise.all(asyncDataPromiseFns).then(result => {
      // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中
      resolve(app)
    }, reject)
  })
}
```

