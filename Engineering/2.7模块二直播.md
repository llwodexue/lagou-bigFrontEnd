## 脚手架生成文件

在封装脚手架时，需要考虑模块中用到的依赖包装一层，让模板依赖所包装的模板（让模板依赖不变的东西）

> [https://cli.vuejs.org/zh/guide/webpack.html](https://cli.vuejs.org/zh/guide/webpack.html)

vue-cli 调整 webpack 的配置

- 配置方式：在 `vue.config.js` 中的 `configureWebpack` 选项提供一个对象，这个对象会被 `webpack-merge` 合并入最终的 webpack 配置
- 链式操作：内部是通过 `webpack-chain` 维护的，它允许我们更细粒度的控制其内部配置

> [https://create-react-app.bootcss.com/docs/available-scripts#npm-run-eject](https://create-react-app.bootcss.com/docs/available-scripts#npm-run-eject)

create-react-app 可以在项目根目录执行 `npm run eject` 提取内置配置

- 默认跟 vue-cli 一样把 webpack 配置包装到一个黑盒中，使用 `react-scripts eject` 后就把 webpack 配置拿到了本地

## 多页面打包

最早都是使用 MPA，只是在一些应用场景下必须实现 SPA，例如网易云音乐之类的产品，具体原因：音乐播放，如果都是不同的页面，从 A 页面跳转到 B 页面过后，音乐如何继续播放。再者就是一些关联性比较强的页面，例如：商品列表和商品明细，希望通过 SPA 提升用户使用上的体验

但是也并不是所有应用都需要做成 SPA 应用的，例如：活动页、专题页，每隔一段时间，上线一个新产品，就会单独出一个专题页

`chunk` 和 `bundle` 的关系：

- 一次打包时可能有多个 `chunk`
- 一次打包的结果就是一个 `bundle`

## 不同环境下的环境变量

使用不同的 `.env` 文件控制，一般在项目根目录下会添加 `.env.development`、`.env.test`、`.env.production` 这样的环境变量配置文件

- vue-cli：只有 `NODE_ENV`、`BASE_URL`、`VUE_APP_` 开头的变量才会通过 `webpack.definePlugin` 静态地嵌入到客户端的代码中，这是为了避免意外公开机器上可能具有相同名称的私钥
- create-react-app：要求环境变量需要以 `REACT_APP_` 开头

执行 webpack 打包时通过 `NODE_ENV` 控制具体使用哪一个环境，然后 webpack 配置文件使用 `dotenv` 读取对应环境配置，通过 `DefinePlugin` 注入

## Webpack 面试会考到的点

1. webpack 的价值体现、你对 webpack 的看法

2. webpack 与 gulp、grunt 之类工具的差异

   三者都是前端构建工具，严格来说 webpack 是模块打包工具，Grunt 和 Gulp 是自动化构建工具

   grunt 和 gulp 是基于任务和流的。Grunt 工作过程是基于临时文件实现的（编译后将结果写入到临时文件，下一个插件直接读取这个临时文件进行操作）。Gulp 是基于内存实现的，对文件的处理都是在内存中完成

   Webpack 作为 **模块打包器（Module bundler）**，可以把零散的文件打包到一个 JS 中，对于有环境兼容的代码可以在打包过程中通过 **模块加载器（Loader）** 对其进行编译转换；Webpack 还具备 **代码拆分（Code Splitting）** 能力，将应用中所有代码按照我们的需要进行打包，这样就可以渐进式加载，不会导致文件过碎或过大；Webpack 支持以模块化的方式载入任意类型文件，通过 **资源模块（Asset Module）**

3. Loader 与 Plugin 之间的差异

   Loader 文件资源转换器，在模块打包之前，会将模块根据配置交给不同的 Loader 处理。Loader 主要负责资源文件从输入到输出的转换，实际上是一种管道的概念，对于同一个资源可以依次使用多个 Loader（use 属性的值是一个由 Loader 组成的数组）

   Plugin 扩展器，为了解决资源加载的一些自动化工作。Plugin 通过钩子机制实现，通过在生命周期的钩子中挂载函数实现扩展

4. 用过的 Loader 和 Plugin（以此来判断你遇到过的问题）

   **Loader**

   - `css-loader`：读取、合并 CSS 文件

     `style-loader`：把 CSS 注入到 JS 中

     `sass-loader`：解析 SASS 文件（安装 `node-sass` 或 `sass`）

     `postcss-loader`：浏览器兼容

   - `file-loader`：拷贝物理文件

     `url-loader`：Data Urls 展示文件

   - `babel-loader`：兼容 JS

     `thread-loader`：由于 `babel-loader` 消耗时间比较长，可以使用 `thread-loader` 对其优化

   **Plugin**

   - `mini-css-extract-plugin`：提取 CSS 到单个文件

     `optimize-css-assets-webpack-plugin` 或 `optimize-cssnano-plugin`：压缩 CSS

   - `terser-webpack-plugin` 或 `uglifyjs-webpack-plugin`：压缩 JS

   - `html-webpack-plugin`：自动生成 html 解决硬编码问题

   - `copy-webpack-plugin`：拷贝一些不参与构建的静态文件

   - `clean-webpack-plugin`：清除 dist 目录文件

   - `DefinePlugin`：webpack 内部，为代码注入全局成员

5. Tree-shaking、sideEffects

6. Source Map 的最佳实践

   - `source-map` 文件访问权健，对于 map 这一类文件只允许局域网访问
   - `nosources-source-map` 可以结合监控平台来做
   - `hidden-source-map` 只暴露行列信息，不暴露源代码

7. webpack 的核心工作过程

8. 文件名 hash（文件指纹）控制缓存

9. webpack 如何打包优化

   [记一次前端面试记录（头条、蚂蚁）](https://juejin.cn/post/6844904138359193608#heading-2)

解答思路：

1. 定义
2. 实践
3. 实践中出现的问题、解决办法