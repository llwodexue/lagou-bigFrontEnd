## 模块化工具

**由来**

- ES Modules 存在环境兼容问题
- 模块文件过多，网络请求频繁
- 所有的前端资源都需要模块化

![开发到生产-编译代码](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81.png)

![开发到生产-模块带包](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E6%A8%A1%E5%9D%97%E5%B8%A6%E5%8C%85.png)

![开发到生产-多类型模块支持](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81.png)

**概要**

![webpackRollup](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpackRollup.png)

- Webpack 作为 **模块打包器（Module bundler）**，可以把零散的文件打包到一个 JS 中，对于有环境兼容的代码可以在打包过程中通过 **模块加载器（Loader）** 对其进行编译转换
- Webpack 还具备 **代码拆分（Code Splitting）** 能力，将应用中所有代码按照我们的需要进行打包，这样就可以渐进式加载，不会导致文件过碎或过大
- Webpack 支持以模块化的方式载入任意类型文件，通过 **资源模块（Asset Module）**

## Webpack

### 快速上手

`yarn webpack` 会先从 `src/index.js` 打包

```bash
yarn init --yes
yarn add webpack webpack-cli --dev
yarn webpack
```

打包的过程会按照约定将 `src/index.js` 作为打包入口，最终存放在 `dist/main.js` 里，可以添加 `webpack.config.js` 进行配置

- 这个文件是运行在 Node 环境的 JS 文件，我们需要按照 CommonJS 方式编写代码

```js
const path = require('path')

module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'output')
  }
}
```

**Webpack 工作模式**

> [webpack mode](https://webpack.js.org/configuration/mode/)
>
> [webpack4 mode](https://v4.webpack.js.org/configuration/mode/)

- production 模式，自动优化打包结果
- development 模式，自动优化打包速度，添加一些调试过程中的辅助
- none 模式，运行最原始的打包，不做任何额外处理

### 打包结果运行原理

`Ctrl + K` + `Ctrl + 0` 折叠所有代码

![webpack打包运行原理1](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%861.png)

`modules` 接收的就是那两个模块所对应的函数

![webpack打包运行原理2](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%862.png)

调用 `require` 函数进入模块入口

![webpack打包运行原理4](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%864.png)

## Loader

- 编译转换类
- 文件操作类
- 代码检查类

### 资源模块加载

Webpack 在所有模块打包之前，将模块根据配置交给不同的 loader 去处理，最后将处理的结果打包到一起

```bash
yarn add css-loader style-loader --dev
```

配置了多个 loader 执行顺序是从后往前

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.css$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
}
```

根据代码的需要动态导入资源，需要资源的不是应用，而是代码

![webpack导入资源模块](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E5%AF%BC%E5%85%A5%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9D%97.png)

通过 JavaScript 建立 JS 与资源文件依赖关系

- 逻辑合理，JS 确实需要这些资源文件
- 确保上线资源不缺失，都是必要的

```js
import './heading.css'

export default () => {
  const element = document.createElement('h2')
  element.textContent = 'Hello world'
  element.classList.add('heading')
  element.addEventListener('click', () => {
    alert('Hello webpack')
  })
  return element
}
```

### 文件资源加载器

```bash
yarn add file-loader --dev
```

`webpack-dev-server` 在不设置 `publicPath` 的情况下，将默认输出 `bundle.js` 到根目录

```js
module.exports = {
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
    publicPath: 'dist/',
  },
  module: {
    rules: [
      {
        test: /.png$/,
        use: 'file-loader',
      },
    ],
  },
}
```

![文件加载器打包代码](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%93%E5%8C%85%E4%BB%A3%E7%A0%81.png)

![文件加载器图例](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9B%BE%E4%BE%8B.png)

URL 加载器

除了 `file-loader` 通过拷贝物理文件形式处理文件，还可以通过 `Data URLs` 方式表示文件

![DataURLs类型格式](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/DataURLs%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F.png)

```bash
yarn add url-loader --dev
```

- 小文件使用 Data URLs，减少请求次数
- 大文件单独提取存放，提高加载速度

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            limit: 10 * 1024 // 10 KB
          }
        }
      }
    ]
  }
}
```

![DataURLbase64](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/DataURLbase64.png)

### ES 2015

由于 webpack 默认就能处理代码中的 `import` 和 `export`，所以有可能会认为 webpack 会自动编译 ES6 代码，实则不然，它并不能转换代码中其它 ES6 语法

```bash
yarn add babel-loader @babel/core @babel/preset-env --dev
```

- webpack 只是打包工具
- 加载器可以用来编译转换代码

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
    ]
  }
}
```

### Webpack 模块加载方式

- 遵循 ES Modules 标准的 `import` 声明

![](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/ESModulesImport.png)

- 遵循 CommonJS 标准的 `require` 函数

![](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CommonJSRequire.png)

- 遵循 AMD 标准的 `define` 函数和 `require` 函数

![AMDrequireDefine](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/AMDrequireDefine.png)

代码中所有需要引用到的资源，都会被 webpack 找出来，根据配置交给不同的 loader 去处理

```html
<style>
/*  */
@import url(reset.css);
</style>

```

- 样式代码中的 `@import` 指令和 url 函数
- HTML 代码中图片标签的 src 属性

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            limit: 10 * 1024, // 10 KB
          },
        },
      },
      {
        test: /.html$/,
        use: {
          loader: 'html-loader',
          options: {
            attrs: ['img:src', 'a:href'],
          },
        },
      },
    ],
  },
}
```

## webpack 核心原理

webpack 会找到其中文件作为打包入口

- 根据代码中的 `import` 或 `require` 的语句解析，推断出来依赖模块，然后解析每个模块的资源依赖，形成依赖树
- 递归依赖树，找到每个节点对应的资源文件，然后根据每个模块的 `rules` 属性找到对应的加载器，然后进行加载，把加载的结果放入 `bundle.js`

![webpack核心原理](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.png)

### Loader 工作原理

Loader 负责资源文件从输入到输出的转换，Loader 实际上是一种管道的概念，对于同一个资源可以依次使用多个 Loader

- loader 配置文件中配置加载器（加载器 use 不仅可以用名字也可以用路径）
- 注意：loader 管道最终需要返回 JavaScript 代码

![loader文件转换流程](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/loader%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B.png)

- 可以借助其他 loader 进行处理，使其转换为 JavaScript 代码

```js
// markdown-loader.js
const marked = require('marked')
module.exports = source => {
  const html = marked(source)
  // 返回 html 字符串交给下一个 loader 处理
  return html
}

// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /.md$/,
        use: ['html-loader', './markdown-loader'],
      },
    ],
  },
}
```

- 可以将 html 转换成 JavaScript 字符串导出

  ``module.exports = "${html}"`` html 中的换行符、引号拼接到一起会造成语法错误，可以使用 `JSON.stringify(html)`

```js
const marked = require('marked')
module.exports = source => {
  const html = marked(source)
  // return `module.exports = "${html}"`
  return `export default ${JSON.stringify(html)}`
}

// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /.md$/,
        use: './markdown-loader',
      },
    ],
  },
}
```

### Plugin 插件机制

- 增强 webpack 自动化能力

Loader 专注实现资源模块加载，从而实现整体项目的打包，Plugin 为了解决除了资源加载的一些自动化工作，例如：清除 dist 目录、拷贝静态文件至输出目录、压缩输出代码

**自动清除输出目录**

- `clean-webpack-plugin`

```bash
yarn add clean-webpack-plugins --dev
```

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  plugins: [new CleanWebpackPlugin()]
}
```

**自动生成 HTML 插件**

```html
<script src="dist/bundle.js"></script>
```

之前都是硬编码的方式单独存在根目录下，这样有两个问题：

- 项目发布时需要同时发布根目录下的 html 和 dist 目录下所有打包结果，上线后还要确保路径正确
- 输出的文件或路径发生改变，那么 html 中的 script 的路径也要修改

解决方法：用 webpack 自动生成，一起输出到 dist 目录，`index.html` 中的 `bundle.js` 也是动态的，这样就不会出现硬编码问题

```bash
yarn add html-webpack-plugin --dev
```

- 注意：把 `output: { publicPath: 'dist' }` 给删除掉

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  plugins: [new HtmlWebpackPlugin()]
}
```

接下来有这几个问题：

- 默认生成 HTML 标题需要修改

  ```html
  <h1><%= htmlWebpackPlugin.options.title %></h1>
  ```

- 自定义页面元数据标签和基础 DOM 结构

  如果要对 HTML 进行大量自定义，更好的方法是根据模板生成页面

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  plugins: [
    // 用于生成 index.html
    new HtmlWebpackPlugin({
      title: 'Webpack Plugin Sample',
      meta: {
        viewport: 'width=device-width'
      },
      template: './src/index.html'
    })
  ]
}
```

输出多个 HTML

- 每个 `html-webpack-plugin` 对象就是负责生成一个页面文件

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  plugins: [
    // 用于生成 index.html
    new HtmlWebpackPlugin({
      title: 'Webpack Plugin Sample',
      meta: {
        viewport: 'width=device-width'
      },
      template: './src/index.html'
    }),
    // 用于生成 about.html
    new HtmlWebpackPlugin({
      filename: 'about.html'
    })
  ]
}
```

**自动复制文件**

项目中还有一些不参与构建的静态文件，例如网站 `favicon`，可以把其放到 `public` 目录中，一并打包

```bash
yarn add copy-webpack-plugin --dev
```

`CopyWebpackPlugin` 要求我们传入一个数组用于指定文件的拷贝路径，可以是通配符也可以是文件路径

```js
const CopyWebpackPlugin = require('copy-webpack-plugin')

module.exports = {
  plugins: [
    new CopyWebpackPlugin([
      // 'public/**'
      'public'
    ])
  ]
}
```

### 开发一个插件

> [Compiler Hooks](https://webpack.js.org/api/compiler-hooks/)
>
> [webpack4 Compiler Hooks ](https://v4.webpack.js.org/api/compilation-hooks/)
>
> [compiler 钩子](https://www.webpackjs.com/api/compiler-hooks/)

相比于 Loader，Plugin 拥有更宽的能力范围

- Plugin 通过钩子机制实现

  钩子机制，类似于 web 的事件，为了便于插件扩展，webpack 在每个环节都设置了钩子

![webpack钩子机制](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E9%92%A9%E5%AD%90%E6%9C%BA%E5%88%B6.png)

webpack 要求插件必须是一个函数或者是一个包含 `apply` 方法的对象，一般会把插件定义成一个类，在类上定义一个 `apply` 方法

- 里面有 `emit` 的钩子，在生成资源到 `output` 目录之前执行

通过在生命周期的钩子中挂载函数实现扩展

```js
class MyPlugin {
  // 在 webpack 启动时自动调用
  apply(compiler) {
    /**
     * @param1 插件名称
     * @param2 挂载的函数
     */
    compiler.hooks.emit.tap('MyPlugin', compilation => {
      // compilation => 可以理解为此次打包的上下文
      for (const name in compilation.assets) {
        if (name.endsWith('.js')) {
          const contents = compilation.assets[name].source()
          const withoutComments = contents.replace(/\/\*\*+\*\//g, '')
          compilation.assets[name] = {
            source: () => withoutComments,
            size: () => withoutComments.length
          }
        }
      }
    })
  }
}

module.exports = {
  plugins: [new MyPlugin()]
}
```

## webpack 开发环境

设想一下开发环境

1. 以 HTTP Server 运行
2. 自动编译 + 自动刷新
3. 提供 Source Map 支持

### 自动编译刷新

**自动编译**

```bash
yarn webpack --watch
```

**自动刷新浏览器**

- 同时使用两个工具效率低下，webpack 编译后写入磁盘，服务器从磁盘读取

```bash
browser-sync dist --files "**/*"
```

**Dev Server**

- 集成 自动编译 和 自动刷新浏览器 等功能

  webpack 为了提高效率，并没有输出 dist 目录，而是将结果暂存到内存中，而 server 是从内存读取文件，然后发送给浏览器，提高效率

```bash
yarn add webpack-dev-server --dev
```

- `CopyWebpackPlugin` 一般只有上线才会使用这个插件，开发如果拷贝得多，效率就低了

  需要在

- 注释掉 `CopyWebpackPlugin` 就需要在 `devServer` 配置 `contentBase`

```js
module.exports = {
  devServer: {
    contentBase: './public',
  },
  plugins: [
    // new CopyWebpackPlugin(['public'])
  ]
}
```

### Dev Server 代理

![webpackDevServerApi](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpackDevServerApi.png)

- 使用 CORS 的前提是 API 必须支持，并不是任何情况下 API 都应该支持

- 希望访问路径 `https://api.github.com/users`

  配置 `target` 后转换：`http://localhost:8080/api/users -> https://api.github.com/api/users`

  因为根路径没有 `/api`，所以需要使用 `pathRewrite` 重写：`http://localhost:8080/api/users -> https://api.github.com/users`

- `changeOrigin: true` 会以实际代理请求过程中的主机名进行请求，不会使用 `localhost: 8080`

```js
module.exports = {
  devServer: {
    contentBase: './public',
    proxy: {
      '/api': {
        target: 'https://api.github.com',
        pathRewrite: {
          '^/api': ''
        },
        // 不能使用 localhost:8080 作为请求 GitHub 的主机名
        changeOrigin: true
      }
    }
  },
}
```

```js
fetch('/api/users') // http://localhost:8080/api/users
  .then(res => res.json())
  .then(data => {
    data.forEach(item => {
      const li = document.createElement('li')
      li.textContent = item.login
      ul.append(li)
    })
  })
```

### Source Map

- 调式和报错都是基于运行代码，但是运行代码与源代码又不同

```js
module.exports = {
  devtool: 'source-map',
}
```

![SourceMap对应表](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/SourceMap%E5%AF%B9%E5%BA%94%E8%A1%A8.png)
