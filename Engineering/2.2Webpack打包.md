## 模块化工具

**由来**

- ES Modules 存在环境兼容问题
- 模块文件过多，网络请求频繁
- 所有的前端资源都需要模块化

![开发到生产-编译代码](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81.png)

![开发到生产-模块带包](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E6%A8%A1%E5%9D%97%E5%B8%A6%E5%8C%85.png)

![开发到生产-多类型模块支持](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E5%BC%80%E5%8F%91%E5%88%B0%E7%94%9F%E4%BA%A7-%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81.png)

**概要**

![webpackRollup](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpackRollup.png)

- Webpack 作为 **模块打包器（Module bundler）**，可以把零散的文件打包到一个 JS 中，对于有环境兼容的代码可以在打包过程中通过 **模块加载器（Loader）** 对其进行编译转换
- Webpack 还具备 **代码拆分（Code Splitting）** 能力，将应用中所有代码按照我们的需要进行打包，这样就可以渐进式加载，不会导致文件过碎或过大
- Webpack 支持以模块化的方式载入任意类型文件，通过 **资源模块（Asset Module）**

## Webpack

### 快速上手

`yarn webpack` 会先从 `src/index.js` 打包

```bash
yarn init --yes
yarn add webpack webpack-cli --dev
yarn webpack
```

打包的过程会按照约定将 `src/index.js` 作为打包入口，最终存放在 `dist/main.js` 里，可以添加 `webpack.config.js` 进行配置

- 这个文件是运行在 Node 环境的 JS 文件，我们需要按照 CommonJS 方式编写代码

```js
const path = require('path')

module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'output')
  }
}
```

**Webpack 工作模式**

> [webpack mode](https://webpack.js.org/configuration/mode/)
>
> [webpack4 mode](https://v4.webpack.js.org/configuration/mode/)

- production 模式，自动优化打包结果
- development 模式，自动优化打包速度，添加一些调试过程中的辅助
- none 模式，运行最原始的打包，不做任何额外处理

### 打包结果运行原理

`Ctrl + K` + `Ctrl + 0` 折叠所有代码

![webpack打包运行原理1](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%861.png)

`modules` 接收的就是那两个模块所对应的函数

![webpack打包运行原理2](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%862.png)

调用 `require` 函数进入模块入口

![webpack打包运行原理4](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%864.png)

## Loader

- 编译转换类
- 文件操作类
- 代码检查类

### 资源模块加载

Webpack 在所有模块打包之前，将模块根据配置交给不同的 loader 去处理，最后将处理的结果打包到一起

```bash
yarn add css-loader style-loader --dev
```

配置了多个 loader 执行顺序是从后往前

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.css$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
}
```

根据代码的需要动态导入资源，需要资源的不是应用，而是代码

![webpack导入资源模块](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E5%AF%BC%E5%85%A5%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9D%97.png)

通过 JavaScript 建立 JS 与资源文件依赖关系

- 逻辑合理，JS 确实需要这些资源文件
- 确保上线资源不缺失，都是必要的

```js
import './heading.css'

export default () => {
  const element = document.createElement('h2')
  element.textContent = 'Hello world'
  element.classList.add('heading')
  element.addEventListener('click', () => {
    alert('Hello webpack')
  })
  return element
}
```

### 文件资源加载器

```bash
yarn add file-loader --dev
```

`webpack-dev-server` 在不设置 `publicPath` 的情况下，将默认输出 `bundle.js` 到根目录

```js
module.exports = {
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
    publicPath: 'dist/',
  },
  module: {
    rules: [
      {
        test: /.png$/,
        use: 'file-loader',
      },
    ],
  },
}
```

![文件加载器打包代码](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%93%E5%8C%85%E4%BB%A3%E7%A0%81.png)

![文件加载器图例](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9B%BE%E4%BE%8B.png)

URL 加载器

除了 `file-loader` 通过拷贝物理文件形式处理文件，还可以通过 `Data URLs` 方式表示文件

![DataURLs类型格式](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/DataURLs%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F.png)

```bash
yarn add url-loader --dev
```

- 小文件使用 Data URLs，减少请求次数
- 大文件单独提取存放，提高加载速度

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            limit: 10 * 1024 // 10 KB
          }
        }
      }
    ]
  }
}
```

![DataURLbase64](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/DataURLbase64.png)

### ES 2015

由于 webpack 默认就能处理代码中的 `import` 和 `export`，所以有可能会认为 webpack 会自动编译 ES6 代码，实则不然，它并不能转换代码中其它 ES6 语法

```bash
yarn add babel-loader @babel/core @babel/preset-env --dev
```

- webpack 只是打包工具
- 加载器可以用来编译转换代码

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
    ]
  }
}
```

### Webpack 模块加载方式

- 遵循 ES Modules 标准的 `import` 声明

![](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/ESModulesImport.png)

- 遵循 CommonJS 标准的 `require` 函数

![](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/CommonJSRequire.png)

- 遵循 AMD 标准的 `define` 函数和 `require` 函数

![AMDrequireDefine](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/AMDrequireDefine.png)

代码中所有需要引用到的资源，都会被 webpack 找出来，根据配置交给不同的 loader 去处理

```html
<style>
/*  */
@import url(reset.css);
</style>

```

- 样式代码中的 `@import` 指令和 url 函数
- HTML 代码中图片标签的 src 属性

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.png$/,
        use: {
          loader: 'url-loader',
          options: {
            limit: 10 * 1024, // 10 KB
          },
        },
      },
      {
        test: /.html$/,
        use: {
          loader: 'html-loader',
          options: {
            attrs: ['img:src', 'a:href'],
          },
        },
      },
    ],
  },
}
```

## webpack 核心原理

webpack 会找到其中文件作为打包入口

- 根据代码中的 `import` 或 `require` 的语句解析，推断出来依赖模块，然后解析每个模块的资源依赖，形成依赖树
- 递归依赖树，找到每个节点对应的资源文件，然后根据每个模块的 `rules` 属性找到对应的加载器，然后进行加载，把加载的结果放入 `bundle.js`

![webpack核心原理](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.png)

### Loader 工作原理

Loader 负责资源文件从输入到输出的转换，Loader 实际上是一种管道的概念

- loader 配置文件中配置加载器（加载器 use 不仅可以用名字也可以用路径）
- 注意：loader 管道最终需要返回 JavaScript 代码

![loader文件转换流程](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/loader%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B.png)

- 可以借助其他 loader 进行处理，使其转换为 JavaScript 代码

```js
// markdown-loader.js
const marked = require('marked')
module.exports = source => {
  const html = marked(source)
  // 返回 html 字符串交给下一个 loader 处理
  return html
}

// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /.md$/,
        use: ['html-loader', './markdown-loader'],
      },
    ],
  },
}
```

- 可以将 html 转换成 JavaScript 字符串导出

  ``module.exports = "${html}"`` html 中的换行符、引号拼接到一起会造成语法错误，可以使用 `JSON.stringify(html)`

```js
const marked = require('marked')
module.exports = source => {
  const html = marked(source)
  // return `module.exports = "${html}"`
  return `export default ${JSON.stringify(html)}`
}

// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /.md$/,
        use: './markdown-loader',
      },
    ],
  },
}
```

