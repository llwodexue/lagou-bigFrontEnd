## 架构工作流

在浏览器使用 Performance 查看到 render 调用栈，整个 render 调用栈就是首屏渲染的流程

![image-20240313171333318](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240313171333318.png)

可以从调用栈发现

- 首次执行 `ReactDOM.render` 时，会创建整个应用的根节点 FiberRootNode
- 当创建完根 Fiber 节点时，接下来就会进入首屏渲染

![image-20240313172415948](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240313172415948.png)

在 react 内部，协调器执行的工作流程被称为 render 阶段，渲染器工作流程被称为 commit 阶段

- render 阶段，根据组件返回的 jsx 在内存中依次创建 Fiber 节点，被称为 workInProgress Fiber 树
- 构建完的 workInProgress Fiber 树在 commit 阶段渲染到页面

![image-20240314084848144](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240314084848144.png)

## 深入理解JSX

1. JSX 与 Fiber 的关系
2. React Component 与 React Element 的关系

React Element 就是 `React.createElement` 调用返回结果

![image-20240315105739368](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240315105739368.png)

进入知乎页面，输入 `__REACT_DEVTOOLS_GLOBAL_HOOK__`，找到 `renders` 点开 `findHostInstanceByFiber`

![image-20240315143821170](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240315143821170.png)

搜索 `createElement`，看 Global 变量发现全局有 React 对象

![image-20240315144257528](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240315144257528.png)

```js
createElement = React.createElement
React.createElement = (type, ...args) => {
  if (type === 'div') type = 'span'
  return createElement(type, ...args)
}
```

## 递阶段mount流程

搜索 beginWork 和 completeWork，并增加断点

WorkTag -> `HostRoot = 3`

![image-20240318104146719](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318104146719.png)

下一个进入 beginWork 节点就没有 current

- 首屏渲染只有当前应用的根节点存在 current

![image-20240318104321804](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318104321804.png)

进入节点为 App

![image-20240318104516283](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318104516283.png)

看一下代码结构

![image-20240318104609275](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318104609275.png)

img 为单闭合标签没有子节点，会执行 completeWork

![image-20240318104729417](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318104729417.png)

调试到 code 的时候，发现 code 其实是有子节点的，但是还是直接进入到了 completeWork

- 因为 React 对于只有唯一文本子节点的节点做了优化，这种情况下文本节点不会生成自己的 Fiber 节点

![image-20240318112326509](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318112326509.png)

**ReactFiberFlags**

![image-20240318152232625](https://gitee.com/lilyn/pic/raw/master/md-img/image-20240318152232625.png)

为什么用二进制形式表示 effectTags？

- 如果有一个 Fiber 节点，它对应的 DOM 节点，首先需要插入到页面中，其次需要更新它的属性，它需要同时存在 Placement 和 Update 两个 effectTags，使用二进制会很方便解决

```js
const NoFlags = /*        */ 0b000000000000000000;
const Placement = /*      */ 0b000000000000000010;
const Update = /*         */ 0b000000000000000100;

let effectTag = NoFlags
0
effectTag |= Placement
2
effectTag |= Update
6
```

当某一个 Fiber 节点进入 beginWork 时，它最终的目的是创建当前 Fiber 节点的第一个子 Fiber 节点

- 首先判断当前 Fiber 节点的类型，进入不同 update 的逻辑
- 其次在 update 逻辑中它会判断 workInProgress Fiber 是否存在 current Fiber 来决定是否标记 effectTag

## 归阶段mount流程

render 递阶段就是采用深度优先遍历方式依次执行 Fiber 节点的 beginWork 以及 completeWork
