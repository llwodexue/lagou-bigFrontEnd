**从低代码搭建的落地场景：**

1. 展示型：营销活动/广告宣传/大屏展示
2. 功能型（和和数据库交道）：中后台页面的快速落地、列表/表单的快速搭建
3. 互动型：游戏引擎

**从技术实现角度来看：**

**（no-code + low code）** 已经成为趋势，通常研发需要自定义一些数据结构、DSL、Schema、渲染器；

**从使用人员：**

- 运营/产品：基于平台进行拖拽 or 表单
- 研发：基于平台通过 low code or pro code（二开） 去进行页面的开发配置

## 整体架构

![image-20220914093524593](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914093524593.png)

从下往上看，是能力分层的结构：

1. **底层**：服务依赖，可以按活动的四个生命周期分为四大类：活动配置中：（规则引擎：比如周一只能用 KFC 的汉堡优惠券，周二只能用可乐优惠券，规则引擎对于低代码来说是比较重要的一环）投放时：**依拖低代码为各个投放系统快速搭建广告投放页面；**运行时：和用户行为相关，比如行为系统、任务系统；活动结束后：（我们也有归因平台、数据统计平台做一些数据分析）。
2. **第二层：**是前端的一些底层能力
3. **基于前后端的能力**，我们第三层打造了核心支撑：**活动编辑器、组件市场、WebIDE**、平行的有一层 Node 服务：做一些 BFF 功能、前端打包构建，连接数据库提供接口能力。就基本上 node 能干的都会在这里有所体现。
4.  **最上层应用层**，涵盖两部分：一部分是中后台，运营管理活动(页面搭建 + 生命周期的管理)。他提供了模版、权限、审核等能力。第二部分是活动 C 端：基于自研的 mix 框架SSR/CSR/SSG 三种渲染模式、基于不同的流量场景，选择投放的渲染模式。

**橘色的安全管控**：

1. 风险人群管控，防止在抽奖活动类的一些薅羊毛的行为
2. 产物扫描/敏感词，主要是针对写码的防范；安全团队会定时进行扫描。

**最后一部分是监控体系**：从：**性能/异常/QPS/内存/异常** 进行全链路监控

## 三大马车

![image-20220914094500709](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914094500709.png)

**WebIDE 入码**：这部分主要是给前端伙伴使用，在这个平台可以书写 React 的组件

**NodeServer**：主要对 WebIDE 的入码进行打包。并且提供给微组件的接口能力（包括市场列表、详情、更新等接口）

**微组件市场**：则提供了出码的组件预览、版本管理等能力

**活动平台**：主要是给运营使用，可以进行活动管理，页面搭建、并且可以通过微组件选取组件

### 运营使用

**步骤一**

![image-20220914101309245](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914101309245.png)

**步骤二**

![image-20220914101350814](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914101350814.png)

**步骤三**

![image-20220914101425586](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914101425586.png)

**步骤四**

![image-20220914101452578](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914101452578.png)

### 快速开发

![image-20220914100905753](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914100905753.png)

**优点：**

1. UI 统一性、规范性，因为组件都是由模板创建
2. 运营/研发 学习成本低、出错率低

**缺点：**

1. 组件枚举、静态资源体积上涨不可控
2. 灵活度较低、组件物料有限、无法满足个性化需求
3. 团队协作问题： 最开始活动平台用于小部门，后来大家觉得还不错就个业务部门都开始使用了起来。所以个业务团队之间就面临着共建、协作的问题。

**解决方案：**

因此，提出了微组件市场结合 WebIDE 的解决方案。微组件市场解决 1、2 两个问题，WebIDE 来解决团队协作的问题

## 微组件

![image-20220914101720088](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914101720088.png)

**第一部分**：是 IDE 侧，主要解决协作问题。可以在线编码，并且实时预览

**第二部分**：组件市场，解决静态资源上涨以及灵活度较低的问题

**右侧是消费侧**：后台搭建部分就有之前静态的 parker- components，变为动静结合的方式。动态部分由组件市场提供

有一个**分治**的思想，将一个大问题分解为多个小问题：第一个是怎么实现组件的远程加载；第二部分就是 IDE 的搭建

### 微组件探索

**微组件**：这个微字大家首先想到的就是微前端：**多个团队通过独立发布功能的方式，来共同构建 web 应用的技术手段**

![image-20220914102254522](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914102254522.png)

从远程加载组件我们再谈模块化：

**模块风格：**AMD/CMD/UMD/ESM

- 使用模块化思路可简化为四大步骤：**打包、上传、加载、执行**
- 这四种风格其实都能实现从远程加载的能力

大家都知道 React 的组件本质也是函数

**umd 风格**

- umd 是一种兼容的方式，将函数组件进行打包，挂载在 window 对象上。useEffect 阶段将打包过后的代码进行 eval。eval 完成，window 可以取出函数并且执行即可
- 基于这种方式，C 端需要从工程化上进行简单的改造，将一些通用的 lib 提取成 umd 的公共模块
- 但是一些 package 是没有提供 umd 风格打包的；所以**这不是一个最佳实践**
- 这种方式，我理解应该可以实现 React-In-Vue。不过对于微组件的体积来说可能有相对较大

**commonjs 风格**

- 先给大家看一下，webpack 打包的产物结构。对于 webpack 构建的产物有一个包裹函数的概念。也就是标红的那一部分。本质就是 **IIFE**。对于产物结果来说：es 到 cjs 的转换过程
- require 约等于 import，也就是依赖
- module 的 exports 和 export 所对应 ，也就是导出

![image-20220914102601428](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/image-20220914102601428.png)

- 基于这种思路，先模拟 cjs 风格的产物，使用 new Function 的形式去执行构建完成的代码；code 的结构其实和私有的 module 保持一致
- new Function 执行的时候不会找自己的作用域而是会优先找上下文的作用域，这样我们 fake 的 module 上就可以挂载上函数
- 对于依赖项（也就是 ES6 的import）的处理，将宿主环境的 lib（比如 React、parker-components） 把作为 require 传入。这样微组件就不在单独依赖公共包，而是依赖宿主环境的依赖包
- 在生产环境中，把这部分核心逻辑封装成了 **microComponent** 给到了 C 端。
- 基于以上思路基本上就可以完成，**从远程加载组件**。**并且他的依赖是基于运行时的依赖，而不需要将依赖注入到组件本身，可以减少产物的体积。**

AMD/CMD 应该也能完成，但需要借助第三方的 lib，比如 requirejs 和 sea.js

### 微前端探索

现目前比较主流的微前端方案：**Qiankun 和 Garfish 提供了基于应用级别比较完整的微前端方案**

理想情况是基于组件的粒度进行加载，现实是 Qiankun 只提供了页面基本的引用。如果就 Qiankun 来进行应用升级，这对于微组件来说会过重。**如果引进来就有一点杀鸡焉用宰牛刀的味道了**

适用场景：

-  多路由下的工作台
-  跨空间、跨时间维度导致团队内技术体系无法统一

 qiankun 特性

- 📦 **基于** **[single-spa](https://github.com/CanopyTax/single-spa)** 封装，提供了更加开箱即用的 API
- 📱 **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是  React/Vue/Angular/JQuery 还是其他等框架
- 💪 **HTML** **Entry 接入方式**，让你接入微应用像使用 iframe 一样简单
- 🛡 **样式隔离**，确保微应用之间样式互相不干扰
- 🧳 **JS** **沙箱**，确保微应用之间 全局变量/事件 不冲突
- ⚡️ **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
- 🔌 **umi 插件**，提供了 [@umijs/plugin-qiankun](https://github.com/umijs/plugins/tree/master/packages/plugin-qiankun) 供 umi 应用一键切换成微前端架构系统

Garfish 特性

- Garfish 微前端子应用支持任意多种框架、技术体系接入
- Garfish 微前端子应用支持「**独立开发**」、「**独立测试**」、「**独立部署**」
- 强大的预加载能力，自动记录用户应用加载习惯增加加载权重，应用切换时间极大缩短
- 支持依赖共享，极大程度的降低整体的包体积，减少依赖的重复加载
- 内置数据收集，有效的感知到应用在运行期间的状态
- 支持多实例能力，可在页面中同时运行多个子应用提升了业务的拆分力度

### ModuleFederation(模块联邦)

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/16631228154291.png)

那基于这个思路，我需要会从 **数据库** 拿到所有组件信息，去生成 webpack.config 的文件、得到依赖关系）。如果组件越来越多，这份配置文件也将会变得无比巨大。本质是没有解决枚举这个问题的，只是将业务侧枚举交给 webpack 枚举而已

- **去中心化**：我可以把自己的模块暴露出来作为别人的依赖。我也可以依赖别人
- **编译时确定依赖关系**：模块联邦本质也是 Webpack 的插件。所以如果要用模块联邦我们本质就是要对 webpack 进行配置，那这份依赖关系是要提前知道的（比如：这里的 App1 依赖远程的App2
- **TreeShaking 问题：**可以提取公共依赖，但是无法摇掉自己 dead code
- **工具链强绑定：**第一个讲的去中心化，各自都是要依赖webpack5+ 以上的，所以用了webpack 基本上可以和其他构建工具说再见了

**微组件特性总结**

- 组件入库、易于检索
- 与页面结耦，可按需加载
- 基于组件级别的快速回滚

## IDE

### Stackblitz

我前面提到的模块联邦的 DEMO 就是基于这个 WebIDE 写的

[WebIDE online 演示](https://stackblitz.com/edit/node-6wlpfk?file=package.json)

[仓库地址](https://github.com/stackblitz/core)

推出了 [WebContainer](http://blog.stackblitz.com/posts/introducing-webcontainers/) 的概念，提供了**非容器化方案的纯前端Node 环境**，简单来说就是用浏览器去模拟 Node 环境。目前该方案不开源，目前猜测较多的是：

1.  使用 **WebAssembly** 提供了 Node 的环境（`使用 wasm 编译 node/deno/go 的模块`），从而实现不需要远程机器，全部都跑在浏览器的一个 IDE。（All in browser！）

2.  **ServiceWorker** 实现**请求拦截**

3.  客户端流式渲染（Client Stream）

   Stream 是支持 Node.js 应用程序的基本概念之一。 它们是一种数据处理方法，用于依次读写数据的输入并输出。其优势可从内存/时间上体现：

   - 内存：不需要从内存中一次性加载大量（或整个）数据
   - 时间效率：一旦有了数据，就可以开始处理，这大大减少开始处理数据的时间，而不必等到整个数据加载完毕再进行处理

在浏览器中，可以使用 TextDecoderStream 实现流式渲染。相关资料可查阅：

[使用 fetchAPI 处理流式请求](https://web.dev/i18n/zh/fetch-upload-streaming/)

MDN: [TextDecoderStream](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream)

[web container：web build web](https://zhuanlan.zhihu.com/p/374221863)

题外话：React18 SSR 也基于 `renderToPipeableStream` 进行了优化，以便 HTML能够快速响应浏览器。

[New Suspense SSR Architecture in React 18 · Discussion #37 · reactwg/react-18](https://github.com/reactwg/react-18/discussions/37)

[Upgrading to React 18 on the server · Discussion #22 · reactwg/react-18](https://github.com/reactwg/react-18/discussions/22)

**优点：**不消耗远程资源

**缺点：**在浏览器模拟 Node 环境，模拟各个系统可能会有所缺失。

### VS C**ode流派**

代表有 [coder](https://coder.com/) ，[code-server](https://github.com/coder/code-server)，[codespaces](http://github.com/features/codespaces)

更注重 IDE 部分，没有视图层也就是沙箱预览那部分，就相当于网页版的 VScode，相对于 Stackblitz 他有一层 Express 的 Node 服务打通和本地文件系统的一些交互

比如网页版进行的文件/文件夹系统的操作，就是发起了请求。通过底层 Node 服务来完成对磁盘进行操作

### Eclipse/Theia or Eclipse/che

[Eclipse Theia 揭秘之技术架构篇](https://blog.csdn.net/lannister_awalys_pay/article/details/117530361)

缺点：在 React 的应用中，只能通过 iframe 的形式嵌入。（https://github.com/eclipse-theia/theia/issues/3104），没有办法和现有的应用程序所整合

### Codesandbox

综合起来，还是官方的 Codesandbox 提供的React lib 比较贴合我们的诉求

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/16631231194594.png)



**Sandpack-react** 提供了 React 组件的封装，可以应用他提供的能力快速构建出一个 mini 编辑器。她的功能包含了在线编码，主题配置、沙箱预览

## Codesandbox

### codesandbox 原理

比如在网页版安装 React，Web 端会发送安装依赖的请求，底层 **express** 接收到请求中的包名以及包版本。入口依赖分析（**browser、module、main、unpkg** 等字段找到 npm 包入口文件），递归分析并生成依赖图谱 **manifest.json：依赖路径和依赖的内容**

**最后返回** manifest.json 交由 **Sandbox 进行在线编译。在线编译和 babel 的原理类似，会生成 AST 文件，在递归执行编译后的代码。**我猜测没有使用 Express 直接编译好的结果是为了减轻服务器的压力。

https://github.com/mcuking/blog/issues/86

### codesandbox 壁垒

这个过程中，Preview 部分是一个 **iframe**。源码通过 postMessage 和摩纳哥 Editor 通信，直接使用这个沙箱预览，我们可以编写简单的组件。但组件内去请求后端接口是非常常见的，而这个 iframe 的地址是由 codesandox 提供所以就会面临**跨域**的问题

同时：没有办法实现私有 **npm 包**的引用，也就是我们无法直接使用 paker-components

那接下来就要给大家隆重介绍一下 esbuild-wasm 能力了

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/16631232721367.png)

**ESbuild** 新一代的构建工具嘛，相信大家也是耳熟能祥了。Esbuild 在资源打包这种 CPU 密集场景下，基于 Go 更具性能优势

**WebAssembly** 并不是一种新的语言。实际上 wasm 是体积小且加载快的[二进制格式](http://webassembly.org.cn/docs/binary-encoding/)， 其目标就是充分发挥 [硬件](http://webassembly.org.cn/docs/portability/#assumptions-for-efficient-execution) 能力以达到原生执行效率。具有一定的可移植性，WebAssembly 不仅可以运行在浏览器上，也可以运行在 [非web](http://webassembly.org.cn/docs/non-web/)

综上来看，Esbuild-Wasm 结合起来就是快 + 跨平台（意思就是我可以在 Web 端进行实时打包构建）。浏览器端使用 wasm 初始化完 ESbuild 之后，调用方式和 Node 环境下是一样的

还记得我们之前讲的实现微组件的 cjs 模块化方案？右侧沙箱预览的 iframe 替换成了由 ESbuild 的产物使用 new Function 的形式进行实时的渲染

**使用 Esbuild-Wasm 就可以实现线打包 Web 化，我们能够解决跨域的问题。**

**第二个问题是内网包 + http 类的资源处理。**

对于各类构建工具而言，对模块的核心处理主要包含两部分：

1. 模块之间的依赖关系，模块依赖关系需要生产模块依赖图，一般称之为 **ModuleGragh**。比如在 ES6 的语法中 import sth from path。解析依赖关系这个过程叫做 **resolve** 处理（webpack 里叫factory.hooks.resolver): 根据一个 moduleid 决定实际的的模块地址）
2. 模块内容本身：webpack 对应的就是 loader

ESbuild 对于其他构建工具，最出色的就是对于Virtual module（虚拟模块的）的支持

构建器一般会处理两种路径形式的模块：一种是真实的磁盘文件路径，另一种路径并不对应真实的文件路径，而是需要根据**路径形式**生成对应的内容即 **virtual module**

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/16631232721378.png)



1. stream-import 可以类比为 snowpack 的 streaming import，可以实现从远程加载 pkg 包，并且转换成 ArrayBuffer 的形式给到 ESbuild。官网给到的 http 式例是基于 Node 环境的，替换成浏览器环境即可
2. memery virtual module 可以将运行时的内存对象给到 esbuild
3. function virtual module 可以作为函数导入
4. 而 glob module 可以作为函数导入，这个有点类似于 https://vitejs.dev/guide/features.html#glob-import

基于esbuild的 wasm 能力，可以打包web 化，利用 virtualbmoudle 的能力可以完成http的请求加载，以及内网包的复用

### 基于 **WebIDE 的 bundler 设计理念：**

- 本地 file:  memoryVM （网页模拟文件系统）
- 私有 npm：提前下载 node_modules, 通过 require 注入
- 外网 npm： unpkg/skypack 动态拉取

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/166312336798813.png)

**其他优化**

1.  基于 WebIDE 的数据容灾
2.  C 端 JS 安全沙箱
3.  WebWorker ESLint 

**IDE 特性总结：**

- 免去本地依赖安装、协同开发
- 组件创建、更新可视化操作，流程简单
- 没有 DSL/Schema、学习成本低

## 基于 WebIDE 和 微组件的产研流程

![img](https://gitee.com/lilyn/pic/raw/master/lagoulearn-img/166312352431316.png)